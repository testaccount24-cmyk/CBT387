   /********************************************************************
   *                                                                   *
   *                 STONY BROOK PASCAL 360 COMPILER                   *
   *             PASS 2 -- GENERATION OF SYMBOLIC TRIPLES              *
   *                                                                   *
   ********************************************************************/

   /*

   COPYRIGHT (C) 1976 DEPARTMENT OF COMPUTER SCIENCE, SUNY AT STONY BROOK.

   */



   /* SET UP SOME CONVENIENT ABBREVIATIONS FOR PRINTER CONTROL */
   DECLARE PAGE CHARACTER INITIAL('1');
   DECLARE EJECT_PAGE LITERALLY 'OUTPUT(1)=PAGE';
   DECLARE DOUBLE CHARACTER INITIAL('0');
   DECLARE DOUBLE_SPACE LITERALLY 'OUTPUT(1)=DOUBLE';
   DECLARE X1 CHARACTER INITIAL(' ');
   DECLARE X2 CHARACTER INITIAL('  ');
   DECLARE X4 CHARACTER INITIAL('    ');
   DECLARE X70 CHARACTER INITIAL(
      '                                                                      ');

   DECLARE TRUE LITERALLY '1', FALSE LITERALLY '0', FOREVER LITERALLY 'WHILE 1';
   DECLARE NULL LITERALLY '-1';
   DECLARE NUL LITERALLY '"FFFF"';
   DECLARE MAXINT FIXED INITIAL (2147483647);

   /* THE PARSE TREE */
   DECLARE PARSE_TREE(7200) BIT(16);
   DECLARE MULTIPLICITY LITERALLY 'PARSE_TREE';
   DECLARE TREE_SIZE FIXED;

   /* THE SYMBOL TABLE */
   DECLARE IDENTITY_LENGTH LITERALLY '500';
   DECLARE TABLE_LENGTH LITERALLY '850';
   DECLARE IDENTITY (IDENTITY_LENGTH) CHARACTER INITIAL (
      'FALSE', 'TRUE', 'NIL', '(..)', 'INTEGER', 'BOOLEAN', 'REAL', 'CHAR',
      'TEXT', 'INPUT', 'OUTPUT', 'ABS', 'SQR', 'ODD', 'SUCC', 'PRED', 'ORD',
      'CHR', 'TRUNC', 'EOF', 'SIN', 'COS', 'EXP', 'LN', 'SQRT', 'ARCTAN',
      'ROUND', 'EOLN', 'GET', 'PUT', 'RESET', 'REWRITE', 'NEW', 'READ', 'WRITE',
      'PACK', 'UNPACK', 'MAXINT', 'DISPOSE', 'PAGE', 'READLN', 'WRITELN',
      'CLOCK', 'INTFIELDSIZE', 'BOOLFIELDSIZE', 'REALFIELDSIZE',
      'DECIMAL_PLACES');
   DECLARE STRUCTYPE (TABLE_LENGTH) BIT(16) INITIAL (
      1, 1, 3, 11, 14, 1, 14, 1, 6, 6,
      6, 10, 10, 10, 10, 10, 10, 10, 10, 10,
      14, 14, 14, 14, 14, 14, 10, 10, 10, 10,
      10, 10, 10, 10, 10, 10, 10, 14, 10, 10,
      10, 10, 10, 14, 14, 14, 14);
   DECLARE DATATYPE (TABLE_LENGTH) BIT(16) INITIAL (
      5, 5, 2, 3, 4, 5, 6, 7, 7, 8,
      8, NUL, NUL, 5, NUL, NUL, 4, 7, 4, 5,
      6, 6, 6, 6, 6, 6, 4, 5, NUL, NUL,
      NUL, NUL, NUL, NUL, NUL, NUL, NUL, 4, NUL, NUL,
      NUL, NUL, 4, 4, 4, 4, 4);
   DECLARE VAR_TYPE (TABLE_LENGTH) BIT(16) INITIAL (
      2, 2, 2, 2, 4, 4, 4, 4, 4, 1,
      1, 5, 5, 5, 5, 5, 5, 5, 5, 5,
      5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
      5, 5, 5, 5, 5, 5, 5, 2, 5, 5,
      5, 5, 5, 1, 1, 1, 1);
   DECLARE OWNER(TABLE_LENGTH) BIT(16);
   DECLARE VALUE(TABLE_LENGTH) BIT(32);
   DECLARE WHERE_DECL(IDENTITY_LENGTH) BIT(16);
   DECLARE N_LOOKUPS(IDENTITY_LENGTH) BIT(16);
   DECLARE S_LIST(TABLE_LENGTH) BIT(16);
   DECLARE STORAGE_LNGTH  (TABLE_LENGTH) FIXED;
   DECLARE PSEUDO_REG (TABLE_LENGTH) BIT(16);
   DECLARE DISPLACEMENT (TABLE_LENGTH) FIXED;
   DECLARE SYMB_LINK(IDENTITY_LENGTH) BIT(16);
   DECLARE N_DECL_SYMB BIT(16);
   DECLARE N_ANONYMOUS_SYMB BIT(16);
   DECLARE N_PREDECLARED_SYMB LITERALLY '46';
   DECLARE FIRST_LITERAL BIT(16);

   /* POINTERS TO THE PREDECLARED CONSTANTS */
   DECLARE FALSEPTR    BIT(16) INITIAL(00),
           TRUEPTR     BIT(16) INITIAL(01),
           NILPTR      BIT(16) INITIAL(02),
           EMPTYSETPTR BIT(16) INITIAL(03),
           MAXINTPTR   BIT(16) INITIAL(37);

   /* POINTERS INTO THE SYMBOL TABLE TO THE PREDECLARED TYPES */
   DECLARE INTPTR  BIT(16) INITIAL(4),
           BOOLPTR BIT(16) INITIAL(5),
           REALPTR BIT(16) INITIAL(6),
           CHARPTR BIT(16) INITIAL(7),
           TEXTPTR BIT(16) INITIAL(8);

   /* POINTERS TO THE PREDECLARED TEXTFILE VARIABLES */
   DECLARE INPUTPTR  BIT(16) INITIAL(09),
           OUTPUTPTR BIT(16) INITIAL(10);

   /* POINTERS TO THE OUTPUT-FORMATTING VARIABLES */
   DECLARE INTFIELDSIZEPTR   BIT(16) INITIAL (43),
           BOOLFIELDSIZEPTR  BIT(16) INITIAL (44),
           REALFIELDSIZEPTR  BIT(16) INITIAL (45),
           DECIMAL_PLACESPTR BIT(16) INITIAL (46);

   /* POINTERS TO SOME OF THE STANDARD PROCEDURES */
   DECLARE ARCTANPTR  BIT(16) INITIAL(25),
           CLOCKPTR   BIT(16) INITIAL(42),
           GETPTR     LITERALLY '28',
           PACKPTR    LITERALLY '35',
           PAGEPTR    LITERALLY '39',
           PUTPTR     LITERALLY '29',
           READPTR    BIT(16) INITIAL(33),
           READLNPTR  BIT(16) INITIAL(40),
           SINPTR     BIT(16) INITIAL(20),
           SUCCPTR    BIT(16) INITIAL(14),
           TRUNCPTR   BIT(16) INITIAL(18),
           WRITEPTR   BIT(16) INITIAL(34),
           WRITELNPTR BIT(16) INITIAL(41);

   /* CHARACTER BUFFER USED IN SYMBOL TABLE AND PARSE TREE RESTORE ROUTINES */
   DECLARE SY_TEXT CHARACTER;

   /* BUFFER WHICH ONE PAGE (80 BYTES) OF THE GLOBAL ACTIVATION RECORD */
   DECLARE DATA_BYTES(79) BIT(8);

   /* GAP IS SET IN RESTORE_SY_TABLE AND USED IN READ_TREE TO FIX UP PARSE
      TREES, COMPENSATING FOR SYMBOL TABLE COMPACTIFICATION AT THE END OF
      PASS 1.                                                              */
   DECLARE GAP BIT(16);

   /* KEEP COUNT OF ERRORS ENCOUNTERED IN PASS 2 */
   DECLARE (ERROR_COUNT, SEVERE_ERRORS) FIXED;

   /* DECLARATIONS FOR THE TREE-TRAVERSAL ALGORITHM */
   DECLARE NODE#STACK#OFLO CHARACTER INITIAL(
      'COMPILER ERROR, NODE#STACK OVERFLOW');
   DECLARE NULREF CHARACTER INITIAL(
      'ATTEMPT TO ACCESS PARSE TREE BY A NULL REFERENCE POINTER');
   DECLARE NODE FIXED;
   DECLARE NPMAX LITERALLY '75';
   DECLARE NP FIXED;
   DECLARE (NODE#STACK, #POS_STACK) (NPMAX) BIT(16);
   DECLARE ROOT_OF_SUBTREE FIXED;

   /* BUFFER FOR STORING GENERATED TRIPLES */
   DECLARE TRIPLE_SIZE LITERALLY '7199';
   DECLARE TRIPLES(TRIPLE_SIZE) BIT(16);

   /* IC IS THE INSTRUCTION COUNT, THE INDEX INTO THE PROGRAM.
      N_TRIPLES IS THE INDEX OF THE FIRST FREE ELEMENT OF THE ARRAY TRIPLES. */
   DECLARE IC FIXED, N_TRIPLES BIT(16);

   /* STACK OF OPERANDS FOR TRIPLES */
   DECLARE #OPMAX LITERALLY '100';
   DECLARE OPERAND#STK(#OPMAX) BIT(16);
   DECLARE #OP FIXED;
   DECLARE OP#STACK#ERR CHARACTER INITIAL('OPERAND STACK OVERFLOW');

   /* OPERAND TYPE DEFINITION MASKS */
   DECLARE MASK_SYMBOL BIT(16) INITIAL("0000");
   DECLARE MASK_IMMEDIATE BIT(16) INITIAL("4000");
   DECLARE MASK_TRIPLE BIT(16) INITIAL("8000");
   DECLARE MASK_TEMP BIT(16) INITIAL("C000");

   /* CURRENT_LINE AND LAST_LINE KEEP TRACK OF OUR POSITION RELATIVE TO
      THE SOURCE TEXT. */
   DECLARE (CURRENT_LINE, LAST_LINE) FIXED;

   /* TOGGLES WHICH CONTROL THE AMOUNT OF PRINTOUT FROM PASS 2 */
   DECLARE (PRINT_TREES, PRINT_TRIPLES, PRINT_SYMBOLS, PRINT_CODE) BIT(1);
   DECLARE PRINT_STATISTICS BIT(1);

   /* MEASURE THE SIZE OF THE PASCAL PROGRAM BEING COMPILED */
   DECLARE (PROC_SEQUENCE_NUMBER, BASIC_BLOCKS) FIXED;

   /* LEXICAL LEVEL OF PROCEDURE CURRENTLY BEING PROCESSED */
   DECLARE CURRENT_LEVEL BIT(16);

   /* PR_CASES IS A BRANCH TABLE USED TO DIRECT THE ACTION TAKEN WHEN A NON-LEAF
         NODE OF THE PARSE_TREE IS VISITED THE FIRST TIME.             */
   DECLARE #_PRODS LITERALLY '81';
   DECLARE PR_CASES(#_PRODS) BIT(16) INITIAL(
      0, 3,0,10,0,0, 0,0,3,3,4, 0,0,0,6,7, 0,7,7,1,1, 7,7,0,0,0, 0,0,0,0,0,
      8,0,0,0,0, 0,0,0,0,0, 9,0,0,0,0, 9,7,11,0,0, 0,0,7,0,0, 0,0,0,0,0,
      0,0,5,0,5, 2,0,0,0,0, 5,0,5,2,7, 7,0,0,12,0, 0);
   DECLARE ALLOCATE_NEW_ROW BIT(1) INITIAL(TRUE);
   DECLARE ALLOCATE_ARRAY_ENTRY BIT(1) INITIAL(TRUE);
   DECLARE (OWNER_STACK, ARRAYS_ALLOCATED, STACK_LIMIT,
         HALFWORD_DISP) (64) FIXED;

   /*    THE ABOVE VARIABLES ARE ALL INDEXED BY CURRENT_LEVEL.
         CURRENT_LEVEL IS INCREMENTED IN PRODS. 1, 8, 9, 66, AND 68.
            OWNER_STACK(CURRENT_LEVEL) POINTS TO THE ENTRY IN THE SYMBOL TABLE
                  FOR THE PROCEDURE OR RECORD TYPE THAT PROVIDES THE
                  SURROUNDING CONTEXT OF A DECLARATION;
            ARRAYS_ALLOCATED IS INITIALIZED TO NULL;
            HALFWORD_DISP IS INITIALIZED TO 0;
            STACK_LIMIT IS INITIALIZED IN PROD NO. 1 TO CONST_POOL_SIZE + 12,
                  IN PRODS NO. 8 AND 9 TO THE SIZE OF THE DISPLAY ALLOCATION,
                  AND IN PRODS NO. 66 AND 68 TO 0.
        OWNER_STACK(CURRENT_LEVEL) IS REFERENCED IN NEARLY EVERY PRODUCTION, TO
            SET THE VALUE OF THE OWNER FIELD IN THE SYMBOL TABLE.
         STACK_LIMIT(CURRENT_LEVEL) GIVES THE VALUE, IN BYTES, OF THE NEXT FREE
            STORAGE LOCATION IN EACH ACTIVITION RECORD OR RECORD TYPE SEGMENT.
            SCALAR VARIABLES ARE ALLOCATED AS THEY ARE ENCOUNTERED, AND
            STRUCTURED TYPES REQUIRING MORE THAN 4 BYTES OF STORAGE ARE HELD BY
            A LIST BASED ON ARRAYS_ALLOCATED(CURRENT_LEVEL).
         HALFWORD_DISP RECORDS 'HOLES' OF 2-BYTE SIZE THAT HAVE BEEN LEFT IN THE
            ALLOCATED STORAGE.  THE VALUE OF STACK_LIMIT IS ALWAYS INCREMENTED
            IN MULTIPLES OF 4 BYTES TO SECURE FULLWORD ALIGNMENT.  WHEN A 2-BYTE
            VARIABLE IS ALLOCATED, HALFWORD_DISP IS SET TO POINT TO THE
            REMAINING TWO BYTES, IF ANY.
            BOTH STACK_LIMIT AND HALFWORD_DISP ARE REFERENCED AND SET BY
            PROCEDURES ALLOCATE_STORAGE AND ALLOCATE_ARRAY_STORAGE, WHICH ARE
            CALLED FROM PRODUCTIONS NO. 10, 12, 25, 66, 67 AND 68.
            ALLOCATE_STORAGE IS ALSO CALLED FROM PRODUCTION NO. 25.
         ARRAYS_ALLOCATED IS USED TO MAINTAIN THE HEAD OF A LIST OF STRUCTURED
            VARIABLES THAT ARE TO BE ALLOCATED STORAGE IN A SEGMENT AFTER ALL
            SCALAR VARIABLES IN THAT SEGMENT HAVE BEEN ALLOCATED STORAGE.
            THE PROCEDURE ALLOCATE_STORAGE BUILDS THE LIST AND IT IS PROCESSED
            BY THE PROCEDURE ALLOCATE_ARRAY_STORAGE.
         CURRENT_LEVEL IS DECREMENTED IN PRODS NO. 10 AND 66.  PRIOR TO
            DECREMENTING, A CALL IS MADE TO ALLOCATE_ARRAY_STORAGE.    */

   /* WHEN THE HEADING OF A FORWARD PROCEDURE DECLARATION IS PROCESSED, WE
      SAVE ITS ARRAYS_ALLOCATED, STACK_LIMIT, AND HALFWORD_DISP FOR WHEN THE
      BODY APPEARS, IN CASE THE PROCEDURE HAS LOCAL VARIABLES OF ITS OWN.
      HOWEVER, A STACK IS NOT ADEQUATE, SINCE WHEN SEVERAL FORWARD-DECLARED
      PROCEDURE BODIES ARE PENDING, THE BODIES MAY IN FACT APPEAR IN AN
      ARBITRARY ORDER.  WE THEREFORE USE THE HEAP FORWARD_SAVE(FORWARD_LENGTH).
      FORWARD_AVAIL POINTS TO THE HEADER OF A LIST OF USED NODES, AND
      FORWARD_LIMIT IS A POINTER TO THE AS YET UNUSED HEAP SPACE.             */
   DECLARE FORWARD_LENGTH LITERALLY '29';
   DECLARE FORWARD_SAVE(FORWARD_LENGTH) FIXED;
   DECLARE (FORWARD_AVAIL, FORWARD_LIMIT) BIT(16);

   /* VARIABLES USED IN DGNS ROUTINE FOR EMITTING ADD_DECIMAL INSTRUCTIONS */
   DECLARE DGNS#_STACK(NPMAX) BIT(1);
   DECLARE (DGNS#_TOP, DGNS#_GOTO) BIT(1);
   DECLARE DGNS#_DEPTH BIT(16) INITIAL (NUL);

   /* "WITH" STATEMENTS ARE IMPLEMENTED USING THE FOLLOWING DOUBLE_BARRELLED
      STACK :__   */
   DECLARE WITH_LENGTH LITERALLY '31';
   DECLARE (WITH_DATATYPE, WITH_VARIABLE) (WITH_LENGTH) BIT(16);
   DECLARE WITH_PTR BIT(16);

   /* A FIXUP LIST CONSISTS OF A CHAIN, THROUGH THE BRANCH ADDRESS (FIRST
         OPERAND) OF BRANCH TRIPLES, OF THOSE BRANCH TRIPLES WHOSE TARGET IS
         UNDETERMINED AS YET.  THE HIGH-ORDER BIT OF EACH FIXUP POINTER
         DETERMINES WHETHER THE BRANCH IS TO BE TAKEN TO A 'TRUE VALUE' TARGET
         (BIT IS ON) OR A 'FALSE VALUE' TARGET (BIT IS OFF).  LISTHEAD HOLDS THE
         HEAD OF ONE FIXUP LIST, AND FIX_LIST STACKS THE HEADS OF LEFT-OPERAND
         FIXUP LISTS (OF BINARY BOOLEAN OPERATORS).  FX HOLDS THE CURRENT
         LOGICAL VALUE ON WHICH TO BRANCH.  VALUES OF FX CORRESPONDING TO
         UNFULFILLED OPERATORS ARE STACKED IN THE FIRST OPERAND POINTERS -
         PARSE_TREE(NODE#STACK(NP) + 2).                                      */
   DECLARE BOOLTYPE CHARACTER INITIAL ('BOOLEAN EXPRESSION EXPECTED');
   DECLARE FIX_LIST(NPMAX) BIT(16);
   DECLARE LISTHEAD BIT(16), FX BIT(1);

   /* ENUMERATION TYPES --
      THESE ARE IMPLEMENTED BY READ-ONLY VARIABLES */

   /* TYPE STRUCTYPES =
        (STATEMENT, SCALAR, SUBRANGE, POINTER, ARRAY, PACKED_ARRAY, FILE,
         PACKED_FILE, RECORD, PACKED_RECORD, STANDARD, SET, PACKED_SET,
         ARITHMETIC);   */

   DECLARE STATEMENT     BIT(16) INITIAL(00),
           SCALAR        BIT(16) INITIAL(01),
           SUBRANGE      BIT(16) INITIAL(02),
           POINTER       BIT(16) INITIAL(03),
           ARRAY         BIT(16) INITIAL(04),
           PACKED_ARRAY  BIT(16) INITIAL(05),
           FILE          BIT(16) INITIAL(06),
           PACKED_FILE   BIT(16) INITIAL(07),
           RECORD        BIT(16) INITIAL(08),
           PACKED_RECORD BIT(16) INITIAL(09),
           STANDARD      BIT(16) INITIAL(10),
           SET           BIT(16) INITIAL(11),
           PACKED_SET    BIT(16) INITIAL(12),
           TAG           BIT(16) INITIAL(13),
           ARITHMETIC    BIT(16) INITIAL(14);

   /* TYPE VAR_TYPES =
        (TYPE_ID, VARIABLE, CONSTANT, LITERAL, TYPE, PROC, VAR_PARAM,
         PROC_PARAM, UNDEFINED, LABLE, TAG, CASELABEL, VARIANT, FIELD_ID,
         FORWARD, MULTDECL, VALUE_PARAM); */

   DECLARE TYPE_ID     BIT(16) INITIAL(00),
           VARIABLE    BIT(16) INITIAL(01),
           CONSTANT    BIT(16) INITIAL(02),
           LITERAL     BIT(16) INITIAL(03),
           TYPE        BIT(16) INITIAL(04),
           PROC        BIT(16) INITIAL(05),
           VAR_PARAM   BIT(16) INITIAL(06),
           PROC_PARAM  BIT(16) INITIAL(07),
           UNDEFINED   BIT(16) INITIAL(08),
           LABLE       BIT(16) INITIAL(09),
           CASELABEL   BIT(16) INITIAL(11),
           VARIANT     BIT(16) INITIAL(12),
           FIELD_ID    BIT(16) INITIAL(13),
           FORWARD     BIT(16) INITIAL(14),
           MULTDECL    BIT(16) INITIAL(15),
           VALUE_PARAM BIT(16) INITIAL(16);

   /* TYPE OP_CODES =
        (LOAD, MONITOR, TRUNCATE, FLOAT, BCH_TARGET, INDEX, TEMP, STORE, MOVE,
         ADD, SUBTRACT, MULTIPLY, DIVIDE, COMPARE, ADD_DECIMAL, GREATER, LESS,
         NOT, ADDFLT, SUBFLT, MPYFLT, DIVFLT, COMPAREFLT, GREATERFLT, LESSFLT,
         LOAD_ADDR, AND, OR, XOR, RSHIFT, LSHIFT, BAL, BCH, BNZ, BZ, BCT,
         PCALL, PRETURN, PARM, BLKMARK, PEND, TPOP, REM, ABS, ABSFLT, NEGATE,
         NEGATEFLT, LLESS, LGREATER, LCOMPARE, PROCPARM, CASE, CASE_TARGET, ODD,
         SQR, SQRFLT, ROUND, S_LENGTH, IN, INTO, LINE#, RANGE); */

   DECLARE LOAD        BIT(16) INITIAL(00),
           MONITOR     BIT(16) INITIAL(01),
           TRUNCATE    BIT(16) INITIAL(02),
           FLOAT       BIT(16) INITIAL(03),
           BCH_TARGET  BIT(16) INITIAL(04),
           INDEX       BIT(16) INITIAL(05),
           TEMP        BIT(16) INITIAL(06),
           STORE       BIT(16) INITIAL(07),
           MOVE        BIT(16) INITIAL(08),
           ADD         BIT(16) INITIAL(09),
           SUBTRACT    BIT(16) INITIAL(10),
           MULTIPLY    BIT(16) INITIAL(11),
           DIVIDE      BIT(16) INITIAL(12),
           COMPARE     BIT(16) INITIAL(13),
           ADD_DECIMAL BIT(16) INITIAL(14),
           GREATER     BIT(16) INITIAL(15),
           LESS        BIT(16) INITIAL(16),
           NOT         BIT(16) INITIAL(17),
           ADDFLT      BIT(16) INITIAL(18),
           SUBFLT      BIT(16) INITIAL(19),
           MPYFLT      BIT(16) INITIAL(20),
           DIVFLT      BIT(16) INITIAL(21),
           COMPAREFLT  BIT(16) INITIAL(22),
           GREATERFLT  BIT(16) INITIAL(23),
           LESSFLT     BIT(16) INITIAL(24),
           LOAD_ADDR   BIT(16) INITIAL(25),
           AND         BIT(16) INITIAL(26),
           OR          BIT(16) INITIAL(27),
           XOR         BIT(16) INITIAL(28),
           LSHIFT      BIT(16) INITIAL(29),
           RSHIFT      BIT(16) INITIAL(30),
           BAL         BIT(16) INITIAL(31),
           BCH         BIT(16) INITIAL(32),
           BNZ         BIT(16) INITIAL(33),
           BZ          BIT(16) INITIAL(34),
           BCT         BIT(16) INITIAL(35),
           PCALL       BIT(16) INITIAL(36),
           PRETURN     BIT(16) INITIAL(37),
           PARM        BIT(16) INITIAL(38),
           BLKMARK     BIT(16) INITIAL(39),
           PEND        BIT(16) INITIAL(40),
           TPOP        BIT(16) INITIAL(41),
           REM         BIT(16) INITIAL(42),
           ABS         BIT(16) INITIAL(43),
           ABSFLT      BIT(16) INITIAL(44),
           NEGATE      BIT(16) INITIAL(45),
           NEGATEFLT   BIT(16) INITIAL(46),
           LLESS       BIT(16) INITIAL(47),
           LGREATER    BIT(16) INITIAL(48),
           LCOMPARE    BIT(16) INITIAL(49),
           PROCPARM    BIT(16) INITIAL(50),
           CASE_JUMP   BIT(16) INITIAL(51),
           CASE_TARGET BIT(16) INITIAL(52),
           ODD         BIT(16) INITIAL(53),
           SQR         BIT(16) INITIAL(54),
           SQRFLT      BIT(16) INITIAL(55),
           ROUND       BIT(16) INITIAL(56),
           S_LENGTH    BIT(16) INITIAL(57),
           IN          BIT(16) INITIAL(58),
           INTO        BIT(16) INITIAL(59),
           LINE#       BIT(16) INITIAL(60),
           RANGE       BIT(16) INITIAL(61);

   /* TYPE COMPARISONS =
        (EQUAL_TO, GREATER_THAN, LESS_THAN, NOT_EQUAL_TO, LESS_EQ,
         GREATER_EQ); */

   DECLARE EQUAL_TO     BIT(16) INITIAL(0),
           GREATER_THAN BIT(16) INITIAL(1),
           LESS_THAN    BIT(16) INITIAL(2),
           NOT_EQUAL_TO BIT(16) INITIAL(3),
           LESS_EQ      BIT(16) INITIAL(4),
           GREATER_EQ   BIT(16) INITIAL(5);

   /*  VALUES USED IN THE ALLOCATION OF STORAGE ON THE RUNTIME STACK  */
   DECLARE CONST_POOL_SIZE FIXED;
   DECLARE DISPLAY_BYTES FIXED INITIAL(20);
   /* SL IS THE VARIABLE SET BY PROCEDURE COMPUTE_STORAGE_LENGTH  */
   DECLARE SL FIXED;

   /* LEFT HAND SIDES IN INTERNAL FORM OF GRAMMAR */
   DECLARE LEFT_PART(#_PRODS) CHARACTER INITIAL('', '<PROGRAM>', '<BLOCK>',
      '<STATEMENT LIST>', '<LABEL DECL>', '<CONST DECL>', '<TYPE DEFN>',
      '<PROC DECL LIST>', '<PROC DECL>', '<PROC DECL>', '<BODY>',
      '<VAR DECL LIST>', '<VAR DECL>', '<STATEMENT>', '<STATEMENT>',
      '<STATEMENT>', '<STATEMENT>', '<STATEMENT>', '<STATEMENT>', '<STATEMENT>',
      '<STATEMENT>', '<STATEMENT>', '<STATEMENT>', '<STATEMENT>', '<STATEMENT>',
      '<FORMAL PARAM>', '<FORMAL PARAM>', '<FORMAL PARAM>', '<CASE INSTANCE>',
      '<EXPRESSION>', '<EXPRESSION>', '<EXPRESSION>', '<EXPRESSION>',
      '<EXPRESSION>', '<EXPRESSION>', '<EXPRESSION>', '<EXPRESSION>',
      '<EXPRESSION>', '<EXPRESSION>', '<EXPRESSION>', '<EXPRESSION>',
      '<EXPRESSION>', '<EXPRESSION>', '<EXPRESSION>', '<EXPRESSION>',
      '<EXPRESSION>', '<EXPRESSION>', '<EXPRESSION>', '<EXPRESSION>',
      '<EXPRESSION>', '<EXPRESSION>', '<VARIABLE>', '<VARIABLE>', '<QUALIFIER>',
      '<QUALIFIER>', '<QUALIFIER>', '<QUALIFIER>', '<CONSTANT>', '<CONSTANT>',
      '<TYPE>', '<TYPE>', '<TYPE>', '<TYPE>', '<TYPE>', '<TYPE>', '<TYPE>',
      '<TYPE>', '<FIXED FIELD LIST>', '<VARIANT FIELD>', '<VARIANT INSTANCE>',
      '<STATEMENT>', '<TYPE>', '<TYPE>', '<TYPE>', '<TYPE>', '<ELEMENT>',
      '<ELEMENT>', '<PARAM TYPES>', '<PARAM TYPES>', '<PARAM TYPES>',
      '<PARAM TYPES>', '<ERROR>');

  /*             P R O C E D U R E S                                  */

PAD:
   PROCEDURE (STRING, WIDTH) CHARACTER;
      DECLARE STRING CHARACTER, (WIDTH, L) FIXED;

      DO WHILE LENGTH(STRING) + 70 < WIDTH;
         STRING = STRING || X70;
      END;
      L = LENGTH(STRING);
      IF L >= WIDTH THEN RETURN STRING;
      ELSE RETURN STRING || SUBSTR(X70, 0, WIDTH-L);
   END PAD;

I_FORMAT:
   PROCEDURE (NUMBER, WIDTH) CHARACTER;
      DECLARE (NUMBER, WIDTH, L) FIXED, STRING CHARACTER;

      STRING = NUMBER;
      L = LENGTH(STRING);
      IF L >= WIDTH THEN RETURN STRING;
      ELSE RETURN SUBSTR(X70, 0, WIDTH-L) || STRING;
   END I_FORMAT;

ERROR:
   PROCEDURE (MESSAGE, SEVERITY);
      DECLARE MESSAGE CHARACTER, SEVERITY FIXED;

      IF ERROR_COUNT = 0 THEN
         DO;
            EJECT_PAGE;
            OUTPUT = '*** PASS TWO DIAGNOSTICS:';
            DOUBLE_SPACE;
         END;
      ERROR_COUNT = ERROR_COUNT + 1;
      OUTPUT = '*** ERROR, ' || MESSAGE || '. DETECTED NEAR LINE ' ||
               CURRENT_LINE || '. ***';
      IF SEVERITY > 0 THEN SEVERE_ERRORS = SEVERE_ERRORS + 1;
   END ERROR;

   /*                  DIAGNOSTIC  DUMP  ROUTINES                     */

SY_TABLE_STAT:
   PROCEDURE (J);
      DECLARE J BIT(16);
      DECLARE LINE CHARACTER;
      DECLARE ID_FIELD FIXED INITIAL (12);
      DECLARE STRUCTYPES(14) CHARACTER INITIAL('STATMENT', 'SCALAR  ',
              'SUBRANGE', 'POINTER ', 'ARRAY   ', 'PKDARRAY', 'FILE    ',
              'PKD FILE', 'RECORD  ', 'PKDRECRD', 'STANDARD', 'SET     ',
              'PKD SET ', 'TAG     ', 'ARITHMET');
      DECLARE VAR_TYPES(16) CHARACTER INITIAL('        ', 'VARIABLE','CONSTANT',
              'LITERAL ', 'TYPE    ', 'PROC    ', 'VAR PARM', 'PROCPARM',
              'UNDEFINE', 'LABEL   ', '        ', 'CASELABL', 'VARIANT ',
              'FIELD ID', 'FORWARD ', 'MULTDECL', 'VAL PARM');

   LJUSTIFY:
      PROCEDURE (X, FIELDWIDTH);
         DECLARE (X, XTEMP) CHARACTER;
         DECLARE FIELDWIDTH FIXED;
         XTEMP = X;
         IF LENGTH(XTEMP) >= FIELDWIDTH THEN
            XTEMP = SUBSTR(XTEMP,0,FIELDWIDTH);
         ELSE XTEMP = XTEMP || SUBSTR(X70,0,FIELDWIDTH-LENGTH(XTEMP));
         LINE = LINE || XTEMP || X4;
      END LJUSTIFY;

   RJUSTIFY:
      PROCEDURE (X, FIELDWIDTH);
         DECLARE X FIXED;
         DECLARE FIELDWIDTH FIXED;
         DECLARE XTEMP CHARACTER;
         XTEMP = X;
         IF LENGTH(XTEMP) > FIELDWIDTH THEN
            LINE = SUBSTR(LINE,0,LENGTH(LINE)-LENGTH(XTEMP)+FIELDWIDTH);
         ELSE LINE = LINE || SUBSTR(X70, 0, FIELDWIDTH-LENGTH(XTEMP));
         LINE = LINE || XTEMP || X4;
      END RJUSTIFY;

      LINE = I_FORMAT(J,4);
      LINE = LINE || X2;
      IF J >= N_ANONYMOUS_SYMB THEN LINE = LINE || SUBSTR(X70,0,ID_FIELD+4);
      ELSE CALL LJUSTIFY(IDENTITY(J), ID_FIELD);
      CALL RJUSTIFY(DATATYPE(J), 4);
      LINE = LINE || STRUCTYPES(STRUCTYPE(J)) || X4 ||
          VAR_TYPES(VAR_TYPE(J)) || X4;
      IF OWNER(J) = NULL THEN
         LINE = LINE || SUBSTR(X70, 0, ID_FIELD + 4);
      ELSE IF OWNER(J) < N_ANONYMOUS_SYMB THEN
         CALL LJUSTIFY(IDENTITY(OWNER(J)), ID_FIELD);
      ELSE
         CALL LJUSTIFY('(' || OWNER(J) || ')', ID_FIELD);
      CALL RJUSTIFY(STORAGE_LNGTH(J),4);
      IF J < N_ANONYMOUS_SYMB THEN CALL RJUSTIFY(WHERE_DECL(J),4);
      ELSE LINE = LINE || SUBSTR(X70,0,8);
      CALL RJUSTIFY(S_LIST(J),4);
      CALL RJUSTIFY(VALUE(J),8);
      CALL RJUSTIFY(PSEUDO_REG(J),4);
      CALL RJUSTIFY(DISPLACEMENT(J),8);
      OUTPUT = LINE;
   END SY_TABLE_STAT;

SY_DUMP:
   PROCEDURE;
      DECLARE I BIT(16);
      EJECT_PAGE;
      OUTPUT = '      IDENTITY      DATATYPE  STRUCTYPE   VAR TYPE    OWNER
  ST LENGTH    LINE   S_LIST      VALUE  PSEUDO REG    DISP';
      OUTPUT = '';
      DO I = 0 TO N_DECL_SYMB - 1;
         CALL SY_TABLE_STAT(I);
      END;
   END SY_DUMP;

PARSE_TREE_DUMP:
   PROCEDURE (TREE);
      DECLARE A(127) BIT(16);   /* AUXILIARY STACK; CF KNUTH V.1 P.317 */
      DECLARE TREE BIT(16);   /* POINTER TO ROOT */
      DECLARE (TOP_OF_A,M,C,P) BIT(16);
      DECLARE LEAF LITERALLY 'PARSE_TREE(P+1)',
              PRODUCTION_NUMB LITERALLY 'PARSE_TREE(P+1)',
              LINE_NUMB LITERALLY 'PARSE_TREE(P+M+2)';
      DECLARE MARGIN CHARACTER;
      DECLARE INDENTATION BIT(16), (S1, S2) CHARACTER;
      DECLARE OVERFLOW_MESSAGE CHARACTER INITIAL(
         '*** AUXILIARY STACK OVERFLOW, PARSE TREE DUMP ABORTED');
      MARGIN = X70 || X70 || '|';
      INDENTATION = LENGTH(MARGIN) - 2;
      TOP_OF_A = 0;
      P = TREE;
      OUTPUT = 'PARSE_TREE AT THIS POINT IS:';
      DO FOREVER;
         IF P = NULL THEN
            DO;
               M = 0;
               S1 = '... EMPTY PRODUCTION ...';
            END;
         ELSE
            DO;
               M = MULTIPLICITY(P);
               IF M = 0 THEN
                  DO;
                     IF LEAF < N_ANONYMOUS_SYMB THEN
                        S1 = IDENTITY(LEAF);
                     ELSE IF (DATATYPE(LEAF)=INTPTR) | (DATATYPE(LEAF)=REALPTR)
                        THEN S1 = VALUE(LEAF);
                     ELSE
                        DO;
                           S1 = ' ';
                           BYTE(S1) = VALUE(LEAF) & "FF";
                        END;
                  END;
               ELSE S1 = PRODUCTION_NUMB || X1 || LEFT_PART(PRODUCTION_NUMB);
            END;
         S2 = SUBSTR(MARGIN,INDENTATION) || X1 || S1;
         S2 = PAD(S2,127);
         S1 = I_FORMAT(LINE_NUMB,4);
         IF P = NULL THEN S1 = '';
         OUTPUT = S2 || '|' || S1;
         IF M > 0 THEN
            DO;
               A(TOP_OF_A) = 0;
               TOP_OF_A = TOP_OF_A + 1;
               IF TOP_OF_A > 127 THEN
                  DO;
                     OUTPUT = OVERFLOW_MESSAGE;
                     RETURN;
                  END;
            END;
         DO C = - 1 TO M - 3;   /* STACK SUBTREES RIGHT TO LEFT */
            A(TOP_OF_A) = PARSE_TREE(P + M - C);
            TOP_OF_A = TOP_OF_A + 1;
            IF TOP_OF_A > 127 THEN
               DO;
                  OUTPUT = OVERFLOW_MESSAGE;
                  RETURN;
               END;
         END;
         IF M = 0 THEN
            DO;   /* UNSTACK SUBTREE */
               IF TOP_OF_A = 0 THEN RETURN;
               TOP_OF_A = TOP_OF_A - 1;
               P = A(TOP_OF_A);
               DO WHILE P = 0;
                  IF TOP_OF_A = 0 THEN RETURN;
                  INDENTATION = INDENTATION + 3;
                  TOP_OF_A = TOP_OF_A - 1;
                  P = A(TOP_OF_A);
               END;
            END;
         ELSE
            DO;    /* PREPARE TO DUMP LEFTMOST SUBTREE */
               P = PARSE_TREE(P + 2);
               INDENTATION = INDENTATION - 3;
            END;
      END;
   END PARSE_TREE_DUMP;

PRINT_COMPILE_TIME:
   PROCEDURE;
      DECLARE (COMPILE_TIME, L) FIXED, STRING CHARACTER;
      COMPILE_TIME = CLOCK_TRAP(NULL);   /* CANCELS CPU TIMER */
      STRING = COMPILE_TIME;   L = LENGTH(STRING);
      IF L < 5 THEN STRING = SUBSTR('00000', 0, 5 - L) || STRING;
      STRING = '0' || SUBSTR(STRING, 0, 3) || '.' || SUBSTR(STRING, 3, 2);
      OUTPUT(1) = STRING || ' SECONDS IN COMPILATION, NO CODE GENERATED.';
   END PRINT_COMPILE_TIME;

   /*                TREE - TRAVERSAL  PROCEDURES                     */

LEFTSON:
   PROCEDURE;
      IF NODE = NULL THEN CALL ERROR(NULREF, 1);
      ELSE
         DO;
            IF MULTIPLICITY(NODE) = 0 THEN NODE = NULL;
            ELSE
               DO;
                  IF NP >= NPMAX THEN
                     DO;
                        CALL ERROR(NODE#STACK#OFLO, 1);
                        NP = 0;
                     END;
                  NP = NP + 1;
                  NODE#STACK(NP) = NODE;
                  #POS_STACK(NP) = 1;
                  NODE = PARSE_TREE(NODE + 2);
                  IF NODE ¬= NULL THEN
                     CURRENT_LINE = PARSE_TREE(NODE + MULTIPLICITY(NODE) + 2);
               END;
         END;
   END LEFTSON;

RIGHT_BRO:
   PROCEDURE;
      IF MULTIPLICITY(NODE#STACK(NP)) > #POS_STACK(NP) THEN
         DO;
            NODE = PARSE_TREE(NODE#STACK(NP) + #POS_STACK(NP) + 2);
            #POS_STACK(NP) = #POS_STACK(NP) + 1;
            IF NODE ¬= NULL THEN
               CURRENT_LINE = PARSE_TREE(NODE + MULTIPLICITY(NODE) + 2);
         END;
      ELSE NODE = NULL;
   END RIGHT_BRO;

FATHER:
   PROCEDURE;
      IF NP < 1 THEN CALL ERROR(NULREF, 1);
      ELSE
         DO;
            NODE = NODE#STACK(NP);
            NP = NP - 1;
         END;
   END FATHER;

REPLACE:
   PROCEDURE (NEWSON);
      DECLARE NEWSON BIT(16);
      IF NP < 1 THEN CALL ERROR(NULREF, 1);
      ELSE PARSE_TREE(NODE#STACK(NP) + #POS_STACK(NP) + 1) = NEWSON;
   END REPLACE;

REPLACE_LEFT_BRO:
   PROCEDURE (NEWSON);
      DECLARE NEWSON BIT(16);
      IF (NP < 1) | (#POS_STACK(NP) < 2) THEN CALL ERROR(NULREF, 1);
      ELSE PARSE_TREE(NODE#STACK(NP) + #POS_STACK(NP)) = NEWSON;
   END REPLACE_LEFT_BRO;

   /*             TYPE  COMPATIBILITY  CHECKING  PROCEDURE            */

COMPTYPES:
   PROCEDURE (TYPE1, TYPE2) BIT(1);
      DECLARE (TYPE1, TYPE2) BIT(16);
      DECLARE COMP_STACKSIZE LITERALLY '50';
      DECLARE STACK1(COMP_STACKSIZE) BIT(16);
      DECLARE STACK2(COMP_STACKSIZE) BIT(16);
      DECLARE SP BIT(16);
      IF TYPE1 = TYPE2 THEN RETURN TRUE;
      SP = 1;  /* FIRST FREE STACK ELEMENT;  0 NOT USED */
      DO WHILE SP > 0;
         IF STRUCTYPE(TYPE1) ¬= STRUCTYPE(TYPE2) THEN RETURN FALSE;
         ELSE
            DO CASE STRUCTYPE(TYPE1);
               /* CASE 0 -- STATEMENT */
               RETURN FALSE;
               /* CASE 1 -- SCALAR */
               IF DATATYPE(TYPE1) ¬= DATATYPE(TYPE2) THEN
                  RETURN FALSE;
               ELSE
                  DO;
                     SP = SP - 1;
                     TYPE1 = STACK1(SP);
                     TYPE2 = STACK2(SP);
                  END;
               /* CASE 2 -- SUBRANGE */
               IF DATATYPE(TYPE1) ¬= DATATYPE(TYPE2) THEN
                  RETURN FALSE; /* UNDERLYING BASE TYPES MUST MATCH */
               ELSE IF VALUE(S_LIST(TYPE1)) ¬= VALUE(S_LIST(TYPE2)) THEN
                  RETURN FALSE; /* LOWBOUNDS MUST MATCH */
               ELSE IF STORAGE_LNGTH(TYPE1) ¬= STORAGE_LNGTH(TYPE2) THEN
                  RETURN FALSE; /* HIGHBOUNDS MUST MATCH */
               ELSE
                  DO;
                     SP = SP - 1;
                     TYPE1 = STACK1(SP);
                     TYPE2 = STACK2(SP);
                  END;
               /* CASE 3 -- POINTER */
               DO;
                  IF (TYPE1 ¬= NILPTR) & (TYPE2 ¬= NILPTR) THEN
                     IF (DATATYPE(TYPE1) ¬= DATATYPE(TYPE2)) THEN
                        RETURN FALSE;
                     /* ALTERNATIVE - CHECK FOR COMPATIBILITY OF REFERENCED
                                      TYPES.  MUST BEWARE OF CYCLES, HOWEVER */
                  SP = SP - 1;
                  TYPE1 = STACK1(SP);
                  TYPE2 = STACK2(SP);
               END;
               /* CASE 4 -- ARRAY */
               IF STORAGE_LNGTH(TYPE1) ¬= STORAGE_LNGTH(TYPE2) THEN
                  RETURN FALSE;
               ELSE
                  DO;
                     TYPE1 = DATATYPE(TYPE1);
                     TYPE2 = DATATYPE(TYPE2);
                  END;
               /* CASE 5 -- PACKED ARRAY */
               IF STORAGE_LNGTH(TYPE1) ¬= STORAGE_LNGTH(TYPE2) THEN
                  RETURN FALSE;
               ELSE
                  DO;
                     TYPE1 = DATATYPE(TYPE1);
                     TYPE2 = DATATYPE(TYPE2);
                  END;
               /* CASE 6 -- FILE */
               DO;
                  TYPE1 = DATATYPE(TYPE1);
                  TYPE2 = DATATYPE(TYPE2);
               END;
               /* CASE 7 -- PACKED FILE */
               DO;
                  TYPE1 = DATATYPE(TYPE1);
                  TYPE2 = DATATYPE(TYPE2);
               END;
               /* CASE 8 -- RECORD */
   CASE#8:     IF TYPE1 = TYPE2 THEN
                  DO;
                     SP = SP - 1;
                     TYPE1 = STACK1(SP);
                     TYPE2 = STACK2(SP);
                  END;
               ELSE IF STORAGE_LNGTH(TYPE1) ¬= STORAGE_LNGTH(TYPE2) THEN
                  RETURN FALSE;
               ELSE
                  DO;
                     TYPE1 = S_LIST(TYPE1);
                     TYPE2 = S_LIST(TYPE2);
                     DO WHILE (VAR_TYPE(TYPE1) = FIELD_ID)
                             & (VAR_TYPE(TYPE2) = FIELD_ID);
                        STACK1(SP) = DATATYPE(TYPE1);
                        STACK2(SP) = DATATYPE(TYPE2);
                        TYPE1 = S_LIST(TYPE1);
                        TYPE2 = S_LIST(TYPE2);
                        SP = SP + 1;
                     END;
                     IF (TYPE1 ¬= NULL) | (TYPE2 ¬= NULL) THEN
                        RETURN FALSE;
                     ELSE
                        DO;
                           SP = SP - 1;
                           TYPE1 = STACK1(SP);
                           TYPE2 = STACK2(SP);
                        END;
                  END;
               /* CASE 9 -- PACKED RECORD */
               GOTO CASE#8;
               /* CASE 10 -- "STANDARD" */
               RETURN FALSE;
               /* CASE 11 -- SET */
               IF (TYPE1 ¬= EMPTYSETPTR) & (TYPE2 ¬= EMPTYSETPTR) THEN
                  DO;
                     IF VALUE(TYPE1) ¬= VALUE(TYPE2) THEN RETURN FALSE;
                     IF STORAGE_LNGTH(TYPE1) ¬= STORAGE_LNGTH(TYPE2) THEN
                        RETURN FALSE;
                     TYPE1 = DATATYPE(TYPE1);
                     TYPE2 = DATATYPE(TYPE2);
                  END;
               ELSE
                  DO;
                     SP = SP - 1;
                     TYPE1 = STACK1(SP);
                     TYPE2 = STACK2(SP);
                  END;
               /* CASE 12 -- PACKED SET */
               DO;
                  IF VALUE(TYPE1) ¬= VALUE(TYPE2) THEN RETURN FALSE;
                  IF STORAGE_LNGTH(TYPE1) ¬= STORAGE_LNGTH(TYPE2) THEN
                     RETURN FALSE;
                  TYPE1 = DATATYPE(TYPE1);
                  TYPE2 = DATATYPE(TYPE2);
               END;
               /* CASE 13 -- TAG */
               RETURN FALSE;
               /* CASE 14 -- ARITHMETIC */
               IF DATATYPE(TYPE1) ¬= DATATYPE(TYPE2) THEN RETURN FALSE;
               ELSE
                  DO;
                     SP = SP - 1;
                     TYPE1 = STACK1(SP);
                     TYPE2 = STACK2(SP);
                  END;
            END; /* CASE */
      END; /* WHILE */
      RETURN TRUE;
   END COMPTYPES;

COMPPROCS:
   PROCEDURE (PROC1, PROC2) BIT(1);
      DECLARE (PROC1, PROC2) BIT(16);
      /* RETURNS TRUE IFF PROCEDURE PROC1 CAN BE USED AS ACTUAL PARAMETER
         FOR FORMAL PROCEDURE PROC2.                                       */
      DECLARE PROC_STACKSIZE LITERALLY '32';
      DECLARE (STACK1, STACK2) (PROC_STACKSIZE) BIT(16), SP BIT(16);
      SP = 1;   /* FIRST STACK ELEMENT; 0 NOT USED */
      DO WHILE SP > 0;
         /* RETURN TYPES MUST BE COMPATIBLE */
         IF STRUCTYPE(PROC1) ¬= STRUCTYPE(PROC2) THEN RETURN FALSE;
         IF ¬COMPTYPES(DATATYPE(PROC1), DATATYPE(PROC2)) THEN RETURN FALSE;
         /* PARAMETER LISTS MUST BE COMPATIBLE */
         IF VAR_TYPE(PROC1) = PROC_PARAM THEN PROC1 = VALUE(PROC1);
         ELSE PROC1 = S_LIST(PROC1);
         IF VAR_TYPE(PROC2) = PROC_PARAM THEN PROC2 = VALUE(PROC2);
         ELSE PROC2 = S_LIST(PROC2);
         DO WHILE (PROC1 ¬= NULL) & (PROC2 ¬= NULL);
            IF VAR_TYPE(PROC1) ¬= VAR_TYPE(PROC2) THEN RETURN FALSE;
            IF VAR_TYPE(PROC1) = PROC_PARAM THEN
               DO;
                  STACK1(SP) = PROC1;
                  STACK2(SP) = PROC2;
                  SP = SP + 1;
               END;
            ELSE IF ¬COMPTYPES(DATATYPE(PROC1), DATATYPE(PROC2)) THEN
               RETURN FALSE;
            PROC1 = S_LIST(PROC1);
            PROC2 = S_LIST(PROC2);
         END;
         IF (PROC1 ¬= NULL) | (PROC2 ¬= NULL) THEN RETURN FALSE;
         SP = SP - 1;
         PROC1 = STACK1(SP);
         PROC2 = STACK2(SP);
      END;
      RETURN TRUE;
   END COMPPROCS;

   /*                   THE CODE EMITTING PROCEDURE                   */

EMIT_TRIPLE:
   PROCEDURE (OP_CODE, OPND1, OPND2, STOR_LENGTH);
      DECLARE (OP_CODE, OPND1, OPND2, STOR_LENGTH, NEW_LINE, LINE_MASK) BIT(16);
      DECLARE NEW_LINE_TRIPLE BIT(1);
      IF CURRENT_LINE <= LAST_LINE THEN
         NEW_LINE, LINE_MASK, NEW_LINE_TRIPLE = 0;
      ELSE IF (CURRENT_LINE - LAST_LINE) = 1 THEN
         DO;
            LAST_LINE, NEW_LINE = CURRENT_LINE;
            LINE_MASK = "0080";
            NEW_LINE_TRIPLE = FALSE;
         END;
      ELSE
         DO;
            LAST_LINE = CURRENT_LINE;
            NEW_LINE, LINE_MASK = 0;
            NEW_LINE_TRIPLE = TRUE;
         END;
      IF N_TRIPLES + 3*(NEW_LINE_TRIPLE + 1) > TRIPLE_SIZE THEN
         DO;
            CALL ERROR('STATEMENT PART OF BLOCK '
                       || IDENTITY(OWNER_STACK(CURRENT_LEVEL))
                       || ' IS TOO BIG',1);
            N_TRIPLES = 0;
         END;
      IF NEW_LINE_TRIPLE THEN
         DO;
            TRIPLES(N_TRIPLES) = LINE#;
            TRIPLES(N_TRIPLES + 1) = CURRENT_LINE;
            TRIPLES(N_TRIPLES + 2) = NULL;
            IC = IC + 1;
            N_TRIPLES = N_TRIPLES + 3;
         END;
      TRIPLES(N_TRIPLES) = SHL(STOR_LENGTH, 8) | LINE_MASK | OP_CODE;
      TRIPLES(N_TRIPLES + 1) = OPND1;
      TRIPLES(N_TRIPLES + 2) = OPND2;
      IC = IC + 1;
      N_TRIPLES = N_TRIPLES + 3;
   END EMIT_TRIPLE;

      /*             GENERATE SEQUENTIAL OUTPUT FILES                   */

REWIND:
   PROCEDURE (IS_OUTPUT_FILE, FILE#);
      DECLARE IS_OUTPUT_FILE BIT(1), FILE# FIXED;
      CALL INLINE("1B",0,0);                     /* SR   0,0               */
      CALL INLINE("43",0,0,IS_OUTPUT_FILE);      /* IC   0,IS_OUTPUT_FILE  */
      CALL INLINE("41",1,0,0,28);                /* LA  1,28               */
      CALL INLINE("58",2,0,FILE#);               /* L    2,FILE#           */
      CALL INLINE("05",12,15);                   /* BALR 12,15             */
   END REWIND;

COREIM_DESCRIPT:
   PROCEDURE (ADDRESS, LENGTH) CHARACTER;
      DECLARE (ADDRESS, LENGTH, DESCRIPTOR) FIXED;
      IF LENGTH = 0 THEN DESCRIPTOR = 0;
      ELSE DESCRIPTOR = SHL(LENGTH - 1, 24) + ADDRESS;
   /* WE RETURN DESCRIPTOR IN REGISTER 3 */
      CALL INLINE("58",3,0,DESCRIPTOR);          /* L    3,DESCRIPTOR      */
   END COREIM_DESCRIPT;

WRITE_TRIPLES:
   PROCEDURE;
      /* WRITE A CORE IMAGE OF THE TRIPLES BUFFER OUT TO A SEQUENTIALLY-
         ACCESSED FILE */
      DECLARE I BIT(16), TEXT CHARACTER;
      TEXT = '%TRIPLE';
      IF PRINT_CODE THEN TEXT = TEXT || 'E';
      ELSE TEXT = TEXT || X1;
      IF PRINT_TRIPLES THEN TEXT = TEXT || 'T';
      ELSE TEXT = TEXT || X1;
      TEXT = TEXT || IDENTITY(TRIPLES(0));
      OUTPUT(4) = TEXT;
      I = 0;
      DO WHILE I < N_TRIPLES;
         OUTPUT(4) = COREIM_DESCRIPT(ADDR(TRIPLES(I)), 80);
         I = I + 40;   /* 2 BYTES PER ARRAY ELEMENT */
      END;
      OUTPUT(4) = '%END';
   END WRITE_TRIPLES;

WRITE_SYMBOLS:
   PROCEDURE;
      DECLARE (I,J) FIXED, (LINE,S1,S2) CHARACTER;
      DECLARE ID CHARACTER;
      CALL REWIND(FALSE, 2);   /* REWIND TREES FILE */
      CALL REWIND(TRUE, 4);   /* REWIND TRIPLES FILE */
      IF PRINT_STATISTICS THEN S1 = 'D';
      ELSE S1 = X1;
      OUTPUT(3) = '%SYMB' || I_FORMAT(N_DECL_SYMB, 5)
                  || I_FORMAT(BASIC_BLOCKS, 5)
                  || I_FORMAT(PROC_SEQUENCE_NUMBER, 5) || S1;
      I = 0;
      DO WHILE I < N_DECL_SYMB;
         OUTPUT(3) = COREIM_DESCRIPT(ADDR(STORAGE_LNGTH(I)), 80);
         I = I + 20;
      END;
      I = 0;
      DO WHILE I < N_DECL_SYMB;
         OUTPUT(3) = COREIM_DESCRIPT(ADDR(PSEUDO_REG(I)), 80);
         I = I + 40;
      END;
      I = 0;
      DO WHILE I < N_DECL_SYMB;
         OUTPUT(3) = COREIM_DESCRIPT(ADDR(DISPLACEMENT(I)), 80);
         I = I + 20;
      END;
      OUTPUT(3) = '%END';
      CALL REWIND(TRUE, 3);   /* REWIND SYMBOL TABLE FILE */
   END WRITE_SYMBOLS;

EMIT_DATA_BYTES:
   PROCEDURE (DATA_PTR);
      DECLARE DATA_PTR BIT(16);
      DECLARE (I, J, INDEX) BIT(16);
      /* THIS PROCEDURE CREATES AN ENTRY INTO THE GLOBAL ACTIVATION RECORD
         FOR THE SYMBOL TABLE ENTRY POINTED TO BY DATA_PTR.  ONE PAGE (80 BYTES)
         OF THIS ACTIVATION RECORD IS KEPT IN CORE IN THE GLOBAL ARRAY
         DATA_BYTES.  WHEN DATA_BYTES BECOMES FULL, IT IS OUTPUTTED TO
         OUTPUT(5), AND HALFWORD_DISP(1) BECOMES ZERO.   */

   WRITE_DATA:
      PROCEDURE;
         DECLARE J BIT(16);
         OUTPUT(5) = COREIM_DESCRIPT(ADDR(DATA_BYTES), 80);
         HALFWORD_DISP(1) = 0;
         CALL INLINE("D7","4","F",DATA_BYTES, DATA_BYTES);
                                       /* XC   DATA_BYTES(80), DATA_BYTES  */
      END WRITE_DATA;

      INDEX = DISPLACEMENT(DATA_PTR) MOD 80;
      IF VAR_TYPE(DATA_PTR) = CONSTANT THEN
         DO I = 1 TO STORAGE_LNGTH(DATA_PTR);
            IF INDEX = 0 THEN CALL WRITE_DATA;
            J = SHL(STORAGE_LNGTH(DATA_PTR) - I, 3);
            DATA_BYTES(INDEX) = SHR(VALUE(DATA_PTR), J);
            INDEX = (INDEX + 1) MOD 80;
         END;
      ELSE IF VAR_TYPE(DATA_PTR) = LITERAL THEN
         DO I = 0 TO STORAGE_LNGTH(DATA_PTR) - 1;
            IF INDEX = 0 THEN CALL WRITE_DATA;
            DATA_BYTES(INDEX) = BYTE(IDENTITY(DATA_PTR), I);
            INDEX = (INDEX + 1) MOD 80;
         END;
      ELSE /* VAR_TYPE(DATA_PTR) IN (.VARIABLE, VAR_PARAM, PROC_PARAM.) */
         IF (INDEX = 0) | (INDEX + STORAGE_LNGTH(DATA_PTR) > 80) THEN
            DO;
               CALL WRITE_DATA;
               DO I = 1 TO (STORAGE_LNGTH(DATA_PTR) - INDEX - 1) / 80;
                  OUTPUT(5) = COREIM_DESCRIPT(ADDR(DATA_BYTES), 80);
               END;
            END;
   END EMIT_DATA_BYTES;

PREPARE_POST_MORTEM_TABLES:
   PROCEDURE;
      DECLARE (I, OWNER_PTR, RELOCATION_INDEX, PROCSEQ#) FIXED,
                     ID_BUFFER CHARACTER, PMD_FILE BIT(16) INITIAL (7),
              SYT_CASE(16) BIT(8) INITIAL(0,2,4,0,3,1,0,0,0,0,0,0,0,0,0,0,0);
      /* SET_OF_SIMPLE_TYPES INCLUDES SCALAR, SUBRANGE, POINTER AND ARITHMETIC.
         BITS ARE ENUMERATED FROM THE RIGHT.   */
      DECLARE SET_OF_SIMPLE_TYPES BIT(16) INITIAL ("(1) 01000000 00001110");
      /* STORAGE OCCUPIED BY THE ARRAYS 'OWNER_STACK', 'ARRAYS_ALLOCATED',
         'STACK_LIMIT' AND 'HALFWORD_DISP' IS OVERLAID TO SAVE SPACE.   */
      DECLARE LIST_END LITERALLY 'OWNER_STACK',
              PROCEDURE_HEADING LITERALLY 'STACK_LIMIT';

   IS_STRING:
      PROCEDURE (TYPE_PTR) BIT(1);
         DECLARE TYPE_PTR BIT(16);   /* POINTER TO TYPE ENTRY IN SY_TABLE */
         RETURN (STRUCTYPE(TYPE_PTR) = ARRAY)
                & COMPTYPES(DATATYPE(TYPE_PTR), CHARPTR);
      END IS_STRING;

   WRITE_COLUMN:
      PROCEDURE (ARRAY_ADDR, ITEMS_PER_IMAGE, LIMIT);
         DECLARE (ARRAY_ADDR, ITEMS_PER_IMAGE, LIMIT, I, J) FIXED;
         I, J = 0;
         DO WHILE I <= LIMIT;
            OUTPUT(PMD_FILE) = COREIM_DESCRIPT(ARRAY_ADDR + J, 80);
            I = I + ITEMS_PER_IMAGE;
            J = J + 80;
         END;
      END WRITE_COLUMN;

      /* INITIALIZE LIST_END AND PROCEDURE_HEADING */
      DO I = 0 TO PROC_SEQUENCE_NUMBER;
         LIST_END(I), PROCEDURE_HEADING(I) = NULL;
      END;
      RELOCATION_INDEX = -1;
      DO I = 0 TO N_ANONYMOUS_SYMB - 1;
         DO CASE SYT_CASE(VAR_TYPE(I));
            /* CASE 0 -- NOT OT BE COPIED */
            WHERE_DECL(I) = NULL;
            /* CASE 1 -- A PROCEDURE HEADING */
            IF I > N_PREDECLARED_SYMB THEN
               DO;   /* A USER-DEFINED PROCEDURE */
                  IDENTITY(I) = PAD(IDENTITY(I), 12);
                  IDENTITY(I) = SUBSTR(IDENTITY(I),0,12);
                  IF DATATYPE(I) ¬= NULL THEN
                     DO;   /* A FUNCTION PROCEDURE */
                        DATATYPE(I) = WHERE_DECL(DATATYPE(I));
                        OWNER(I) = 4;   /* STORAGE_LNGTH */
                     END;
                  ELSE OWNER(I) = 0;
                  S_LIST(I) = NULL;
                  RELOCATION_INDEX, WHERE_DECL(I) = RELOCATION_INDEX + 1;
                  PROCEDURE_HEADING(VALUE(I)) = RELOCATION_INDEX;
               END;
            ELSE WHERE_DECL(I) = NULL;
            /* CASE 2 -- A VARIABLE */
            IF (SHR(SET_OF_SIMPLE_TYPES, STRUCTYPE(I)) & 1)
               | IS_STRING(DATATYPE(I)) THEN
               DO;
                  IDENTITY(I) = PAD(IDENTITY(I), 12);
                  IDENTITY(I) = SUBSTR(IDENTITY(I),0,12);
                  /* RELOCATE THE DATATYPE POINTER */
                  IF STRUCTYPE(I) = SUBRANGE THEN
                     DO;
                        VALUE(I) = VALUE(S_LIST(DATATYPE(I)));
                        DATATYPE(I) = WHERE_DECL(DATATYPE(DATATYPE(I)));
                     END;
                  ELSE
                     DO;
                        VALUE(I) = 0;
                        IF DATATYPE(I) >= N_ANONYMOUS_SYMB THEN
                           DO;
                              IF STRUCTYPE(I) = SCALAR THEN
                                 DATATYPE(I) = S_LIST(DATATYPE(I)) +
                                               RELOCATION_INDEX - I + 1;
                              ELSE /* CHARACTER ARRAY */
                                 DATATYPE(I) = WHERE_DECL(CHARPTR);
                           END;
                     ELSE DATATYPE(I) = WHERE_DECL(DATATYPE(I));
                     END;
                  OWNER_PTR = OWNER(I);
                  PROCSEQ# = VALUE(OWNER_PTR);
                  RELOCATION_INDEX, WHERE_DECL(I) = RELOCATION_INDEX + 1;
                  /* USE THE OWNER FIELD FOR STORAGE_LNGTH */
                  OWNER(I) = STORAGE_LNGTH(I);
                  S_LIST(I) = NULL;
                  /* ATTACH THIS SYT ENTRY TO THE LIST OF OWNER'S VARIABLES */
                  IF LIST_END(PROCSEQ#) = NULL THEN
                     S_LIST(OWNER_PTR) = RELOCATION_INDEX;
                  ELSE S_LIST(LIST_END(PROCSEQ#)) = RELOCATION_INDEX;
                  LIST_END(PROCSEQ#) = I;
               END;
            ELSE WHERE_DECL(I) = NULL;
            /* CASE 3 -- A TYPE */
            IF (STRUCTYPE(I) = SCALAR) | (STRUCTYPE(I) = ARITHMETIC) THEN
               DO;
                  IDENTITY(I) = PAD(IDENTITY(I), 12);
                  IDENTITY(I) = SUBSTR(IDENTITY(I),0,12);
                  OWNER(I) = STORAGE_LNGTH(I);
                  RELOCATION_INDEX, WHERE_DECL(I), DATATYPE(I) =
                     RELOCATION_INDEX + 1;
               END;
            ELSE WHERE_DECL(I) = NULL;
            /* CASE 4 -- A CONSTANT */
            IF STRUCTYPE(I) = SCALAR THEN
               DO;
                  IDENTITY(I) = PAD(IDENTITY(I), 12);
                  IDENTITY(I) = SUBSTR(IDENTITY(I),0,12);
                  RELOCATION_INDEX, WHERE_DECL(I) = RELOCATION_INDEX + 1;
                  IF VALUE(I) = 0 THEN
                     DO;
                        IF DATATYPE(I) >= N_ANONYMOUS_SYMB THEN
                           DATATYPE(I) = I;
                        S_LIST(DATATYPE(I)) = RELOCATION_INDEX;
                        DATATYPE(I) = WHERE_DECL(DATATYPE(I));
                     END;
                  ELSE DATATYPE(I) = DATATYPE(I - 1);
               END;
            ELSE WHERE_DECL(I) = NULL;
         END;   /* CASE */
      END;   /* DO I */
      DATATYPE(FALSEPTR), DATATYPE(TRUEPTR) = WHERE_DECL(BOOLPTR);
      /* COMPRESS THE SYMBOL TABLE */
      N_DECL_SYMB = 2;
      DO I = 3 TO N_ANONYMOUS_SYMB - 1;
         IF WHERE_DECL(I) ¬= NULL THEN
            DO;
               IDENTITY(N_DECL_SYMB) = IDENTITY(I);
               DATATYPE(N_DECL_SYMB) = DATATYPE(I);
               VAR_TYPE(N_DECL_SYMB) = VAR_TYPE(I);
               STRUCTYPE(N_DECL_SYMB) = STRUCTYPE(I);
               OWNER(N_DECL_SYMB) = OWNER(I);
               S_LIST(N_DECL_SYMB) = S_LIST(I);
               DISPLACEMENT(N_DECL_SYMB) = DISPLACEMENT(I);
               VALUE(N_DECL_SYMB) = VALUE(I);
               N_DECL_SYMB = N_DECL_SYMB + 1;
            END;
      END;
      N_DECL_SYMB = N_DECL_SYMB - 1;
      /* OUTPUT THE POST MORTEM INFO */
      OUTPUT(PMD_FILE) = '%PMD ' || I_FORMAT(N_DECL_SYMB, 5)
                         || I_FORMAT(PROC_SEQUENCE_NUMBER, 5);
      /* WRITE OUT THE IDENTITY COLUMN */
      ID_BUFFER = '';
      DO I = 0 TO N_DECL_SYMB;
         ID_BUFFER = ID_BUFFER || IDENTITY(I);
         IF LENGTH(ID_BUFFER) > 80 THEN
            DO;
               OUTPUT(PMD_FILE) = SUBSTR(ID_BUFFER,0,80);
               ID_BUFFER = SUBSTR(ID_BUFFER,80);
            END;
      END;
      OUTPUT(PMD_FILE) = ID_BUFFER;
      /* WRITE OUT THE OTHER SYMBOL TABLE COLUMNS OF INTEREST */
      CALL WRITE_COLUMN(ADDR(DATATYPE), 40, N_DECL_SYMB);
      CALL WRITE_COLUMN(ADDR(VAR_TYPE), 40, N_DECL_SYMB);
      CALL WRITE_COLUMN(ADDR(STRUCTYPE), 40, N_DECL_SYMB);
      CALL WRITE_COLUMN(ADDR(OWNER), 40, N_DECL_SYMB);
      CALL WRITE_COLUMN(ADDR(S_LIST), 40, N_DECL_SYMB);
      CALL WRITE_COLUMN(ADDR(DISPLACEMENT), 20, N_DECL_SYMB);
      CALL WRITE_COLUMN(ADDR(VALUE), 20, N_DECL_SYMB);
      /* WRITE THE PROCEDURE HEADING TABLE */
      CALL WRITE_COLUMN(ADDR(PROCEDURE_HEADING), 20, PROC_SEQUENCE_NUMBER);
      OUTPUT(PMD_FILE) = '%END';
      CALL REWIND(TRUE, PMD_FILE);
      IF ¬PRINT_SYMBOLS THEN RETURN;
      /* PRINT THE PROCEDURE HEADING TABLE */
      EJECT_PAGE;
      OUTPUT = 'PROCEDURE HEADING TABLE';
      DOUBLE_SPACE;
      DO I = 0 TO PROC_SEQUENCE_NUMBER;
         OUTPUT = IDENTITY(PROCEDURE_HEADING(I)) || X4 || 'INDEX = ' ||
                  I_FORMAT(PROCEDURE_HEADING(I), 4);
      END;
      N_DECL_SYMB = N_DECL_SYMB + 1;
      CALL SY_DUMP;
   END PREPARE_POST_MORTEM_TABLES;

   /*       PROCEDURES FOR EMITTING BLOCK COUNTERS FOR FLOW SUMMARY       */

DGNS#_PUSH:
  PROCEDURE;
      DGNS#_DEPTH = DGNS#_DEPTH + 1;
      DGNS#_GOTO, DGNS#_TOP, DGNS#_STACK(DGNS#_DEPTH) = FALSE;
   END DGNS#_PUSH;

DGNS#_POP:
   PROCEDURE;
      DGNS#_GOTO = DGNS#_TOP & (DGNS#_DEPTH > 0);
      DGNS#_DEPTH = DGNS#_DEPTH - 1;
      IF DGNS#_DEPTH >= 0 THEN
         DO;
            DGNS#_TOP = DGNS#_TOP | DGNS#_STACK(DGNS#_DEPTH);
            DGNS#_STACK(DGNS#_DEPTH) = DGNS#_TOP;
         END;
   END DGNS#_POP;

EMIT_ADD_DECIMAL:
   PROCEDURE;
      IF MONITOR_LINK(2) < 2 THEN RETURN;
      CALL EMIT_TRIPLE(ADD_DECIMAL, BASIC_BLOCKS, 1 | MASK_IMMEDIATE, 0);
      BASIC_BLOCKS = BASIC_BLOCKS + 1;
   END EMIT_ADD_DECIMAL;

NEXT_FREE_ROW:
   PROCEDURE FIXED;
         /* THIS PROCEDURE ALLOCATES A NEW SYMBOL TABLE ENTRY.  IT REFERS TO,
         AND UPDATES, THE GLOBAL VARIABLE N_DECL_SYMB.   */
      IF N_DECL_SYMB < TABLE_LENGTH THEN N_DECL_SYMB = N_DECL_SYMB + 1;
      ELSE CALL ERROR(
         'SYMBOL TABLE OVERFLOW WHILE ALLOCATING TEMPORARIES OR CONSTANTS', 1);
      RETURN N_DECL_SYMB - 1;
   END NEXT_FREE_ROW;

   /*           PROCEDURE FOR CREATING AN OPERAND OUT OF AN            */
   /*                        INTEGER CONSTANT.                         */

FINDCONST:
   PROCEDURE (INTCONST) BIT(16);
      /* WE CREATE AN INTEGER CONSTANT OPERAND FOR A TRIPLE.  IF IT IS
         TOO LARGE TO BE AN IMMEDIATE OPERAND, WE SEARCH THE SYMBOL TABLE
         FOR THE INTEGER CONSTANT INTCONST.  IF WE THEN DO NOT FIND IT,
         WE ENTER IT, AND RETURN ITS INDEX.                                */
      DECLARE INTCONST FIXED, INDEX BIT(16);
      IF (0 <= INTCONST) & (INTCONST < 4096) THEN
         /* RETURN AN IMMEDIATE OPERAND */
         RETURN INTCONST | MASK_IMMEDIATE;
      INDEX = S_LIST(INTPTR);
      DO WHILE INDEX ¬= NULL;
         IF VALUE(INDEX) = INTCONST THEN RETURN INDEX | MASK_SYMBOL;
         INDEX = S_LIST(INDEX);
      END;
      INDEX = N_DECL_SYMB;
      N_DECL_SYMB = N_DECL_SYMB + 1;
      IF N_DECL_SYMB > TABLE_LENGTH THEN
         DO;
            CALL ERROR('SYMBOL TABLE OVERFLOW', 1);
            RETURN;
         END;
      S_LIST(INDEX) = S_LIST(INTPTR);
      S_LIST(INTPTR) = INDEX;
      DATATYPE(INDEX) = INTPTR;
      VAR_TYPE(INDEX) = CONSTANT;
      STRUCTYPE(INDEX) = ARITHMETIC;
      VALUE(INDEX) = INTCONST;
      STORAGE_LNGTH(INDEX) = 4;
      PSEUDO_REG(INDEX) = 0;
      DISPLACEMENT(INDEX) = STACK_LIMIT(1);
      STACK_LIMIT(1) = STACK_LIMIT(1) + 4;
      CALL EMIT_DATA_BYTES(INDEX);
      RETURN INDEX | MASK_SYMBOL;
   END FINDCONST;

FINDREAL:
   PROCEDURE (REALCONST) BIT(16);
      /* WE CREATE A REAL CONSTANT OPERAND FOR A TRIPLE.  FIRST WE SEARCH THE
         SYMBOL TABLE FOR THE REAL CONSTANT "REALCONST".  IF WE THEN DO NOT
         FIND IT WE ENTER IT AND RETURN ITS INDEX.                           */
      DECLARE REALCONST FIXED, INDEX BIT(16);
      INDEX = S_LIST(REALPTR);
      DO WHILE INDEX ¬= NULL;
         IF VALUE(INDEX) = REALCONST THEN RETURN INDEX | MASK_SYMBOL;
         INDEX = S_LIST(INDEX);
      END;
      INDEX = N_DECL_SYMB;
      N_DECL_SYMB = N_DECL_SYMB + 1;
      IF N_DECL_SYMB > TABLE_LENGTH THEN
         DO;
            CALL ERROR('SYMBOL TABLE OVERFLOW', 1);
            RETURN;
         END;
      S_LIST(INDEX) = S_LIST(REALPTR);
      S_LIST(REALPTR) = INDEX;
      DATATYPE(INDEX) = REALPTR;
      VAR_TYPE(INDEX) = CONSTANT;
      STRUCTYPE(INDEX) = ARITHMETIC;
      VALUE(INDEX) = REALCONST;
      STORAGE_LNGTH(INDEX) = 4;
      PSEUDO_REG(INDEX) = 0;
      DISPLACEMENT(INDEX) = STACK_LIMIT(1);
      STACK_LIMIT(1) = STACK_LIMIT(1) + 4;
      CALL EMIT_DATA_BYTES(INDEX);
      RETURN INDEX | MASK_SYMBOL;
   END FINDREAL;

   /*                   THE TRIPLES - SYNTHESIZER                     */

RANGE_CHECK:
   PROCEDURE (TYPE, LOWBOUND, HIGHBOUND);
      /* WHEN THIS PROCEDURE IS CALLED, THE TOP ELEMENT OF OPERAND#STK
         HAS JUST BEEN COERCED TO A SUBRANGE TYPE, AND NODE HAS BEEN
         REPLACED IN PARSE_TREE BY A POINTER TO THAT TYPE.  WE EMIT
         TRIPLES TO CHECK WHETHER THE COERCION HAS INDEED RESULTED IN
         A VALUE WITHIN THE TARGET RANGE.                             */
      DECLARE (TYPE, OPND) BIT(16), (LOWBOUND, HIGHBOUND) BIT(1);
      IF MONITOR_LINK(2) = 0 THEN /* DEBUG LEVEL = 0 */ RETURN;
      IF ¬(LOWBOUND | HIGHBOUND) THEN RETURN;
      OPND = OPERAND#STK(#OP);
      /* IF OPND IS NOT IN A REGISTER, LOAD IT */
      IF (OPND & "C000") ¬= (MASK_TRIPLE & "C000") THEN
         DO;
            CALL EMIT_TRIPLE(LOAD, OPND, NULL, 3);
            OPND, OPERAND#STK(#OP) = (N_TRIPLES - 3) | MASK_TRIPLE;
         END;
      IF LOWBOUND THEN
         DO; /* SEE IF OPERAND IS LESS THAN ZERO */
            CALL EMIT_TRIPLE(LESS, OPND | MASK_TEMP, 0 | MASK_IMMEDIATE, 0);
            IF HIGHBOUND THEN
               CALL EMIT_TRIPLE(BNZ, (N_TRIPLES + 9) | MASK_TRIPLE,
                                (N_TRIPLES - 3) | MASK_TRIPLE, 0);
            ELSE CALL EMIT_TRIPLE(BZ, (N_TRIPLES + 6) | MASK_TRIPLE,
                                  (N_TRIPLES - 3) | MASK_TRIPLE, 0);
         END;
      IF HIGHBOUND THEN
         DO; /* SEE IF OPERAND IS GREATER THAN HIGHBOUND */
            CALL EMIT_TRIPLE(GREATER, OPND | MASK_TEMP,
               FINDCONST(STORAGE_LNGTH(TYPE) - 1), 0);
            CALL EMIT_TRIPLE(BZ, (N_TRIPLES + 3*LOWBOUND + 6) | MASK_TRIPLE,
                             (N_TRIPLES - 3) | MASK_TRIPLE, 0);
            IF LOWBOUND THEN CALL EMIT_TRIPLE(BCH_TARGET, NULL, NULL, 1);
         END;
      /* VALUE OUT OF RANGE -- CALL THE MONITOR */
      CALL EMIT_TRIPLE(MONITOR, NULL, NULL, 32);
      CALL EMIT_TRIPLE(BCH_TARGET, NULL, NULL, 1);
   END RANGE_CHECK;

COERCE_ASSIGNMENT:
   PROCEDURE (TYPE1, TYPE2);
      /* WE HAVE TWO OPERANDS, OPND1 AND OPND2, OF TYPES TYPE1 AND TYPE2
         RESPECTIVELY.  OPND2 IS THE TOP ELEMENT OF OPERAND#STK.  WE WISH
         TO ASSIGN THE VALUE OF OPND2 TO OPND1.  THIS PROCEDURE WILL PER-
         FORM A LEGAL IMPLICIT TYPE COERCION FROM TYPE2 TO TYPE1 IF
         NECESSARY.                                                         */
      DECLARE (TYPE1, TYPE2, OPND2) BIT(16);
      DECLARE (LOW1, LOW2) FIXED;
      DECLARE RANGE_ERR CHARACTER INITIAL('VALUE OUT OF RANGE');
      DECLARE INCOMPATIBLE_DATATYPES CHARACTER INITIAL (
         'INCOMPATIBLE DATATYPES');
      DECLARE ERROR_FLAG BIT(1);
      DECLARE I FIXED, OFFSET FIXED;
      IF COMPTYPES(TYPE1, TYPE2) THEN
         /* NO COERCION IS NECESSARY */ RETURN;
      OPND2 = OPERAND#STK(#OP);
      IF STRUCTYPE(TYPE1) ¬= STRUCTYPE(TYPE2) THEN
         DO;
            IF ((STRUCTYPE(TYPE2) = SCALAR) | (STRUCTYPE(TYPE2) = ARITHMETIC)) &
               (STRUCTYPE(TYPE1) = SUBRANGE) THEN
               DO;
                  LOW1 = VALUE(S_LIST(TYPE1));
                  IF COMPTYPES(TYPE2, DATATYPE(TYPE1)) THEN
                     DO; /* COERCE SCALAR TO SUBRANGE */
                        IF (OPND2 & "C000") = MASK_IMMEDIATE THEN
                           OPND2, OPERAND#STK(#OP) =
                              FINDCONST((OPND2 & "3FFF") - LOW1);
                        ELSE IF ((OPND2 & "C000") = MASK_SYMBOL) &
                           (VAR_TYPE(OPND2) = CONSTANT) THEN
                           OPND2, OPERAND#STK(#OP) =
                              FINDCONST(VALUE(OPND2) - LOW1);
                        ELSE IF VALUE(LOW1) = 1 THEN
                           DO;
                              CALL EMIT_TRIPLE(SUBTRACT, OPND2,
                                 1 | MASK_IMMEDIATE, 3);
                              OPERAND#STK(#OP) = (N_TRIPLES - 3) | MASK_TRIPLE;
                              OPND2 = OPERAND#STK(#OP);
                           END;
                        ELSE IF LOW1 ¬= 0 THEN
                           DO;
                              CALL EMIT_TRIPLE(ADD, OPND2, FINDCONST(-LOW1), 3);
                              OPERAND#STK(#OP) = (N_TRIPLES - 3) | MASK_TRIPLE;
                              OPND2 = OPERAND#STK(#OP);
                           END;
                        IF (OPND2 & "C000") = MASK_IMMEDIATE THEN
                           DO;
                              IF (OPND2 & "3FFF") + LOW1 > VALUE(TYPE1) THEN
                                 DO;
                                    CALL ERROR(RANGE_ERR, 0);
                                    CALL EMIT_TRIPLE(MONITOR, NULL, NULL, 32);
                                 END;
                           END;
                        ELSE IF ((OPND2 & "C000") = MASK_SYMBOL) &
                                (VAR_TYPE(OPND2) = CONSTANT) THEN
                           DO;
                              IF (VALUE(OPND2) > STORAGE_LNGTH(TYPE1)) |
                                 (VALUE(OPND2) < 0) THEN
                                 DO;
                                    CALL ERROR(RANGE_ERR, 0);
                                    CALL EMIT_TRIPLE(MONITOR, NULL, NULL, 32);
                                 END;
                           END;
                        ELSE CALL RANGE_CHECK(TYPE1, TRUE, TRUE);
                        CALL REPLACE(TYPE1);
                        RETURN;
                     END;
                  ELSE
                     DO;
                        CALL ERROR(INCOMPATIBLE_DATATYPES, 1);
                        RETURN;
                     END;
               END;
            ELSE IF ((STRUCTYPE(TYPE1) = SCALAR) |
                     (STRUCTYPE(TYPE1) = ARITHMETIC)) &
                    (STRUCTYPE(TYPE2) = SUBRANGE) THEN
               DO;  /* COERCE SUBRANGE TO SCALAR */
                  LOW2 = VALUE(S_LIST(TYPE2));
                  IF LOW2 ¬= 0 THEN
                     DO;
                        CALL EMIT_TRIPLE(ADD, OPND2, FINDCONST(LOW2), 3);
                        OPERAND#STK(#OP) = (N_TRIPLES - 3) | MASK_TRIPLE;
                     END;
                  TYPE2 = DATATYPE(TYPE2);
                  CALL REPLACE(TYPE1);
                  IF COMPTYPES(TYPE1, TYPE2) THEN RETURN;
                  /* ELSE DO NOT RETURN;  MAY HAVE TO FLOAT OPND2 */
                  OPND2 = OPERAND#STK(#OP);
               END;
            ELSE
               DO;
                  CALL ERROR(INCOMPATIBLE_DATATYPES, 1);
                  RETURN;
               END;
         END;
      /* NOW STRUCTYPE(TYPE1) = STRUCTYPE(TYPE2), AND ¬COMPTYPES(TYPE1,TYPE2) */
      IF STRUCTYPE(TYPE1) = ARITHMETIC THEN
         DO;
            IF COMPTYPES(TYPE1, REALPTR) & COMPTYPES(TYPE2, INTPTR) THEN
               DO;  /* FLOAT OPERAND 2 */
                  CALL EMIT_TRIPLE(FLOAT, OPND2, NULL, 3);
                  OPERAND#STK(#OP) = (N_TRIPLES - 3) | MASK_TRIPLE;
                  CALL REPLACE(REALPTR);
               END;
            ELSE CALL ERROR('ILLEGAL REAL EXPRESSION', 1);
         END;
      ELSE IF STRUCTYPE(TYPE1) = SUBRANGE THEN
         DO;
            IF ¬COMPTYPES(DATATYPE(TYPE1), DATATYPE(TYPE2)) THEN
               DO;
                  CALL ERROR(INCOMPATIBLE_DATATYPES, 1);
                  RETURN;
               END;
            /* COERCE TYPE2 TO TYPE1 */
            LOW1 = VALUE(S_LIST(TYPE1));
            LOW2 = VALUE(S_LIST(TYPE2));
            IF LOW1 ¬= LOW2 THEN
               DO;
                  CALL EMIT_TRIPLE(ADD, OPND2, FINDCONST(LOW2 - LOW1), 3);
                  OPERAND#STK(#OP) = (N_TRIPLES - 3) | MASK_TRIPLE;
               END;
            CALL RANGE_CHECK(TYPE1, (LOW1 > LOW2),
               (VALUE(TYPE1) < VALUE(TYPE2)));
            CALL REPLACE(TYPE1);
         END;
      ELSE IF STRUCTYPE(TYPE1) = SET THEN
         DO;
            ERROR_FLAG = ¬COMPTYPES(DATATYPE(TYPE1), DATATYPE(TYPE2));
            IF ¬ERROR_FLAG THEN
               DO;
                  LOW1 = VALUE(TYPE1);
                  LOW2 = VALUE(TYPE2);
                  OFFSET =
                     LOW1 + STORAGE_LNGTH(TYPE1) - LOW2 - STORAGE_LNGTH(TYPE2);
                  ERROR_FLAG = (LOW1 > LOW2) | (OFFSET < 0);
               END;
            IF ERROR_FLAG THEN
               DO;
                  CALL REPLACE(EMPTYSETPTR);
                  CALL ERROR('INCOMPATIBLE SET TYPES', 1);
                  RETURN;
               END;
            /* COERCE TYPE2 TO TYPE1 */
            I = N_TRIPLES | MASK_TEMP;
            CALL EMIT_TRIPLE(TEMP, NULL, 0, STORAGE_LNGTH(TYPE1) - 1);
            CALL EMIT_TRIPLE(XOR, I, I, 0);
            CALL EMIT_TRIPLE(INDEX, I, FINDCONST(LOW2 - LOW1),
                             STORAGE_LNGTH(TYPE2) - 1);
            CALL EMIT_TRIPLE(MOVE, (N_TRIPLES - 3) | MASK_TRIPLE, OPND2, 0);
            OPERAND#STK(#OP) = I & "BFFF";
            CALL REPLACE(TYPE1);
         END;
      ELSE CALL ERROR(INCOMPATIBLE_DATATYPES, 1);
   END COERCE_ASSIGNMENT;

COERCE_PARAMETER:
   PROCEDURE (ACTUAL, FORMAL, ACTUAL_TYPE);
      DECLARE (ACTUAL, FORMAL, ACTUAL_TYPE) BIT(16);
      DECLARE VAR_ERR CHARACTER INITIAL ('VAR PARAMETER MUST BE A VARIABLE');
      IF VAR_TYPE(FORMAL) = VARIABLE THEN
         DO;
            IF (ACTUAL & "C000") = MASK_SYMBOL THEN
               IF VAR_TYPE(ACTUAL) = VAR_PARAM THEN
                  DO;
                     CALL EMIT_TRIPLE(INDEX, 0 | MASK_IMMEDIATE, ACTUAL,
                                      STORAGE_LNGTH(FORMAL) - 1);
                     OPERAND#STK(#OP) = (N_TRIPLES - 3) | MASK_TRIPLE;
                     IF STORAGE_LNGTH(FORMAL) > 255 THEN
                        CALL EMIT_TRIPLE(S_LENGTH, SHR(STORAGE_LNGTH(FORMAL),
                           16), STORAGE_LNGTH(FORMAL), 0);
                  END;
            CALL COERCE_ASSIGNMENT(DATATYPE(FORMAL), ACTUAL_TYPE);
         END;
      ELSE IF VAR_TYPE(FORMAL) = VAR_PARAM THEN
         DO;
            IF ¬ COMPTYPES(DATATYPE(FORMAL), ACTUAL_TYPE) THEN
               CALL ERROR('VAR PARAMETER NOT COMPATIBLE WITH TYPE '
                          || IDENTITY(DATATYPE(FORMAL)), 1);
            IF (ACTUAL & "C000") = MASK_SYMBOL THEN
               DO;
                  IF VAR_TYPE(ACTUAL) = VARIABLE THEN
                     DO;
                        CALL EMIT_TRIPLE(LOAD_ADDR, ACTUAL, NULL, 3);
                        OPERAND#STK(#OP) = (N_TRIPLES - 3) | MASK_TRIPLE;
                     END;
                  ELSE IF VAR_TYPE(ACTUAL) ¬= VAR_PARAM THEN
                     CALL ERROR('VAR PARAMETER MUST BE A VARIABLE', 1);
               END;
            ELSE IF (ACTUAL & "C000") = MASK_IMMEDIATE THEN
               CALL ERROR (VAR_ERR, 1);
            ELSE
               DO;   /* ACTUAL PARAMETER MUST BE AN INDEX TRIPLE */
                  IF (TRIPLES(ACTUAL & "3FFF") & "7F") ¬= INDEX THEN
                     CALL ERROR (VAR_ERR, 1);
                  ELSE IF (STRUCTYPE(ACTUAL_TYPE) = SCALAR)
                        | (STRUCTYPE(ACTUAL_TYPE) = SUBRANGE) THEN
                        IF SHR(TRIPLES(ACTUAL & "3FFF"), 8) = 0 THEN
                           CALL ERROR (
             'VAR PARAMETER MUST NOT BE A SCALAR OR SUBRANGE ARRAY ELEMENT', 1);
                  CALL EMIT_TRIPLE(LOAD_ADDR, ACTUAL, NULL, 3);
                  OPERAND#STK(#OP) = (N_TRIPLES - 3) | MASK_TRIPLE;
               END;
         END;
      ELSE   /* VAR_TYPE(FORMAL) = PROC_PARAM */
         DO;
            IF ((ACTUAL & "C000") ¬= MASK_SYMBOL)
               | ((ACTUAL & "3FFF") >= N_ANONYMOUS_SYMB) THEN
               CALL ERROR('IN PARAMETER LIST - PROCEDURE/FUNCTION NAME EXPECTED'
                          , 1);
            ELSE IF (SHL(1, VAR_TYPE(ACTUAL)) & "(1)01000000010100000") = 0 THEN
               /* ¬(VAR_TYPE(ACTUAL) IN (.PROC, PROC_PARAM, MULTDECL.)) */
               CALL ERROR(IDENTITY(ACTUAL) || ' IS NOT A PROCEDURE/FUNCTION',1);
            ELSE IF STRUCTYPE(ACTUAL) = STANDARD THEN
               CALL ERROR('ATTEMPT TO PASS STANDARD PROCEDURE/FUNCTION '
                          || IDENTITY(ACTUAL), 1);
            ELSE IF ¬COMPPROCS(ACTUAL, FORMAL) THEN
               CALL ERROR(IDENTITY(ACTUAL) || ' IS NOT COMPATIBLE WITH '
                          || IDENTITY(FORMAL), 1);
            ELSE IF VAR_TYPE(ACTUAL) ¬= PROC_PARAM THEN
               DO;
                  CALL EMIT_TRIPLE(PROCPARM, ACTUAL, FINDCONST(VALUE(ACTUAL)),
                                   0);
                  OPERAND#STK(#OP) = (N_TRIPLES - 3) | MASK_TRIPLE;
               END;
         END;
   END COERCE_PARAMETER;

COERCE_OP:
   PROCEDURE;
      /* WE ARE GIVEN TWO OPERANDS, OPND1 AND OPND2, OF TYPES TYPE1 AND TYPE2
         RESPECTIVELY.  OPND1 AND OPND2 ARE THE TOP TWO ELEMENTS OF OPERAND#STK.
         WE WISH TO COMBINE THEM USING SOME ARITHMETIC OR COMPARISON OPERATOR.
         IN DOING SO, HOWEVER, WE MAY FIRST HAVE TO COERCE SUBRANGE TO SCALAR OR
         INTEGER TO REAL, IN ACCORDANCE WITH THE AXIOMATIC DEFINITION OF PASCAL.
      */
      DECLARE (OPND1, OPND2, TYPE1, TYPE2) BIT(16);
      DECLARE INCOMPATIBLE_DATATYPES CHARACTER INITIAL (
         'INCOMPATIBLE DATATYPES');
      DECLARE LOWBOUND FIXED;
      DECLARE (I, ST_LNGTH, HIGHBOUND) FIXED, SET_TYPE_PTR BIT(16);
      OPND1 = OPERAND#STK(#OP - 1);
      OPND2 = OPERAND#STK(#OP);
      TYPE1 = PARSE_TREE(NODE#STACK(NP) + #POS_STACK(NP));
      TYPE2 = PARSE_TREE(NODE#STACK(NP) + #POS_STACK(NP) + 1);
      IF STRUCTYPE(TYPE1) = SUBRANGE THEN
         DO;   /* COERCE OPERAND 1 FROM SUBRANGE TO SCALAR */
            LOWBOUND = VALUE(S_LIST(TYPE1));
            IF LOWBOUND ¬= 0 THEN
               DO;
                  CALL EMIT_TRIPLE(ADD, OPND1, FINDCONST(LOWBOUND), 3);
                  OPERAND#STK(#OP - 1) = (N_TRIPLES - 3) | MASK_TRIPLE;
                  OPND1 = OPERAND#STK(#OP - 1);
               END;
            TYPE1 = DATATYPE(TYPE1);
            CALL REPLACE_LEFT_BRO(TYPE1);
         END;
      IF STRUCTYPE(TYPE2) = SUBRANGE THEN
         DO;   /* COERCE OPERAND 2 FROM SUBRANGE TO SCALAR */
            LOWBOUND = VALUE(S_LIST(TYPE2));
            IF LOWBOUND ¬= 0 THEN
               DO;
                  CALL EMIT_TRIPLE(ADD, OPND2, FINDCONST(LOWBOUND), 3);
                  OPERAND#STK(#OP) = (N_TRIPLES - 3) | MASK_TRIPLE;
                  OPND2 = OPERAND#STK(#OP);
               END;
            TYPE2 = DATATYPE(TYPE2);
            CALL REPLACE(TYPE2);
         END;
      IF COMPTYPES(TYPE1, TYPE2) THEN RETURN;
      IF (STRUCTYPE(TYPE1) = SET) & (STRUCTYPE(TYPE2) = SET) THEN
         DO;
            IF ¬COMPTYPES(DATATYPE(TYPE1), DATATYPE(TYPE2)) THEN
               DO;
                  CALL ERROR('INCOMPATIBLE SET TYPES', 1);
                  CALL REPLACE(EMPTYSETPTR);
                  CALL REPLACE_LEFT_BRO(EMPTYSETPTR);
                  RETURN;
               END;
            IF VALUE(TYPE1) < VALUE(TYPE2) THEN
               LOWBOUND = VALUE(TYPE1);
            ELSE LOWBOUND = VALUE(TYPE2);
            IF (VALUE(TYPE1) + STORAGE_LNGTH(TYPE1))
               > (VALUE(TYPE2) + STORAGE_LNGTH(TYPE2)) THEN
               HIGHBOUND = VALUE(TYPE1) + STORAGE_LNGTH(TYPE1);
            ELSE HIGHBOUND = VALUE(TYPE2) + STORAGE_LNGTH(TYPE2);
            ST_LNGTH = HIGHBOUND - LOWBOUND;
            IF ST_LNGTH > 256 THEN
               DO;
                  CALL ERROR('SET EXPRESSION REQUIRES MORE THAN 256 BYTES', 1);
                  CALL REPLACE(EMPTYSETPTR);
                  CALL REPLACE_LEFT_BRO(EMPTYSETPTR);
                  RETURN;
               END;
            SET_TYPE_PTR = NEXT_FREE_ROW;
            DATATYPE(SET_TYPE_PTR) = DATATYPE(TYPE1);
            VALUE(SET_TYPE_PTR) = LOWBOUND;
            STORAGE_LNGTH(SET_TYPE_PTR) = ST_LNGTH;
            STRUCTYPE(SET_TYPE_PTR) = SET;
            VAR_TYPE(SET_TYPE_PTR) = TYPE;
            IF COMPTYPES(TYPE1, SET_TYPE_PTR) THEN
               DO;
                  N_DECL_SYMB = N_DECL_SYMB - 1;
                  SET_TYPE_PTR = TYPE1;
               END;
            ELSE IF COMPTYPES(TYPE2, SET_TYPE_PTR) THEN
               DO;
                  N_DECL_SYMB = N_DECL_SYMB - 1;
                  SET_TYPE_PTR = TYPE2;
               END;
            IF ¬COMPTYPES(TYPE1,SET_TYPE_PTR) THEN
               DO;   /* COERCE OPND1 TO SET_TYPE_PTR */
                  CALL EMIT_TRIPLE(TEMP, NULL, 0, ST_LNGTH - 1);
                  I = (N_TRIPLES - 3) | MASK_TEMP;
                  CALL EMIT_TRIPLE(XOR, I, I, 0);
                  CALL EMIT_TRIPLE(INDEX, I, FINDCONST(VALUE(TYPE1) - LOWBOUND),
                     STORAGE_LNGTH(TYPE1) - 1);
                  CALL EMIT_TRIPLE(MOVE, (N_TRIPLES - 3) | MASK_TRIPLE, OPND1,
                     0);
                  OPERAND#STK(#OP - 1) = I & "BFFF";
                  CALL REPLACE_LEFT_BRO(SET_TYPE_PTR);
               END;
            IF ¬COMPTYPES(TYPE2, SET_TYPE_PTR) THEN
               CALL COERCE_ASSIGNMENT(SET_TYPE_PTR, TYPE2);
            RETURN;
         END;
      ELSE IF (STRUCTYPE(TYPE1) ¬= ARITHMETIC)
              | (STRUCTYPE(TYPE2) ¬= ARITHMETIC) THEN
         DO;
            CALL ERROR(INCOMPATIBLE_DATATYPES, 1);
            RETURN;
         END;
      /* NOW OPERAND 1 AND OPERAND 2 ARE OF INCOMPATIBLE ARITHMETIC TYPES, I.E.,
         ONE IS INTEGER, THE OTHER REAL.  FLOAT THE INTEGER OPERAND. */
      IF DATATYPE(TYPE1) = INTPTR THEN
         DO;   /* FLOAT OPERAND 1 */
            CALL EMIT_TRIPLE(FLOAT, OPND1, NULL, 3);
            OPERAND#STK(#OP - 1) = (N_TRIPLES - 3) | MASK_TRIPLE;
            CALL REPLACE_LEFT_BRO(REALPTR);
         END;
      ELSE
         DO;   /* FLOAT OPERAND 2 */
            CALL EMIT_TRIPLE(FLOAT, OPND2, NULL, 3);
            OPERAND#STK(#OP) = (N_TRIPLES - 3) | MASK_TRIPLE;
            CALL REPLACE(REALPTR);
         END;
   END COERCE_OP;

COERCE_SET_ELEMENT:
   PROCEDURE (ELEMENT_TYPE, MIN);
      DECLARE (ELEMENT_TYPE, MIN, ELT) BIT(16);
      ELT = OPERAND#STK(#OP);
      IF (ELT & "C000") = MASK_IMMEDIATE THEN
         OPERAND#STK(#OP) = FINDCONST((ELT & "3FFF") - MIN);
      ELSE IF ((ELT & "C000") = MASK_SYMBOL) & (VAR_TYPE(ELT) = CONSTANT) THEN
         OPERAND#STK(#OP) = FINDCONST(VALUE(ELT) - MIN);
      ELSE IF (STRUCTYPE(ELEMENT_TYPE) = SUBRANGE) &
              (VALUE(S_LIST(ELEMENT_TYPE)) ¬= MIN) THEN
         DO;
            CALL EMIT_TRIPLE(ADD, ELT,
               FINDCONST(VALUE(S_LIST(ELEMENT_TYPE)) - MIN), 3);
            OPERAND#STK(#OP) = (N_TRIPLES - 3) | MASK_TRIPLE;
         END;
   END COERCE_SET_ELEMENT;

   /*       S T O R A G E   A L L O C A T I O N   P R O C E D U R E S     */

COMPUTE_STORAGE_LENGTH:
   PROCEDURE (TYPE_PTR);
      DECLARE TYPE_PTR FIXED;
      DECLARE STRUCTYPECASE (14) BIT(16) INITIAL(0,1,2,3,4,4,4,4,4,4,0,5,5,0,3);
      DO CASE STRUCTYPECASE(STRUCTYPE(TYPE_PTR));
         /*  0   STATEMENT, STANDARD   */
            ;
         /*  1   SCALAR   */
            IF STORAGE_LNGTH(TYPE_PTR) <= 256 THEN SL = 1;
            ELSE SL = 2;
         /*  2   SUBRANGE   */
            IF STORAGE_LNGTH(TYPE_PTR) = NULL THEN SL = 4;
            ELSE IF STORAGE_LNGTH(TYPE_PTR) < 256 THEN SL = 1;
            ELSE SL = 2;
         /*  3   POINTER, ARITHMETIC   */
            SL = 4;
         /*  4   ARRAY, FILE, RECORD  */
            SL = STORAGE_LNGTH(TYPE_PTR);
         /*  5   SET   */
            SL = STORAGE_LNGTH(TYPE_PTR);
      END;
   END COMPUTE_STORAGE_LENGTH;

ALLOCATE_STORAGE:
   PROCEDURE (VAR_PTR);
      DECLARE VAR_PTR FIXED;
      /* THIS PROCEDURE REFERS TO THE GLOBAL VARIABLE SL, WHICH IS PRESUMED
         TO HAVE BEEN SET BY A PRIOR CALL TO COMPUTE_STORAGE_LENGTH.  IT
         SETS VALUES OF DISPLACEMENT(VAR_PTR), STACK_LIMIT(CURRENT_LEVEL),
         HALFWORD_DISP(CURRENT_LEVEL) AND ARRAYS_ALLOCATED(CURRENT_LEVEL). */
      IF SL <= 2 THEN
         DO;
            IF HALFWORD_DISP(CURRENT_LEVEL) ¬= 0 THEN
               DO;
                  DISPLACEMENT(VAR_PTR) = HALFWORD_DISP(CURRENT_LEVEL);
                  HALFWORD_DISP(CURRENT_LEVEL) = 0;
               END;
            ELSE
               DO;
                  DISPLACEMENT(VAR_PTR) = STACK_LIMIT(CURRENT_LEVEL);
                  HALFWORD_DISP(CURRENT_LEVEL) = STACK_LIMIT(CURRENT_LEVEL) + 2;
                  STACK_LIMIT(CURRENT_LEVEL) = STACK_LIMIT(CURRENT_LEVEL) + 4;
               END;
            IF STRUCTYPE(VAR_PTR) = SET THEN
               STORAGE_LNGTH(VAR_PTR) = SL;
            ELSE STORAGE_LNGTH(VAR_PTR) = 2;
            IF CURRENT_LEVEL = 1 THEN CALL EMIT_DATA_BYTES(VAR_PTR);
         END;
      ELSE IF SL <= 4 THEN
         DO;
            DISPLACEMENT(VAR_PTR) = STACK_LIMIT(CURRENT_LEVEL);
            STACK_LIMIT(CURRENT_LEVEL) = STACK_LIMIT(CURRENT_LEVEL) + 4;
            STORAGE_LNGTH(VAR_PTR) = SL;
            IF CURRENT_LEVEL = 1 THEN CALL EMIT_DATA_BYTES(VAR_PTR);
         END;
      ELSE
         DO; /* CHAIN STRUCTURED VARIABLES THROUGH THE VALUE FIELD */
            STORAGE_LNGTH(VAR_PTR) = SL;
            VALUE(VAR_PTR) = ARRAYS_ALLOCATED(CURRENT_LEVEL);
            ARRAYS_ALLOCATED(CURRENT_LEVEL) = VAR_PTR;
         END;
   END ALLOCATE_STORAGE;

ALLOCATE_ARRAY_STORAGE:
   PROCEDURE (LEVEL);
      DECLARE (VAR_PTR, LEVEL, I) BIT(16);
   /* THIS PROCEDURE IS CALLED WHENEVER CURRENT_LEVEL IS ABOUT TO BE DECREMENTED
         (AT THE CLOSE OF A BLOCK OR A RECORD DECLARATION) IN ORDER TO ALLOCATE
         STORAGE FOR THE STRUCTURED VARIABLES, AFTER ALL STORAGE FOR SCALAR
         VARIABLES HAS BEEN ALLOCATED.  THIS IS DONE TO SECURE EFFICIENCY IN
         ADDRESS COMPUTATION AT RUNTIME.                               */
      VAR_PTR = ARRAYS_ALLOCATED(LEVEL);
      DO WHILE VAR_PTR > N_PREDECLARED_SYMB;
         SL = STORAGE_LNGTH(VAR_PTR);
         DISPLACEMENT(VAR_PTR) =   STACK_LIMIT(LEVEL);
         SL = SHL(SHR(SL,2) + ((SL  &  3) > 0), 2);
         STACK_LIMIT(LEVEL) = STACK_LIMIT(LEVEL) + SL;
         IF LEVEL = 1 THEN CALL EMIT_DATA_BYTES(VAR_PTR);
         I = VAR_PTR;
         VAR_PTR = VALUE(VAR_PTR);
         VALUE(I) = 0;
      END;
      ARRAYS_ALLOCATED(LEVEL) = NULL;
   END ALLOCATE_ARRAY_STORAGE;

SAVE_CURRENT_LEVEL:
   PROCEDURE;
      DECLARE I BIT(16), NODE_SIZE BIT(16) INITIAL(3);
      /* FIRST, ALLOCATE A NODE FROM THE FORWARD_SAVE HEAP. */
      IF FORWARD_AVAIL ¬= NULL THEN
         DO;
            I = FORWARD_AVAIL;
            FORWARD_AVAIL = FORWARD_SAVE(I);
         END;
      ELSE IF FORWARD_LIMIT < FORWARD_LENGTH THEN
         DO; /* CARVE OUT A NEW NODE */
            I = FORWARD_LIMIT;
            FORWARD_LIMIT = FORWARD_LIMIT + NODE_SIZE;
         END;
      ELSE
         DO; /* HEAP OVERFLOW */
            CALL ERROR(
           'TOO MANY FORWARD-DECLARED PROCEDURES ARE PENDING AT THIS POINT', 1);
            RETURN;
         END;
      PSEUDO_REG(OWNER_STACK(CURRENT_LEVEL)) = I;
      FORWARD_SAVE(I) = ARRAYS_ALLOCATED(CURRENT_LEVEL);
      FORWARD_SAVE(I + 1) = STACK_LIMIT(CURRENT_LEVEL);
      FORWARD_SAVE(I + 2) = HALFWORD_DISP(CURRENT_LEVEL);
   END SAVE_CURRENT_LEVEL;

RESTORE_CURRENT_LEVEL:
   PROCEDURE;
      DECLARE I BIT(16);
      I = PSEUDO_REG(OWNER_STACK(CURRENT_LEVEL));
      PSEUDO_REG(OWNER_STACK(CURRENT_LEVEL)) = CURRENT_LEVEL - 1;
      ARRAYS_ALLOCATED(CURRENT_LEVEL) = FORWARD_SAVE(I);
      STACK_LIMIT(CURRENT_LEVEL) = FORWARD_SAVE(I + 1);
      HALFWORD_DISP(CURRENT_LEVEL) = FORWARD_SAVE(I + 2);
      FORWARD_SAVE(I) = FORWARD_AVAIL;
      FORWARD_AVAIL = I;
   END RESTORE_CURRENT_LEVEL;

   /*      T R A V E R S E   P A R S E   T R E E S           */

VISIT_NODES:
   PROCEDURE;
      DECLARE FIRST_VISIT BIT(1);
      DECLARE IS_LEAF LITERALLY 'PARSE_TREE(NODE)=0';
      DECLARE FATHERS_PROD_NO LITERALLY 'PARSE_TREE(NODE#STACK(NP)+1)';
      DECLARE GREAT_GRANDFATHERS_PROD_NO LITERALLY
              'PARSE_TREE(NODE#STACK(NP-2)+1)';
      DECLARE(FATHERS_MULTIPLICITY, #MP, #TP) FIXED;
      DECLARE IS_DECLARATION BIT(1);
      DECLARE (LHS, PARAMLIST) BIT(1);
      DECLARE FIRST_PARAM_TYPES BIT(1);
      /* SYMBOL TABLE POINTERS USED IN PROCESSING DECLARATION TREES */
      DECLARE (TABLE_PTR, ID_PTR, TP_ID_PTR) FIXED;
      /*  GLOBAL TEMPORARIES USED IN TRAVERSING SYMBOL TABLE ENTRIES  */
      DECLARE (I, LINK, NP1) FIXED;
      DECLARE J FIXED;
      DECLARE (MIN, MAX, CASE_LABEL_VALUE) FIXED;
      DECLARE (CASE_INSTANCE_PTR, CASE_LABEL_PTR, CASE_PTR) BIT(16);
      /*  STRINGS USED IN ERROR MESSAGES     */
      DECLARE SUBRANGE_SIZE CHARACTER INITIAL
         ('IMPLEMENTATION RESTRICTS LENGTH OF A SET TO 256 BYTES');
      DECLARE TAG_TYPE CHARACTER INITIAL (
         'TYPE OF CASE LABEL DOES NOT AGREE WITH TYPE OF TAG FIELD');
      DECLARE (BOUND1_IS_CONST, BOUND2_IS_CONST) BIT(1);
      DECLARE (BOUND1_VALUE, BOUND2_VALUE) FIXED;
      DECLARE (MUST_CHECK_LOWBOUND, MUST_CHECK_HIGHBOUND) BIT(1);
      DECLARE ERROR_FLAG BIT(1);

   IS_VALID_ROOT_PRODUCTION:
      PROCEDURE (PRODUCTION#) BIT(1);
         DECLARE PRODUCTION# BIT(16);
         IF (PRODUCTION# < 0) | (PRODUCTION# > 10) THEN RETURN FALSE;
         RETURN (SHL(1, PRODUCTION#) & "(1)11100 00011 0") ¬= 0;
         /* RETURN PRODUCTION# IN (.1,2,8,9,10.) */
      END IS_VALID_ROOT_PRODUCTION;

   SIZE:
      PROCEDURE (OPND) FIXED;
         DECLARE (OPND, OPCD) BIT(16);
         IF (OPND & "C000") = MASK_SYMBOL THEN
            RETURN STORAGE_LNGTH(OPND);
         ELSE IF (OPND & "C000") = MASK_IMMEDIATE THEN
            RETURN 4;   /* ASSUME LOADED IN A REGISTER */
         /* ELSE OPERAND IS A TRIPLE */
         OPND = OPND & "3FFF";
         OPCD = TRIPLES(OPND) & "7F";
         IF OPCD = INDEX THEN
            IF TRIPLES(OPND + 3) = S_LENGTH THEN
               RETURN SHL(TRIPLES(OPND + 4), 16) + TRIPLES(OPND + 5);
         RETURN SHR(TRIPLES(OPND), 8) + 1;
   END SIZE;

   SUBSET:
      PROCEDURE (OPND1, OPND2);
         /* CHECK TO SEE IF OPND1 IS A SUBSET OF OPND2.  OPND1 AND OPND2
            ARE THE TOP TWO ELEMENTS ON OPERAND#STK, BUT WE CANNOT TELL
            WHICH ONE IS ON TOP. */
         DECLARE (OPND1, OPND2, OPCD) BIT(16);
         IF OPND1 = EMPTYSETPTR THEN
            DO;
               IF (OPND2 & MASK_TRIPLE) ¬= 0 THEN
                  CALL EMIT_TRIPLE(TPOP, OPND2, NULL, 0);
               OPERAND#STK(#OP - 1) = TRUE | MASK_IMMEDIATE;
            END;
         ELSE IF OPND2 = EMPTYSETPTR THEN
            DO;
               CALL EMIT_TRIPLE(AND, OPND1, OPND1, 0);
               IF FX THEN OPCD = BZ; ELSE OPCD = BNZ;
               CALL EMIT_TRIPLE(OPCD, LISTHEAD, NULL, 0);
               LISTHEAD = (N_TRIPLES - 3) | SHL(FX, 15);
               OPERAND#STK(#OP - 1) = (N_TRIPLES - 3) | MASK_TRIPLE;
            END;
         ELSE
            DO;
               CALL EMIT_TRIPLE(TEMP, OPND1, 0, SIZE(OPND1) - 1);
               IF (OPND1 & MASK_TRIPLE) ¬= 0 THEN /* FLAG OPND1 AS REUSABLE */
                  TRIPLES(N_TRIPLES - 2) = OPND1 | MASK_TEMP;
               CALL EMIT_TRIPLE(AND, (N_TRIPLES - 3) | MASK_TEMP, OPND2, 0);
               CALL EMIT_TRIPLE(LCOMPARE, (N_TRIPLES - 6) | MASK_TRIPLE,
                  OPND1, 0);
               IF FX THEN OPCD = BNZ;   ELSE OPCD = BZ;
               CALL EMIT_TRIPLE(OPCD, LISTHEAD, (N_TRIPLES - 3)|MASK_TRIPLE, 0);
               LISTHEAD = (N_TRIPLES - 3) | SHL(FX, 15);
               OPERAND#STK(#OP - 1) = (N_TRIPLES - 3) | MASK_TRIPLE;
            END;
         #OP = #OP - 1;
         #TP = BOOLPTR;
      END SUBSET;

   IS_CONDITION:
      PROCEDURE (OP_PTR) BIT(1);
         /* TESTS OPERAND TO SEE IF BZ OR BNZ TRIPLE */
         DECLARE (OP_PTR, OPCD) BIT(16);
         IF (OP_PTR & "C000") = (MASK_TRIPLE & "C000") THEN
            DO;
               OPCD = TRIPLES(OP_PTR & "3FFF") & "7F";
               IF (OPCD = BZ) | (OPCD = BNZ) THEN RETURN TRUE;
            END;
         RETURN FALSE;
      END IS_CONDITION;

   IS_NEGATION:
      PROCEDURE (OP_PTR) BIT(1);
         /* DETERMINES IF OPERAND IS A "NOT" TRIPLE */
         DECLARE (OP_PTR, OPCD) BIT(16);
         IF (OP_PTR & "C000") = (MASK_TRIPLE & "C000") THEN
            DO;
               OPCD = TRIPLES(OP_PTR & "3FFF") & "7F";
               IF OPCD = NOT THEN RETURN TRUE;
            END;
         RETURN FALSE;
      END IS_NEGATION;

   FIXUP:
      PROCEDURE (HEAD_PTR, TARGET_TRIPLE);
         /* ASSUMES TRIPLES ARE ALL IN TRIPLES BUFFER */
         DECLARE (HEAD_PTR, TARGET_TRIPLE, NEXT) BIT(16);
         DO WHILE HEAD_PTR ¬= NULL;
            HEAD_PTR = HEAD_PTR & "3FFF";
            NEXT = TRIPLES(HEAD_PTR + 1);
            TRIPLES(HEAD_PTR + 1) = TARGET_TRIPLE | MASK_TRIPLE;
            HEAD_PTR = NEXT;
         END;
      END FIXUP;

   EMIT_CONDITIONAL_BRANCH:
      PROCEDURE(FX);
         DECLARE FX BIT(1), OPND BIT(16);
         OPND = OPERAND#STK(#OP);
         IF IS_NEGATION(OPND) THEN
            DO;
               N_TRIPLES = N_TRIPLES - 3;
               IC = IC - 1;
               OPND = TRIPLES(N_TRIPLES + 1);
               FX = ¬FX;
            END;
         IF FX THEN CALL EMIT_TRIPLE(BNZ, NULL, OPND, 0);
         ELSE CALL EMIT_TRIPLE(BZ, NULL, OPND, 0);
      END EMIT_CONDITIONAL_BRANCH;

   COND_TO_REGISTER:
      PROCEDURE;
         /* ASSUMES OPERAND#STK(#OP) POINTS TO A CONDITIONAL BRANCH TRIPLE */
         IF LISTHEAD = NULL THEN RETURN;
         CALL EMIT_TRIPLE(TEMP, (1 - FX) | MASK_IMMEDIATE, NULL, 3);
         OPERAND#STK(#OP) = (N_TRIPLES - 3) | MASK_TRIPLE;
         CALL EMIT_TRIPLE(BCH, (N_TRIPLES + 9) | MASK_TRIPLE, NULL, 0);
         CALL FIXUP(LISTHEAD, N_TRIPLES);
         CALL EMIT_TRIPLE(BCH_TARGET, NULL, NULL, 1);
         CALL EMIT_TRIPLE(STORE, (N_TRIPLES - 9) | MASK_TEMP,
                          FX | MASK_IMMEDIATE, 0);
         CALL EMIT_TRIPLE(BCH_TARGET, NULL, NULL, 1);
         LISTHEAD = NULL;
      END COND_TO_REGISTER;

   EMIT_COMPARE:
      PROCEDURE (OP);
         DECLARE OP BIT(16);   /* OP IS OF TYPE COMPARISONS */
         DECLARE COMPARE_ERROR CHARACTER INITIAL('ILLEGAL COMPARISON');
         DECLARE CONTAINS_ERROR CHARACTER INITIAL(
            'STRICT INCLUSION IS NOT ALLOWED');
         IF #TP = BOOLPTR THEN
            IF IS_CONDITION(OPERAND#STK(#OP)) THEN
               CALL COND_TO_REGISTER;
         CALL REPLACE(#TP);
         IF #MP = 1 THEN RETURN;
         IF ¬COMPTYPES(#TP, PARSE_TREE(NODE#STACK(NP) + 2)) THEN
            CALL COERCE_OP;
         IF COMPTYPES(#TP, REALPTR) THEN
            DO CASE OP MOD 3;
               /* CASE 0 -- EQUAL_TO, NOT_EQUAL_TO */
               CALL EMIT_TRIPLE(COMPAREFLT, OPERAND#STK(#OP - 1),
                  OPERAND#STK(#OP), 0);
               /* CASE 1 -- GREATER_THAN, LESS_EQ */
               CALL EMIT_TRIPLE(GREATERFLT, OPERAND#STK(#OP - 1),
                  OPERAND#STK(#OP), 0);
               /* CASE 2 -- LESS_THAN, GREATER_EQ */
               CALL EMIT_TRIPLE(LESSFLT, OPERAND#STK(#OP - 1),
                  OPERAND#STK(#OP), 0);
            END;
         ELSE IF (STRUCTYPE(#TP) = SET) | (STRUCTYPE(#TP) = PACKED_SET) THEN
            DO CASE OP MOD 3;
               /* CASE 0 -- EQUAL_TO, NOT_EQUAL_TO */
               IF OPERAND#STK(#OP) = EMPTYSETPTR THEN
                  DO;
                     CALL EMIT_TRIPLE(AND, OPERAND#STK(#OP - 1),
                        OPERAND#STK(#OP - 1), 0);
                     OPERAND#STK(#OP - 1) = NULL;
                    IF OP = EQUAL_TO THEN OP = NOT_EQUAL_TO; ELSE OP = EQUAL_TO;
                  END;
               ELSE IF OPERAND#STK(#OP - 1) = EMPTYSETPTR THEN
                  DO;
                     CALL EMIT_TRIPLE(AND, OPERAND#STK(#OP),
                        OPERAND#STK(#OP), 0);
                     OPERAND#STK(#OP - 1) = NULL;
                    IF OP = EQUAL_TO THEN OP = NOT_EQUAL_TO; ELSE OP = EQUAL_TO;
                  END;
               ELSE
                  DO;
                     CALL EMIT_TRIPLE(LCOMPARE, OPERAND#STK(#OP - 1),
                        OPERAND#STK(#OP), 0);
                     OPERAND#STK(#OP - 1) = (N_TRIPLES - 3) | MASK_TRIPLE;
                  END;
               /* CASE 1 -- GREATER_THAN, LESS_EQ */
               IF OP = GREATER_THAN THEN
                  CALL ERROR(CONTAINS_ERROR, 1);
               ELSE
                  DO;
                     CALL SUBSET(OPERAND#STK(#OP - 1), OPERAND#STK(#OP));
                     RETURN;
                  END;
               /* CASE 2 -- LESS_THAN, GREATER_EQ */
               IF OP = LESS_THAN THEN
                  CALL ERROR(CONTAINS_ERROR, 1);
                ELSE
                  DO;
                     CALL SUBSET(OPERAND#STK(#OP), OPERAND#STK(#OP - 1));
                     RETURN;
                  END;
            END;
         ELSE IF ((STRUCTYPE(#TP) = ARRAY) | (STRUCTYPE(#TP) = PACKED_ARRAY)) &
                 (DATATYPE(#TP) = CHARPTR) THEN
            DO CASE OP MOD 3;
               /* CASE 0 -- EQUAL_TO, NOT_EQUAL_TO */
               CALL EMIT_TRIPLE(LCOMPARE, OPERAND#STK(#OP - 1),
                  OPERAND#STK(#OP), 0);
               /* CASE 1 -- GREATER_THAN, LESS_EQ */
               CALL EMIT_TRIPLE(LGREATER, OPERAND#STK(#OP - 1),
                  OPERAND#STK(#OP), 0);
               /* CASE 2 -- LESS_THAN, GREATER_EQ */
               CALL EMIT_TRIPLE(LLESS, OPERAND#STK(#OP - 1),
                  OPERAND#STK(#OP), 0);
            END;
         ELSE IF (SHL(1, STRUCTYPE(#TP)) & "(1)00000 11001 11000") ¬= 0 THEN
               /* STRUCTYPE(#TP) IN (.POINTER, ARRAY, PACKED_ARRAY,
                                      RECORD, PACKED_RECORD.) */
            DO;
               IF (OP MOD 3) = 0 THEN
                  CALL EMIT_TRIPLE(LCOMPARE, OPERAND#STK(#OP - 1),
                     OPERAND#STK(#OP), 0);
               ELSE CALL ERROR(COMPARE_ERROR, 1);
            END;
         ELSE IF (SHL(1, STRUCTYPE(#TP)) & "(1)10000 00000 00110") ¬= 0 THEN
            /* STRUCTYPE(#TP) IN (.SCALAR, SUBRANGE, ARITHMETIC.) */
            DO CASE OP MOD 3;
               /* CASE 0 -- EQUAL_TO, NOT_EQUAL_TO */
               CALL EMIT_TRIPLE(COMPARE, OPERAND#STK(#OP - 1),
                  OPERAND#STK(#OP), 0);
               /* CASE 1 -- GREATER_THAN, LESS_EQ */
               CALL EMIT_TRIPLE(GREATER, OPERAND#STK(#OP - 1),
                  OPERAND#STK(#OP), 0);
               /* CASE 2 -- LESS_THAN, GREATER_EQ */
               CALL EMIT_TRIPLE(LESS, OPERAND#STK(#OP - 1),
                  OPERAND#STK(#OP), 0);
            END;
         ELSE CALL ERROR(COMPARE_ERROR, 1);
         #OP = #OP - 1;
         IF (FX & (OP < NOT_EQUAL_TO)) THEN
            CALL EMIT_TRIPLE(BNZ, LISTHEAD, (N_TRIPLES - 3) | MASK_TRIPLE, 0);
         ELSE IF (¬FX & (OP >= NOT_EQUAL_TO)) THEN
            CALL EMIT_TRIPLE(BNZ, LISTHEAD, (N_TRIPLES - 3) | MASK_TRIPLE, 0);
         ELSE CALL EMIT_TRIPLE(BZ, LISTHEAD, (N_TRIPLES - 3) | MASK_TRIPLE, 0);
         IF (STRUCTYPE(#TP) = SET) | (STRUCTYPE(#TP) = PACKED_SET) THEN
            TRIPLES(N_TRIPLES - 1) = OPERAND#STK(#OP);
         OPERAND#STK(#OP) = (N_TRIPLES - 3) | MASK_TRIPLE;
         LISTHEAD = (N_TRIPLES - 3) | SHL(FX, 15);
         #TP = BOOLPTR;
      END EMIT_COMPARE;

   EMIT_BOUND_CHECK:
      PROCEDURE(OPND, VALUE, COMPARISON);
         DECLARE (OPND, OPCD, COMPARISON) BIT(16), VALUE FIXED;
         IF COMPARISON = LESS_EQ THEN OPCD = GREATER;
         ELSE /* COMPARISON = GREATER_EQ */ OPCD = LESS;
         CALL EMIT_TRIPLE(OPCD, OPND, FINDCONST(VALUE), 0);
         CALL EMIT_TRIPLE(BNZ, LISTHEAD, (N_TRIPLES - 3) | MASK_TRIPLE, 0);
         LISTHEAD = (N_TRIPLES - 3) | SHL(FX, 15);
      END EMIT_BOUND_CHECK;

   PROCFUNC:
      PROCEDURE(IS_PROC);
         DECLARE IS_PROC BIT(1);
         DECLARE PARAM_ERROR CHARACTER INITIAL(
            'ILLEGAL PARAMETER TYPE IN CALL TO STANDARD PROCEDURE/FUNCTION');
         DECLARE #_PARAMS CHARACTER INITIAL(
            'WRONG NUMBER OF PARAMETERS IN CALL TO STANDARD PROCEDURE');
         DECLARE STD_FILE_ERR CHARACTER INITIAL(
            'ILLEGAL USE OF STANDARD FILE');
         DECLARE ERROR_FLAG BIT(1);
         DECLARE MONITOR_CODE(N_PREDECLARED_SYMB) BIT(8) INITIAL(
            "FF", "FF", "FF", "FF", "FF", "FF", "FF", "FF", "FF", "FF",
            "FF", 10, 11, 12, "FF", "FF", "FF", "FF", 9, 14,
            0, 1, 3, 4, 5, 2, 8, 13, 17, 18,
            19, 20, 15, "FF", "FF", "FF", "FF", "FF", 16, 31,
            29, 30, 35, "FF", "FF", "FF", "FF");
         /* OTHER MONITOR CODES */
         DECLARE READ_INT     BIT(16) INITIAL(21),
                 READ_REAL    BIT(16) INITIAL(22),
                 READ_CHAR    BIT(16) INITIAL(23),
                 WRITE_INT    BIT(16) INITIAL(24),
                 WRITE_REAL   BIT(16) INITIAL(25),
                 WRITE_BOOL   BIT(16) INITIAL(26),
                 WRITE_CHAR   BIT(16) INITIAL(27),
                 WRITE_STRING BIT(16) INITIAL(28);
         DECLARE (I, J) FIXED;
         DECLARE FILE_PTR BIT(16);
         DECLARE #TP1 BIT(16);
         DECLARE TAG_PTR BIT(16);
         DECLARE VARIANT_NOT_FOUND BIT(1);
         DECLARE RECORD_LENGTH FIXED;
         DECLARE (ARRAY1, ARRAY2) BIT(16);
         DECLARE (ARRAY1_TYPE, ARRAY2_TYPE) BIT(16);
         DECLARE FIRST_PROC BIT(16) INITIAL(11); /* INDEX OF 1ST STD. PROC */
         DECLARE PROPER BIT(N_PREDECLARED_SYMB) INITIAL
            ("(1)0 00000 00000 00000 00000 00000 00111 11111 10111 10000 0");
         DECLARE PARAMETERLESS BIT(N_PREDECLARED_SYMB) INITIAL
            ("(1)0 00000 00000 00000 00010 00000 01000 00000 00011 11000 0");

      IS_PROPER:
         PROCEDURE (STD_PROC) BIT(1);
            DECLARE STD_PROC BIT(16); /* INDEX OF A STANDARD PROC */
            /* RETURN TRUE IFF STD_PROC IS A PROPER STANDARD PROCEDURE */
            RETURN (SHL(BYTE(PROPER, SHR(STD_PROC, 3)), STD_PROC & "7") & "80")
                   ¬= 0;
         END IS_PROPER;

      IS_PARAMETERLESS:
         PROCEDURE (STD_PROC) BIT(1);
            DECLARE STD_PROC BIT(16); /* INDEX OF A STANDARD PROC */
            /* RETURN TRUE IFF STD_PROC CAN BE CALLED WITH NO PARAMETERS */
            RETURN (SHL(BYTE(PARAMETERLESS, SHR(STD_PROC, 3)), STD_PROC & "7")
                    & "80") ¬= 0;
         END IS_PARAMETERLESS;

         IF #MP = 1 THEN
            DO;
               ERROR_FLAG = (SHL(1, VAR_TYPE(TABLE_PTR)) &
                  "(1)01 00000 00101 00000") = 0;
               /* ERROR_FLAG = ¬(VAR_TYPE(TABLE_PTR) IN (.PROC, PROC_PARAM,
                     MULTDECL.)); */
               IF TABLE_PTR > N_PREDECLARED_SYMB THEN
                  DO;
                     IF IS_PROC THEN
                        ERROR_FLAG = ERROR_FLAG | (DATATYPE(TABLE_PTR) ¬= NULL);
                     ELSE ERROR_FLAG = ERROR_FLAG | (DATATYPE(TABLE_PTR) =NULL);
                  END;
               ELSE
                  ERROR_FLAG = ERROR_FLAG | (IS_PROC ¬= IS_PROPER(TABLE_PTR));
               IF ERROR_FLAG THEN
                  DO;
                     CALL ERROR('ILLEGAL PROCEDURE/FUNCTION IDENTIFIER', 1);
                     #POS_STACK(NP) = FATHERS_MULTIPLICITY;
                     IF IS_PROC THEN #OP = #OP - 1;
                     RETURN;
                  END;
               IF TABLE_PTR > N_PREDECLARED_SYMB THEN
                  DO;
                     IF VAR_TYPE(TABLE_PTR) = PROC_PARAM THEN
                        DO;
                           ID_PTR = VALUE(TABLE_PTR);
                           J = NULL;
                        END;
                     ELSE
                        DO;
                           ID_PTR = S_LIST(TABLE_PTR);
                           J = FINDCONST(VALUE(TABLE_PTR));
                        END;
                     CALL EMIT_TRIPLE(BLKMARK, TABLE_PTR, J, 0);
                     I = 1;
                     DO WHILE ID_PTR ¬= NULL;
                        I = I + 1;
                        ID_PTR = S_LIST(ID_PTR);
                     END;
                     IF I ¬= FATHERS_MULTIPLICITY THEN
                        DO;
                           CALL ERROR('WRONG NUMBER OF PARAMETERS', 1);
                           #POS_STACK(NP) = FATHERS_MULTIPLICITY;
                           IF IS_PROC THEN #OP = #OP - 1;
                           RETURN;
                        END;
                     IF FATHERS_MULTIPLICITY = 1 THEN
                        DO;   /* PARAMETERLESS CALL */
                           CALL EMIT_TRIPLE(PCALL, TABLE_PTR, J, 3);
                           IF IS_PROC THEN
                              DO;
                                 CALL EMIT_TRIPLE(TPOP, (N_TRIPLES - 3) |
                                    MASK_TRIPLE, NULL, 0);
                                 #OP = #OP - 1;
                              END;
                           ELSE OPERAND#STK(#OP) = (N_TRIPLES - 3) |MASK_TRIPLE;
                        END;   /* FATHERS_MULTIPLICITY = 1 */
                     ELSE IF VAR_TYPE(S_LIST(TABLE_PTR)) ¬= VARIABLE THEN
                        PARAMLIST = TRUE;
                  END;   /* USER-DEFINED PROC/FUNC */
               ELSE IF FATHERS_MULTIPLICITY = 1 THEN
                  DO;   /* PARAMETERLESS STANDARD PROC/FUNC CALL */
                     IF TABLE_PTR = CLOCKPTR THEN
                        DO;
                           CALL EMIT_TRIPLE(MONITOR, NULL, NULL,
                                            MONITOR_CODE(CLOCKPTR));
                           OPERAND#STK(#OP) = (N_TRIPLES - 3) | MASK_TRIPLE;
                           #TP = INTPTR;
                           RETURN;
                        END;
                     IF (TABLE_PTR = PAGEPTR) | (TABLE_PTR = WRITELNPTR) THEN
                        I = OUTPUTPTR;
                     ELSE I = INPUTPTR;
                     CALL EMIT_TRIPLE(LOAD_ADDR, I, NULL, 3);
                     IF IS_PROC THEN #OP = #OP - 1;
                     ELSE OPERAND#STK(#OP) = N_TRIPLES | MASK_TRIPLE;
                     CALL EMIT_TRIPLE(MONITOR, (N_TRIPLES - 3) | MASK_TRIPLE,
                        NULL, MONITOR_CODE(TABLE_PTR));
                     IF ¬IS_PARAMETERLESS(TABLE_PTR) THEN CALL ERROR(
                 'MISSING PARAMETER IN CALL TO STANDARD PROCEDURE/FUNCTION', 1);
                  END;
               ELSE   /* THERE ARE PARAMETERS */
                  DO;
                     IF (TABLE_PTR = READPTR) | (TABLE_PTR = READLNPTR) THEN
                        PARAMLIST = TRUE;   /* SIGNAL CALL BY REFERENCE */
                     IF (¬IS_PROC) & (FATHERS_MULTIPLICITY > 2) THEN
                        DO;
                           CALL ERROR(
                         'TOO MANY PARAMETERS IN CALL TO STANDARD FUNCTION', 1);
                           #POS_STACK(NP) = FATHERS_MULTIPLICITY;
                        END;
                  END;
            END;   /* #MP = 1 */
         ELSE
            DO;
               ID_PTR = OPERAND#STK(#OP - 1);
               IF #TP = BOOLPTR THEN
                  IF IS_CONDITION(OPERAND#STK(#OP)) THEN
                     CALL COND_TO_REGISTER;
               TABLE_PTR = OPERAND#STK(#OP);
               IF ID_PTR > N_PREDECLARED_SYMB THEN
                  DO;
                     IF VAR_TYPE(ID_PTR) = PROC_PARAM THEN
                        DO;
                           J = NULL;
                           ID_PTR = VALUE(ID_PTR);
                        END;
                     ELSE
                        DO;
                           J = FINDCONST(VALUE(ID_PTR));
                           ID_PTR = S_LIST(ID_PTR);
                        END;
                     DO I = 3 TO #MP;
                        ID_PTR = S_LIST(ID_PTR);
                     END;
                     CALL COERCE_PARAMETER(TABLE_PTR, ID_PTR, #TP);
                     CALL EMIT_TRIPLE(PARM, ID_PTR, OPERAND#STK(#OP), 0);
                     #OP = #OP - 1;
                     IF #MP = FATHERS_MULTIPLICITY THEN
                        DO;
                           CALL EMIT_TRIPLE(PCALL, OPERAND#STK(#OP), J, 3);
                           IF IS_PROC THEN
                              DO;
                                 CALL EMIT_TRIPLE(TPOP, (N_TRIPLES - 3) |
                                    MASK_TRIPLE, NULL, 0);
                                 #OP = #OP - 1;
                              END;
                           ELSE
                              DO;
                                 #TP = DATATYPE(OPERAND#STK(#OP));
                                 OPERAND#STK(#OP) = (N_TRIPLES - 3)|MASK_TRIPLE;
                              END;
                        END;
                     ELSE PARAMLIST = (VAR_TYPE(S_LIST(ID_PTR)) ¬= VARIABLE);
                     RETURN;
                  END;   /* USER-DEFINED PROC/FUNC */
               DO CASE ID_PTR - FIRST_PROC;
                  /* CASE 0 -- ABS() */
                  DO;
                     IF COMPTYPES(#TP, REALPTR) THEN
                        CALL EMIT_TRIPLE(ABSFLT, TABLE_PTR, NULL, 3);
                     ELSE
                        DO;
                           CALL COERCE_ASSIGNMENT(INTPTR, #TP);
                           CALL EMIT_TRIPLE(ABS, OPERAND#STK(#OP), NULL, 3);
                           #TP = INTPTR;
                        END;
                     #OP = #OP - 1;
                     OPERAND#STK(#OP) = (N_TRIPLES - 3) | MASK_TRIPLE;
                  END;
                  /* CASE 1 -- SQR() */
                  DO;
                     IF COMPTYPES(#TP, REALPTR) THEN
                        CALL EMIT_TRIPLE(SQRFLT, TABLE_PTR, NULL, 3);
                     ELSE
                        DO;
                           CALL COERCE_ASSIGNMENT(INTPTR, #TP);
                           CALL EMIT_TRIPLE(SQR, OPERAND#STK(#OP), NULL, 3);
                           #TP = INTPTR;
                        END;
                     #OP = #OP - 1;
                     OPERAND#STK(#OP) = (N_TRIPLES - 3) | MASK_TRIPLE;
                  END;
                  /* CASE 2 -- ODD() */
                  DO;
                     CALL COERCE_ASSIGNMENT(INTPTR, #TP);
                     CALL EMIT_TRIPLE(ODD, TABLE_PTR, NULL, 3);
                     #TP = BOOLPTR;
                     #OP = #OP - 1;
                     OPERAND#STK(#OP) = (N_TRIPLES - 3) | MASK_TRIPLE;
                  END;
                  /* CASE 3 -- SUCC() */
               PREDSUCC:
                  DO;
                     IF ID_PTR = SUCCPTR THEN I = ADD;
                     ELSE /* PRED() */ I = SUBTRACT;
                     CALL EMIT_TRIPLE(I, TABLE_PTR, 1 | MASK_IMMEDIATE, 3);
                     #OP = #OP - 1;
                     OPERAND#STK(#OP) = (N_TRIPLES - 3) | MASK_TRIPLE;
                     IF (STRUCTYPE(#TP) = SCALAR) |
                        (STRUCTYPE(#TP) = SUBRANGE) THEN
                        CALL RANGE_CHECK(#TP, (ID_PTR ¬= SUCCPTR),
                                         (ID_PTR = SUCCPTR));
                     ELSE IF ¬COMPTYPES(#TP, INTPTR) THEN
                        CALL ERROR(PARAM_ERROR, 1);
                  END;
                  /* CASE 4 -- PRED() */
                  GOTO PREDSUCC;
                  /* CASE 5 -- ORD() */
                  DO;
                     #OP = #OP - 1;
                     OPERAND#STK(#OP) = TABLE_PTR;
                     IF ((SHL(1, STRUCTYPE(#TP)) & "(1)00000 00000 01110") = 0)
                        /* ¬(#TP IN (.POINTER, SUBRANGE, SCALAR.)) */
                        & ¬COMPTYPES(#TP, INTPTR) THEN
                        CALL ERROR(PARAM_ERROR, 1);
                     #TP = INTPTR;
                  END;
                  /* CASE 6 -- CHR() */
                  DO;
                     #OP = #OP - 1;
                     OPERAND#STK(#OP) = TABLE_PTR;
                     CALL COERCE_ASSIGNMENT(INTPTR, #TP);
                     CALL RANGE_CHECK(CHARPTR, TRUE, TRUE);
                     #TP = CHARPTR;
                  END;
                  /* CASE 7 -- TRUNC() */
               TRUNCROUND:
                  DO;
                     CALL COERCE_ASSIGNMENT(REALPTR, #TP);
                     IF ID_PTR = TRUNCPTR THEN I = TRUNCATE;
                     ELSE /* ROUND() */ I = ROUND;
                     CALL EMIT_TRIPLE(I, OPERAND#STK(#OP), NULL, 3);
                     #OP = #OP - 1;
                     OPERAND#STK(#OP) = (N_TRIPLES - 3) | MASK_TRIPLE;
                     #TP = INTPTR;
                  END;
                  /* CASE 8 -- EOF() */
                  DO;
                     #OP = #OP - 1;
                     CALL EMIT_TRIPLE(LOAD_ADDR, TABLE_PTR, NULL, 3);
                     OPERAND#STK(#OP) = N_TRIPLES | MASK_TRIPLE;
                     CALL EMIT_TRIPLE(MONITOR, (N_TRIPLES - 3) | MASK_TRIPLE,
                        NULL, MONITOR_CODE(ID_PTR));
                     IF (STRUCTYPE(#TP) ¬= FILE) &
                        (STRUCTYPE(#TP) ¬= PACKED_FILE) THEN
                        CALL ERROR(PARAM_ERROR, 1);
                     #TP = BOOLPTR;
                  END;
                  /* CASE 9 -- SIN() */
               SINCOSEXPLNSQRTARCTAN:
                  DO;
                     CALL COERCE_ASSIGNMENT(REALPTR, #TP);
                     CALL EMIT_TRIPLE(MONITOR, OPERAND#STK(#OP), NULL,
                        MONITOR_CODE(ID_PTR));
                     #OP = #OP - 1;
                     OPERAND#STK(#OP) = (N_TRIPLES - 3) | MASK_TRIPLE;
                     #TP = REALPTR;
                  END;
                  /* CASE 10 -- COS() */
                  GOTO SINCOSEXPLNSQRTARCTAN;
                  /* CASE 11 -- EXP() */
                  GOTO SINCOSEXPLNSQRTARCTAN;
                  /* CASE 12 -- LN() */
                  GOTO SINCOSEXPLNSQRTARCTAN;
                  /* CASE 13 -- SQRT() */
                  GOTO SINCOSEXPLNSQRTARCTAN;
                  /* CASE 14 -- ARCTAN() */
                  GOTO SINCOSEXPLNSQRTARCTAN;
                  /* CASE 15 -- ROUND() */
                  GOTO TRUNCROUND;
                  /* CASE 16 -- EOLN() */
                  DO;
                     #OP = #OP - 1;
                     CALL EMIT_TRIPLE(LOAD_ADDR, TABLE_PTR, NULL, 3);
                     OPERAND#STK(#OP) = N_TRIPLES | MASK_TRIPLE;
                     CALL EMIT_TRIPLE(MONITOR, (N_TRIPLES - 3) | MASK_TRIPLE,
                        NULL, MONITOR_CODE(ID_PTR));
                     IF ¬COMPTYPES(TEXTPTR, #TP) THEN
                        CALL ERROR(PARAM_ERROR, 1);
                     #TP = BOOLPTR;
                  END;
                  /* CASE 17 -- GET() */
               GETPUTRESETREWRITEPAGE:
                  DO;
                     #OP = #OP - 2;
                     CALL EMIT_TRIPLE(LOAD_ADDR, TABLE_PTR, NULL, 3);
                     CALL EMIT_TRIPLE(MONITOR, (N_TRIPLES - 3) | MASK_TRIPLE,
                        NULL, MONITOR_CODE(ID_PTR));
                     IF (STRUCTYPE(#TP) ¬= FILE) &
                        (STRUCTYPE(#TP) ¬= PACKED_FILE) THEN
                        CALL ERROR(PARAM_ERROR, 1);
                     IF ((TABLE_PTR = INPUTPTR) & (ID_PTR ¬= GETPTR)) |
                        ((TABLE_PTR = OUTPUTPTR) & (ID_PTR ¬= PUTPTR)
                                    & (ID_PTR ¬= PAGEPTR)) THEN
                        CALL ERROR(STD_FILE_ERR, 1);
                     IF FATHERS_MULTIPLICITY > 2 THEN
                        DO;
                           CALL ERROR(#_PARAMS, 1);
                           #POS_STACK(NP) = FATHERS_MULTIPLICITY;
                        END;
                  END;
                  /* CASE 18 -- PUT() */
                  GOTO GETPUTRESETREWRITEPAGE;
                  /* CASE 19 -- RESET() */
                  GOTO GETPUTRESETREWRITEPAGE;
                  /* CASE 20 -- REWRITE() */
                  GOTO GETPUTRESETREWRITEPAGE;
                  /* CASE 21 -- NEW() */
                  IF #MP = 2 THEN
                     DO;
                        IF STRUCTYPE(#TP) ¬= POINTER THEN
                           CALL ERROR(PARAM_ERROR, 1);
                        IF (STRUCTYPE(DATATYPE(#TP)) = SCALAR) |
                           (STRUCTYPE(DATATYPE(#TP)) = SUBRANGE) THEN
                           RECORD_LENGTH = 2;
                        ELSE RECORD_LENGTH = STORAGE_LNGTH(DATATYPE(#TP));
                        CALL EMIT_TRIPLE(MONITOR, FINDCONST(RECORD_LENGTH),
                           NULL, MONITOR_CODE(ID_PTR));
                        CALL EMIT_TRIPLE(STORE, TABLE_PTR, (N_TRIPLES - 3) |
                           MASK_TRIPLE, 0);
                        IF FATHERS_MULTIPLICITY = 2 THEN
                           DO;
                              #OP = #OP - 2;
                              RETURN;
                           END;
                        /* FLAG THE 'MONITOR' TRIPLE AS REUSABLE */
                        TRIPLES(N_TRIPLES - 1) = (N_TRIPLES - 6) | MASK_TEMP;
                        ERROR_FLAG = FALSE;
                        I = STRUCTYPE(DATATYPE(#TP));
                        IF (I ¬= RECORD) & (I ¬= PACKED_RECORD) THEN
                           ERROR_FLAG = TRUE;
                        ELSE
                           DO;
                              TAG_PTR = S_LIST(DATATYPE(#TP));
                              DO WHILE (STRUCTYPE(TAG_PTR) ¬= TAG) &
                                 (TAG_PTR ¬= NULL);
                                 TAG_PTR = S_LIST(TAG_PTR);
                              END;
                              ERROR_FLAG = (TAG_PTR = NULL);
                           END;
                        IF ERROR_FLAG THEN
                           DO;
                              #POS_STACK(NP) = FATHERS_MULTIPLICITY;
                              #OP = #OP - 2;
                              CALL ERROR(
                               'MISSING CORRESPONDING TAGFIELD DECLARATION', 1);
                              RETURN;
                           END;
                        /* SAVE POINTER TO THE "MONITOR" TRIPLE */
                        FIX_LIST(NP) = (N_TRIPLES - 6) | MASK_TRIPLE;
                        #OP = #OP - 1;
                     END;   /* #MP = 2 */
                  ELSE
                     DO;
                        I = FIX_LIST(NP);   /* POINTS TO "MONITOR" TRIPLE */
                        IF #MP < FATHERS_MULTIPLICITY THEN
                           I = I | MASK_TEMP;   /* FLAGS TRIPLE AS REUSABLE */
                        CALL EMIT_TRIPLE(INDEX, 0 | MASK_IMMEDIATE, I,
                           RECORD_LENGTH - 1);
                        CALL EMIT_TRIPLE(INDEX, (N_TRIPLES - 3) | MASK_TRIPLE,
                           FINDCONST(DISPLACEMENT(TAG_PTR)), 1);
                        IF (TABLE_PTR & "C000") = MASK_SYMBOL THEN
                           ERROR_FLAG = (VAR_TYPE(TABLE_PTR) ¬= CONSTANT);
                        ELSE ERROR_FLAG =
                           ((TABLE_PTR & "C000") ¬= MASK_IMMEDIATE);
                        IF ERROR_FLAG THEN
                           DO;
                              CALL ERROR(
                             'CONSTANT REQUIRED IN TAGFIELD INITIALIZATION', 1);
                              #POS_STACK(NP) = FATHERS_MULTIPLICITY;
                              #OP = #OP - 2;
                              RETURN;
                           END;
                        I = (N_TRIPLES - 3) | MASK_TRIPLE;
                        CALL COERCE_ASSIGNMENT(DATATYPE(TAG_PTR), #TP);
                        CALL EMIT_TRIPLE(STORE, I, OPERAND#STK(#OP), 0);
                        IF #MP = FATHERS_MULTIPLICITY THEN
                           DO;
                              #OP = #OP - 2;
                              RETURN;
                           END;
                        /* PREPARE FOR NEXT VISIT BY UPDATING TAG_PTR.
                           FIRST, FIND THE <VARIANT INSTANCE> WHICH
                           CORRESPONDS TO TABLE_PTR. */
                        IF (TABLE_PTR & "C000") = MASK_IMMEDIATE THEN
                           I = TABLE_PTR & "3FFF";
                        ELSE I = VALUE(TABLE_PTR);
                        TABLE_PTR = OWNER(TAG_PTR);
                        VARIANT_NOT_FOUND = TRUE;
                        TAG_PTR = S_LIST(TAG_PTR);
                        DO WHILE VARIANT_NOT_FOUND & (TAG_PTR ¬= NULL);
                           IF VALUE(TAG_PTR) = I THEN
                              DO;
                                 VARIANT_NOT_FOUND = FALSE;
                                 DO WHILE (VAR_TYPE(TAG_PTR) = CASELABEL) &
                                    (TAG_PTR ¬= NULL);
                                    TAG_PTR = S_LIST(TAG_PTR);
                                 END;
                              END;
                           ELSE
                              DO;   /* LOCATE NEXT CASELABEL */
                                 TAG_PTR = S_LIST(TAG_PTR);
                                 DO WHILE (OWNER(TAG_PTR) ¬= TABLE_PTR) &
                                    (TAG_PTR ¬= NULL);
                                    TAG_PTR = S_LIST(TAG_PTR);
                                 END;
                              END;
                        END;
                        /* NOW FIND THE TAGFIELD */
                        TABLE_PTR = TAG_PTR;
                        IF TAG_PTR ¬= NULL THEN TAG_PTR = S_LIST(TAG_PTR);
                        DO WHILE (TAG_PTR ¬= NULL) &(OWNER(TAG_PTR) = TABLE_PTR)
                           & (STRUCTYPE(TAG_PTR) ¬= TAG);
                           TAG_PTR = S_LIST(TAG_PTR);
                        END;
                        IF (TAG_PTR = NULL) | (OWNER(TAG_PTR) ¬= TABLE_PTR) THEN
                           DO;
                              CALL ERROR(
                               'MISSING CORRESPONDING TAGFIELD DECLARATION', 1);
                              #POS_STACK(NP) = FATHERS_MULTIPLICITY;
                              #OP = #OP - 2;
                           END;
                        ELSE #OP = #OP - 1;
                     END;   /* #MP > 2 */
                  /* CASE 22 -- READ() */
               READREADLN:
                  DO;
                     IF #MP = 2 THEN
                        IF (STRUCTYPE(#TP) = FILE) |
                           (STRUCTYPE(#TP) = PACKED_FILE) THEN
                           DO;
                              IF TABLE_PTR = OUTPUTPTR THEN
                                 DO;
                                    CALL ERROR(STD_FILE_ERR, 1);
                                    #OP = #OP - 2;
                                    #POS_STACK(NP) = FATHERS_MULTIPLICITY;
                                    RETURN;
                                 END;
                              IF ID_PTR = READLNPTR THEN
                                 IF ¬COMPTYPES(#TP, TEXTPTR) THEN
                                       DO;
                                          CALL ERROR(PARAM_ERROR, 1);
                                          #OP = #OP - 2;
                                          #POS_STACK(NP) = FATHERS_MULTIPLICITY;
                                          RETURN;
                                       END;
                              FILE_PTR = TABLE_PTR;
                              CALL EMIT_TRIPLE(LOAD_ADDR, FILE_PTR, NULL, 3);
                              FIX_LIST(NP) = (N_TRIPLES - 3) | MASK_TRIPLE;
                              IF FATHERS_MULTIPLICITY = 2 THEN
                                 DO;
                                    #OP = #OP - 2;
                                    IF ID_PTR = READPTR THEN
                                       CALL ERROR(#_PARAMS, 1);
                                    ELSE /* READLN() */
                                       CALL EMIT_TRIPLE(MONITOR, FIX_LIST(NP),
                                          NULL, MONITOR_CODE(ID_PTR));
                                 END;
                              RETURN;
                           END;
                        ELSE /* DEFAULT FILE IS INPUT */
                           DO;
                              FILE_PTR = INPUTPTR;
                              CALL EMIT_TRIPLE(LOAD_ADDR, INPUTPTR, NULL, 3);
                              FIX_LIST(NP) = (N_TRIPLES - 3) | MASK_TRIPLE;
                           END;
                     I = FIX_LIST(NP); /* ADDR OF FILE */
                     IF (#MP < FATHERS_MULTIPLICITY) | (ID_PTR = READLNPTR) THEN
                        I = I | MASK_TEMP;
                     IF ¬COMPTYPES(DATATYPE(FILE_PTR), TEXTPTR) THEN
                        DO;
                           CALL EMIT_TRIPLE(MONITOR, I, NULL,
                                            MONITOR_CODE(GETPTR));
                           OPERAND#STK(#OP) = FILE_PTR;
                           CALL COERCE_ASSIGNMENT(DATATYPE(DATATYPE(FILE_PTR)),
                              #TP);
                           CALL EMIT_TRIPLE(STORE, TABLE_PTR, OPERAND#STK(#OP),
                              0);
                        END;
                     ELSE
                        DO;
                           IF STRUCTYPE(#TP) = SUBRANGE THEN
                              #TP1 = DATATYPE(#TP);
                           ELSE #TP1 = #TP;
                           IF COMPTYPES(#TP1, INTPTR) THEN
                              J = READ_INT;
                           ELSE IF COMPTYPES(#TP1, REALPTR) THEN
                              J = READ_REAL;
                           ELSE IF COMPTYPES(#TP1, CHARPTR) THEN
                              J = READ_CHAR;
                           ELSE CALL ERROR(PARAM_ERROR, 1);
                           CALL EMIT_TRIPLE(MONITOR, I, NULL, J);
                           OPERAND#STK(#OP) = (N_TRIPLES - 3) | MASK_TRIPLE;
                           IF #TP ¬= #TP1 THEN CALL COERCE_ASSIGNMENT(#TP,#TP1);
                           CALL EMIT_TRIPLE(STORE, TABLE_PTR,
                              OPERAND#STK(#OP), 0);
                        END;
                     IF #MP = FATHERS_MULTIPLICITY THEN
                        DO;
                           #OP = #OP - 2;
                           IF ID_PTR = READLNPTR THEN
                              CALL EMIT_TRIPLE(MONITOR, FIX_LIST(NP), NULL,
                                 MONITOR_CODE(ID_PTR));
                        END;
                     ELSE #OP = #OP - 1;
                  END;
                  /* CASE 23 -- WRITE() */
               WRITEWRITELN:
                  DO;
                     IF #MP = 2 THEN
                        IF (STRUCTYPE(#TP) = FILE) |
                           (STRUCTYPE(#TP) = PACKED_FILE) THEN
                           DO;
                              IF TABLE_PTR = INPUTPTR THEN
                                 DO;
                                    CALL ERROR(STD_FILE_ERR, 1);
                                    #OP = #OP - 2;
                                    #POS_STACK(NP) = FATHERS_MULTIPLICITY;
                                    RETURN;
                                 END;
                              IF ID_PTR = WRITELNPTR THEN
                                 IF ¬COMPTYPES(#TP, TEXTPTR) THEN
                                    DO;
                                       CALL ERROR(PARAM_ERROR, 1);
                                       #OP = #OP - 2;
                                       #POS_STACK(NP) = FATHERS_MULTIPLICITY;
                                       RETURN;
                                    END;
                              FILE_PTR = TABLE_PTR;
                              CALL EMIT_TRIPLE(LOAD_ADDR, TABLE_PTR, NULL, 3);
                              FIX_LIST(NP) = (N_TRIPLES - 3) | MASK_TRIPLE;
                              IF FATHERS_MULTIPLICITY = 2 THEN
                                 DO;
                                    #OP = #OP - 2;
                                    IF ID_PTR = WRITEPTR THEN
                                       CALL ERROR(#_PARAMS, 1);
                                    ELSE /* WRITELN() */
                                       CALL EMIT_TRIPLE(MONITOR, FIX_LIST(NP),
                                          NULL, MONITOR_CODE(ID_PTR));
                                 END;
                              RETURN;
                           END;
                        ELSE   /* DEFAULT FILE IS OUTPUT */
                           DO;
                              FILE_PTR = OUTPUTPTR;
                              CALL EMIT_TRIPLE(LOAD_ADDR, OUTPUTPTR, NULL, 3);
                              FIX_LIST(NP) = (N_TRIPLES - 3) | MASK_TRIPLE;
                           END;
                     I = FIX_LIST(NP);   /* ADDR OF FILE */
                     IF (#MP < FATHERS_MULTIPLICITY)
                        | (ID_PTR = WRITELNPTR) THEN
                        I = I | MASK_TEMP;
                     IF ¬COMPTYPES(DATATYPE(FILE_PTR), TEXTPTR) THEN
                        DO;
                           CALL COERCE_ASSIGNMENT(DATATYPE(FILE_PTR), #TP);
                           CALL EMIT_TRIPLE(STORE, FILE_PTR,OPERAND#STK(#OP),0);
                           CALL EMIT_TRIPLE(MONITOR, I, NULL,
                                            MONITOR_CODE(PUTPTR));
                        END;
                     ELSE
                        DO;
                           IF STRUCTYPE(#TP) = SUBRANGE THEN
                              DO;
                                 CALL COERCE_ASSIGNMENT(DATATYPE(#TP), #TP);
                                 #TP = DATATYPE(#TP);
                                 TABLE_PTR = OPERAND#STK(#OP);
                              END;
                           IF COMPTYPES(#TP, INTPTR) THEN
                              J = WRITE_INT;
                           ELSE IF COMPTYPES(#TP, REALPTR) THEN
                              J = WRITE_REAL;
                           ELSE IF COMPTYPES(#TP, BOOLPTR) THEN
                              J = WRITE_BOOL;
                           ELSE IF COMPTYPES(#TP, CHARPTR) THEN
                              J = WRITE_CHAR;
                           ELSE IF ((STRUCTYPE(#TP) = ARRAY) |
                                    (STRUCTYPE(#TP) = PACKED_ARRAY)) &
                              COMPTYPES(DATATYPE(#TP), CHARPTR) THEN
                              DO;   /* FORM A STRING DESCRIPTOR */
                                 CALL EMIT_TRIPLE(LOAD_ADDR, TABLE_PTR, NULL,3);
                                 CALL EMIT_TRIPLE(ADD,(N_TRIPLES-3)|MASK_TRIPLE,
                                    FINDCONST(SHL(STORAGE_LNGTH(#TP)-1,24)), 3);
                                 TABLE_PTR = (N_TRIPLES - 3) | MASK_TRIPLE;
                                 J = WRITE_STRING;
                              END;
                           ELSE CALL ERROR(PARAM_ERROR, 1);
                           CALL EMIT_TRIPLE(MONITOR, I, TABLE_PTR, J);
                        END;
                     IF #MP = FATHERS_MULTIPLICITY THEN
                        DO;
                           #OP = #OP - 2;
                           IF ID_PTR = WRITELNPTR THEN
                              CALL EMIT_TRIPLE(MONITOR, FIX_LIST(NP),
                                 NULL, MONITOR_CODE(ID_PTR));
                        END;
                     ELSE #OP = #OP - 1;
                  END;
                  /* CASE 24 -- PACK() */
               PACKUNPACK:
                  IF #MP = 2 THEN
                     DO;
                        IF FATHERS_MULTIPLICITY ¬= 4 THEN
                           DO;
                              #OP = #OP - 2;
                              CALL ERROR(#_PARAMS, 1);
                              #POS_STACK(NP) = FATHERS_MULTIPLICITY;
                              RETURN;
                           END;
                        IF ID_PTR = PACKPTR THEN
                           DO;
                              ARRAY1 = TABLE_PTR;
                              ARRAY1_TYPE = #TP;
                           END;
                        ELSE /* UNPACK() */
                           DO;
                              ARRAY2 = TABLE_PTR;
                              ARRAY2_TYPE = #TP;
                           END;
                        #OP = #OP - 1;
                     END;
                  ELSE IF #MP = 3 THEN
                     DO;
                        IF ID_PTR = PACKPTR THEN
                           DO;
                              FIX_LIST(NP) = TABLE_PTR;
                              #TP1 = #TP;
                           END;
                        ELSE /* UNPACK() */
                           DO;
                              ARRAY1 = TABLE_PTR;
                              ARRAY1_TYPE = #TP;
                           END;
                        #OP = #OP - 1;
                     END;
                  ELSE /* #MP = 4 */
                     DO;
                        IF ID_PTR = PACKPTR THEN
                           DO;
                              ARRAY2 = TABLE_PTR;
                              ARRAY2_TYPE = #TP;
                           END;
                        ELSE /* UNPACK() */
                           DO;
                              FIX_LIST(NP) = TABLE_PTR;
                              #TP1 = #TP;
                           END;
                        ERROR_FLAG = (STRUCTYPE(ARRAY1_TYPE) ¬= ARRAY)
                                     | (STRUCTYPE(ARRAY2_TYPE) ¬= ARRAY);
                        IF ¬ERROR_FLAG THEN
                           ERROR_FLAG =
                              (STORAGE_LNGTH(ARRAY1_TYPE)
                                 < STORAGE_LNGTH(ARRAY2_TYPE))
                              | ¬COMPTYPES(DATATYPE(ARRAY1_TYPE),
                                           DATATYPE(ARRAY2_TYPE));
                        IF ERROR_FLAG | (VAR_TYPE(ARRAY1_TYPE) = LITERAL) THEN
                           DO;
                              CALL ERROR(PARAM_ERROR, 1);
                              #OP = #OP - 2;
                              RETURN;
                           END;
                        OPERAND#STK(#OP) = FIX_LIST(NP);
                        CALL COERCE_ASSIGNMENT(S_LIST(ARRAY1_TYPE), #TP1);
                        I = STORAGE_LNGTH(ARRAY2_TYPE);
                        /* I EQUALS NUMBER OF BYTES TO BE MOVED */
                        J = STORAGE_LNGTH(ARRAY1_TYPE)/STORAGE_LNGTH(
                           S_LIST(ARRAY1_TYPE));
                        /* J IS ARRAY ELEMENT SIZE */
                        TABLE_PTR = OPERAND#STK(#OP);
                        IF (TABLE_PTR & "C000") = (MASK_TRIPLE & "C000") THEN
                           TABLE_PTR = TABLE_PTR | MASK_TEMP;
                        /* FLAG TABLE_PTR AS REUSABLE */
                        CALL EMIT_TRIPLE(GREATER, TABLE_PTR,
                           FINDCONST((STORAGE_LNGTH(ARRAY1_TYPE) - I)/J), 0);
                        CALL EMIT_TRIPLE(BZ, (N_TRIPLES + 6) | MASK_TRIPLE,
                           (N_TRIPLES - 3) | MASK_TRIPLE, 0);
                        /* VALUE OUT OF RANGE */
                        CALL EMIT_TRIPLE(MONITOR, NULL, NULL, 32);
                        CALL EMIT_TRIPLE(BCH_TARGET, NULL, NULL, 1);
                        IF J ¬= 1 THEN
                           DO;
                              CALL EMIT_TRIPLE(MULTIPLY, OPERAND#STK(#OP),
                                 FINDCONST(J), 3);
                              OPERAND#STK(#OP) = (N_TRIPLES - 3) | MASK_TRIPLE;
                           END;
                        CALL EMIT_TRIPLE(INDEX, ARRAY1, OPERAND#STK(#OP), I-1);
                        OPERAND#STK(#OP) = (N_TRIPLES - 3) | MASK_TRIPLE;
                        IF I > 256 THEN
                           CALL EMIT_TRIPLE(S_LENGTH, SHR(I, 16), I, 0);
                        IF ID_PTR = PACKPTR THEN
                           CALL EMIT_TRIPLE(STORE, ARRAY2, OPERAND#STK(#OP), 0);
                        ELSE /* UNPACK() */
                           CALL EMIT_TRIPLE(STORE, OPERAND#STK(#OP), ARRAY2, 0);
                        #OP = #OP - 2;
                     END;
                  /* CASE 25 -- UNPACK() */
                  GOTO PACKUNPACK;
                  /* CASE 26 -- (NOT USED) */
                  ;
                  /* CASE 27 -- DISPOSE() */
                  DO;
                     IF #MP = 2 THEN
                        DO;
                           IF STRUCTYPE(#TP) ¬= POINTER THEN
                              CALL ERROR(PARAM_ERROR, 1);
                           IF (STRUCTYPE(DATATYPE(#TP)) = SCALAR) |
                              (STRUCTYPE(DATATYPE(#TP)) = SUBRANGE) THEN
                              RECORD_LENGTH = 2;
                           ELSE RECORD_LENGTH = STORAGE_LNGTH(DATATYPE(#TP));
                           CALL EMIT_TRIPLE(MONITOR, TABLE_PTR,
                              FINDCONST(RECORD_LENGTH), MONITOR_CODE(ID_PTR));
                        END;
                     IF #MP = FATHERS_MULTIPLICITY THEN #OP = #OP - 2;
                     ELSE #OP = #OP - 1;
                  END;
                  /* CASE 28 -- PAGE() */
                  GOTO GETPUTRESETREWRITEPAGE;
                  /* CASE 29 -- READLN() */
                  GOTO READREADLN;
                  /* CASE 30 -- WRITELN() */
                  GOTO WRITEWRITELN;
                  /* CASE 31 -- CLOCK */
                  DO;
                     CALL ERROR('STANDARD FUNCTION CLOCK HAS NO PARAMETERS', 1);
                     #OP = #OP - 1;
                     #POS_STACK(NP) = FATHERS_MULTIPLICITY;
                     #TP = INTPTR;
                  END;
               END;   /* CASE */
            END;   /* #MP > 1 */
      END PROCFUNC;

     /*         $P ----- ENABLES XREF PROGRAM         */
      FIRST_VISIT = TRUE;
      NP, #OP = 0;
      NODE = ROOT_OF_SUBTREE;
      IF ¬IS_VALID_ROOT_PRODUCTION(PARSE_TREE(NODE + 1)) THEN RETURN;
      DO WHILE FIRST_VISIT | NP > 0;
         IF FIRST_VISIT THEN
            DO;
               IF NODE = NULL THEN FIRST_VISIT = FALSE;
               ELSE IF IS_LEAF THEN
                  DO;
                     TABLE_PTR = PARSE_TREE(NODE + 1);
                     FIRST_VISIT = FALSE;
                     IF IS_DECLARATION THEN CALL REPLACE(TABLE_PTR);
                     ELSE
                        DO; /* PUSH SYMBOL TABLE POINTER ONTO OPERAND STACK */
                           IF #OP < #OPMAX THEN #OP = #OP + 1;
                           ELSE
                              DO;
                                 CALL ERROR(OP#STACK#ERR, 1);
                                 #OP = 10;
                              END;
                           OPERAND#STK(#OP) = TABLE_PTR;
                           /* OPERAND#STK IS POPPED WHEN TRIPLES ARE FORMED */
                           #TP = DATATYPE(TABLE_PTR);
                           CALL REPLACE(#TP);
                        END;
                  END;
               ELSE
                  DO;
                     /* CASE STATEMENT ON PRODUCTION NUMBER OF NODE */
                     I = PARSE_TREE(NODE + 1);
                     DO CASE PR_CASES(I);
                        /*  CASE 0 -- NO ACTION  */
                        ;
                        /* CASE 1 -- WHILE OR UNTIL STATEMENT  */
                        DO;
                           CALL EMIT_TRIPLE(BCH_TARGET, NULL, NULL, 0);
                           IF NP < NPMAX THEN
                              FIX_LIST(NP + 1) = (N_TRIPLES - 3) | MASK_TRIPLE;
                           FX = FALSE;
                           LISTHEAD = NULL;
                        END;
                        /* CASE 2 -- PROD. 66 RECORD TYPE.  CREATE SY_TABLE
                                              ENTRY                    */
                        DO;
                           IF ALLOCATE_NEW_ROW THEN
                              ID_PTR = NEXT_FREE_ROW;
                           ELSE
                              DO;
                                 ID_PTR = TP_ID_PTR;
                                 ALLOCATE_NEW_ROW = TRUE;
                              END;
                           DATATYPE(ID_PTR) = ID_PTR;
                           VAR_TYPE(ID_PTR) = TYPE;
                           STRUCTYPE(ID_PTR) = RECORD;
                           OWNER(ID_PTR) = OWNER_STACK(CURRENT_LEVEL);
                           CURRENT_LEVEL = CURRENT_LEVEL + 1;
                           OWNER_STACK(CURRENT_LEVEL) = ID_PTR;
                           ARRAYS_ALLOCATED(CURRENT_LEVEL) = NULL;
                           IF VAR_TYPE(OWNER_STACK(CURRENT_LEVEL-1)) = PROC THEN
                              STACK_LIMIT(CURRENT_LEVEL),
                                 HALFWORD_DISP(CURRENT_LEVEL) = 0;
                           ELSE
                              DO;
                                 STACK_LIMIT(CURRENT_LEVEL) =
                                    STACK_LIMIT(CURRENT_LEVEL - 1);
                                 HALFWORD_DISP(CURRENT_LEVEL) =
                                    HALFWORD_DISP(CURRENT_LEVEL - 1);
                              END;
                        END;
                        /* CASE 3 -- BLOCK HEADER  */
                        IS_DECLARATION = TRUE;
                        /* CASE 4 -- BLOCK BODY */
                        DO;
                           IS_DECLARATION = FALSE;
                           IF PARSE_TREE(NODE + 2) ¬= NULL THEN
                              DO;
                                 TRIPLES(0) = OWNER_STACK(CURRENT_LEVEL);
                                 TRIPLES(1) = VALUE(TRIPLES(0));
                                 TRIPLES(2), N_TRIPLES = 6;
                                 IF CURRENT_LEVEL > 1 THEN
                                    IF MONITOR_LINK(2) > 0 THEN
                                    DO; /* DEBUG LEVEL > 0; INITIALIZE STORAGE*/
                                       I = S_LIST(OWNER_STACK(CURRENT_LEVEL));
                                       MAX = DISPLAY_BYTES+4*(CURRENT_LEVEL-1);
                                       DO WHILE I ¬= NULL;
                                          J = DISPLACEMENT(I)+STORAGE_LNGTH(I);
                                          IF J > MAX THEN MAX = J;
                                          I = S_LIST(I);
                                       END;
                                       I = STACK_LIMIT(CURRENT_LEVEL) - MAX;
                                       IF I > 0 THEN
                                          DO; /* THERE ARE LOCALS */
                                             J = NEXT_FREE_ROW;
                                             STORAGE_LNGTH(J) = I;
                                             PSEUDO_REG(J) = CURRENT_LEVEL - 1;
                                             DISPLACEMENT(J) = MAX;
                                             CALL EMIT_TRIPLE(XOR, J, J, 0);
                                          END;
                                       /* INITIALIZE FUNCTION RETURN VALUE */
                                       IF DATATYPE(OWNER_STACK(CURRENT_LEVEL))
                                          ¬= NULL THEN
                                          CALL EMIT_TRIPLE(STORE,
                                             OWNER_STACK(CURRENT_LEVEL),
                                             0 | MASK_IMMEDIATE, 0);
                                    END;
                              END;
                        END;
                        /* CASE 5 -- ARRAY TYPES  */
                        DO;
                           ALLOCATE_ARRAY_ENTRY = ALLOCATE_NEW_ROW;
                           ALLOCATE_NEW_ROW = TRUE;
                        END;
                        /* CASE 6 -- ASSIGNMENT  */
                        DO;
                           LHS = TRUE;
                           FX = FALSE;
                           LISTHEAD = NULL;
                        END;
                        /* CASE 7 -- FOR STATEMENT, PROC/FUNC CALL,
                           SUBSCRIPT LIST, SET ELEMENT */
                        DO;
                           CALL REPLACE(FX);
                           FX = FALSE;
                           LISTHEAD = NULL;
                        END;
                        /* CASE 8 -- UNARY NOT */
                        FX = ¬FX;
                        /* CASE 9 -- AND, OR */
                        DO;
                           CALL REPLACE(FX);
                           FX = (I = 41); /* TRUE IF OR, FALSE IF AND */
                           LISTHEAD = NULL;
                        END;
                        /* CASE 10 -- STATEMENT LIST */
                        DO;
                           CALL DGNS#_PUSH;
                           CALL EMIT_ADD_DECIMAL;
                        END;
                        /* CASE 11 -- SET ELEMENT LIST */
                        DO;
                           IF NP < NPMAX THEN
                              FIX_LIST(NP + 1) = NEXT_FREE_ROW;
                           VAR_TYPE(N_DECL_SYMB - 1) = TYPE;
                           STRUCTYPE(N_DECL_SYMB - 1) = SET;
                        END;
                        /* CASE 12 -- DUMMY PROC_PARAM */
                        DO;
                           TABLE_PTR = NEXT_FREE_ROW;
                           DATATYPE(TABLE_PTR), S_LIST(TABLE_PTR) = NULL;
                           OWNER(TABLE_PTR) = OWNER_STACK(CURRENT_LEVEL);
                           STORAGE_LNGTH(TABLE_PTR) = 12;
                           VAR_TYPE(TABLE_PTR) = PROC_PARAM;
                           STRUCTYPE(TABLE_PTR) = STATEMENT;
                           PSEUDO_REG(TABLE_PTR) = NULL;
                           DISPLACEMENT(TABLE_PTR) = STACK_LIMIT(CURRENT_LEVEL);
                           STACK_LIMIT(CURRENT_LEVEL) =
                              STACK_LIMIT(CURRENT_LEVEL) + 12;
                           CURRENT_LEVEL = CURRENT_LEVEL + 1;
                           OWNER_STACK(CURRENT_LEVEL) = TABLE_PTR;
                           ARRAYS_ALLOCATED(CURRENT_LEVEL) = NULL;
                           STACK_LIMIT(CURRENT_LEVEL) = 0;
                           HALFWORD_DISP(CURRENT_LEVEL) = 0;
                           CALL REPLACE(TABLE_PTR);
                        END;
                     END;  /* OF CASE ON PR_CASES  */
                     CALL LEFTSON;
                  END;
            END;
         ELSE  /*  LATER VISITS  */
            DO;
               #MP = #POS_STACK(NP);
               FATHERS_MULTIPLICITY = PARSE_TREE(NODE#STACK(NP));
               DO CASE FATHERS_PROD_NO;
               /* FOR PRODUCTION NUMBERS WHOSE MULTIPLICITY CAN EXCEED ONE,
                  THE CODE WILL INCLUDE A SEGMENT TO VISIT THE NEXT SUBTREE.
                  IN ADDITION, FOR MANY OF THE PRODUCTION NUMBERS, IT WILL
                  BE NECESSARY TO DETERMINE WHICH OF THE SIBLING NODES IS
                  BEING VISITED.  FOR THIS PURPOSE, ONE CAN INTERROGATE #MP,
                  WHOSE VALUE IS THE INDEX OF 'NODE' AMONG ITS FATHER'S SONS. */
               /* CASE 0 IS A DUMMY BECAUSE WE NUMBER PRODUCTIONS FROM 1 */
                  ;
               /* 1  <PROGRAM> ::= <ID> (<ID>)+ <BLOCK> */
                  IF #MP = 1 THEN
                     DO;
                        DATATYPE(TABLE_PTR) = NULL;
                        VAR_TYPE(TABLE_PTR) = PROC;
                        STRUCTYPE(TABLE_PTR) = STATEMENT;
                        OWNER(TABLE_PTR) = NULL;
                        VALUE(TABLE_PTR) = 0;
                        PSEUDO_REG(TABLE_PTR) = 0;
                        OWNER_STACK(1) = TABLE_PTR;
                        STACK_LIMIT(1) = CONST_POOL_SIZE + DISPLAY_BYTES;
                        ARRAYS_ALLOCATED(1) = NULL;
                        CURRENT_LEVEL = 1;
                        DISPLACEMENT(TABLE_PTR), PROC_SEQUENCE_NUMBER = 0;
                        /* THE STORAGE_LNGTH FIELD IS TO BE FILLED IN LATER
                           WITH THE LENGTH OF THE ACTIVATION RECORD FOR THE
                           <PROGRAM> BLOCK.                                 */
                     END;
                  ELSE
                     DO; /* <ID> IS A FILE NAME */
                        IF VAR_TYPE(TABLE_PTR) = UNDEFINED THEN
                           DO;
                              VAR_TYPE(TABLE_PTR) = VARIABLE;
                              STRUCTYPE(TABLE_PTR) = FILE;
                              DATATYPE(TABLE_PTR) = NULL;
                           END;
                        S_LIST(PARSE_TREE(NODE#STACK(NP) + #MP)) = TABLE_PTR;
                        /* DATATYPE, STORAGE_LNGTH ARE TO BE FILLED IN WHEN
                           THE FILE DECLARATION IS ENCOUNTERED              */
                     END;
               /* 2  <BLOCK> ::= (<LABEL DECL>) (<CONST DECL>) (<TYPE DEFN>)
                  (<VAR DECL LIST>) (<PROC DECL LIST>) <STATEMENT LIST> */
                  ;
               /* 3  <STATEMENT LIST> ::= (<STATEMENT>)+ */
                  IF #MP = FATHERS_MULTIPLICITY THEN CALL DGNS#_POP;
                  ELSE IF DGNS#_GOTO THEN
                     DO;
                        DGNS#_GOTO = FALSE;
                        CALL EMIT_ADD_DECIMAL;
                     END;
               /* 4  <LABEL DECL> ::= (<UNSIGNED INTEGER>)+ */
                  DO;
                     DATATYPE(TABLE_PTR) = NULL;
                     VAR_TYPE(TABLE_PTR) = LABLE;
                     STRUCTYPE(TABLE_PTR) = STATEMENT;
                     STORAGE_LNGTH(TABLE_PTR), OWNER(TABLE_PTR) =
                           OWNER_STACK(CURRENT_LEVEL);
                  END;
               /* 5  <CONST DECL> ::= (<ID> <CONSTANT>)+ */
                  IF #MP & 1 THEN
                     DO;   /* <ID> */
                        VAR_TYPE(TABLE_PTR) = CONSTANT;
                        OWNER(TABLE_PTR) = OWNER_STACK(CURRENT_LEVEL);
                        PSEUDO_REG(TABLE_PTR) = 0;
                     END;
                  ELSE
                     DO;   /* <CONSTANT> */
                        ID_PTR = PARSE_TREE(NODE#STACK(NP) + #MP);
                        DATATYPE(ID_PTR) = DATATYPE(TABLE_PTR);
                        IF VAR_TYPE(TABLE_PTR) = LITERAL THEN
                           /* <CONSTANT> IS A STRING */
                           STRUCTYPE(ID_PTR) = ARRAY;
                        ELSE
                           DO;
                              IF VAR_TYPE(TABLE_PTR) ¬= CONSTANT THEN
                                 CALL ERROR(
                 'ILLEGAL IDENTIFIER ON RIGHT SIDE OF CONSTANT DECLARATION', 1);
                              STRUCTYPE(ID_PTR) = STRUCTYPE(I);
                              VALUE(ID_PTR) = VALUE(TABLE_PTR);
                           END;
                        DISPLACEMENT(ID_PTR) = DISPLACEMENT(TABLE_PTR);
                        S_LIST(ID_PTR) = TABLE_PTR;
                     END;
               /* 6  <TYPE DEFN> ::= (<ID> <TYPE>)+ */
                  IF #MP & 1 THEN
                     DO;  /* <IDENTIFIER> */
                        VAR_TYPE(TABLE_PTR) = TYPE;
                        OWNER(TABLE_PTR) = OWNER_STACK(CURRENT_LEVEL);
                        TP_ID_PTR = TABLE_PTR;
                        ALLOCATE_NEW_ROW = FALSE;
                     END;
                  ELSE
                     DO;  /* <TYPE> */
                        ID_PTR = PARSE_TREE(NODE#STACK(NP) + #MP);
                        DATATYPE(ID_PTR) = DATATYPE(TABLE_PTR);
                        STRUCTYPE(ID_PTR) = STRUCTYPE(TABLE_PTR);
                        STORAGE_LNGTH(ID_PTR) = STORAGE_LNGTH(TABLE_PTR);
                     END;
               /* 7  <PROC DECL LIST> ::= <PROC DECL> (<PROC DECL LIST>) */
                  ;
               /* 8  <PROC DECL> ::= <ID> (<FORMAL PARAM>)* <BODY> */
                                  /* PROPER PROCEDURE */
               PROC_DECL:
                  IF #MP = 1 THEN
                     DO;
                        IF VAR_TYPE(TABLE_PTR) = MULTDECL THEN
                           DO;
                              VAR_TYPE(TABLE_PTR) = PROC;
                              CURRENT_LEVEL = CURRENT_LEVEL + 1;
                              OWNER_STACK(CURRENT_LEVEL) = TABLE_PTR;
                              CALL RESTORE_CURRENT_LEVEL;
                           END;
                        ELSE
                           DO;
                              IF VAR_TYPE(TABLE_PTR) = FORWARD THEN
                                 VAR_TYPE(TABLE_PTR) = MULTDECL;
                              ELSE VAR_TYPE(TABLE_PTR) = PROC;
                              DATATYPE(TABLE_PTR) = NULL;
                              STRUCTYPE(TABLE_PTR) = STATEMENT;
                              OWNER(TABLE_PTR) = OWNER_STACK(CURRENT_LEVEL);
                              PSEUDO_REG(TABLE_PTR) = CURRENT_LEVEL;
                              DISPLACEMENT(TABLE_PTR) = 0;
                              VALUE(TABLE_PTR), PROC_SEQUENCE_NUMBER =
                                 PROC_SEQUENCE_NUMBER + 1;
                              /* STORAGE_LNGTH IS TO BE FILLED IN WHEN
                                 PRODUCTION NUMBER 10 IS PROCESSED, AFTER
                                 ALL DECLARATIONS OF VARIABLES LOCAL TO
                                 THE PROCEDURE HAVE HAD STORAGE ALLOCATED. */
                              CURRENT_LEVEL = CURRENT_LEVEL + 1;
                              OWNER_STACK(CURRENT_LEVEL) = TABLE_PTR;
                              ARRAYS_ALLOCATED(CURRENT_LEVEL) = NULL;
                              STACK_LIMIT(CURRENT_LEVEL) =
                                 (CURRENT_LEVEL - 1)*4 + DISPLAY_BYTES;
                              HALFWORD_DISP(CURRENT_LEVEL) = 0;
                              IF VAR_TYPE(TABLE_PTR) = MULTDECL THEN
                                 IF FATHERS_MULTIPLICITY = 1 THEN
                                    CALL SAVE_CURRENT_LEVEL;
                           END;
                     END;  /* #MP = 1 */
                  ELSE
                     DO;  /* LINK FORMAL PARAMETER LISTS TOGETHER. */
                        LINK = PARSE_TREE(NODE#STACK(NP) + #MP);
                        DO WHILE S_LIST(LINK) ¬= NULL;
                           LINK = S_LIST(LINK);
                        END;
                        S_LIST(LINK) = TABLE_PTR;
                        CALL REPLACE(TABLE_PTR);
                        IF #MP = FATHERS_MULTIPLICITY THEN
                           DO;  /* ASSUMES NO ENTRY FOR <BODY> EXISTS IN FATHER
                                */
                              CALL ALLOCATE_ARRAY_STORAGE(CURRENT_LEVEL);
                              IF FATHERS_PROD_NO = 9 THEN
                                 DO;
                                    S_LIST(LINK) = NULL;
                                    ID_PTR = OWNER_STACK(CURRENT_LEVEL);
                                    DATATYPE(ID_PTR) = TABLE_PTR;
                                    I, STRUCTYPE(ID_PTR) =
                                       STRUCTYPE(TABLE_PTR);
                                    IF (VAR_TYPE(TABLE_PTR) ¬= TYPE) |
                                       /* ¬(I IN (.SCALAR, SUBRANGE, POINTER,
                                                   ARITHMETIC.))             */
                                       ((SHL(1, I) & "(1)10000 00000 01110")
                                          = 0) THEN
                                    CALL ERROR(
                    'FUNCTION CANNOT BE DECLARED TO HAVE A STRUCTURED TYPE', 1);
                                 END;
                              IF VAR_TYPE(OWNER_STACK(CURRENT_LEVEL)) = MULTDECL
                                 THEN CALL SAVE_CURRENT_LEVEL;
                           END;
                     END;  /* PROC_DECL */
               /* 9  <PROC DECL> ::= <ID> (<FORMAL PARAM>)* <ID> <BODY> */
                                  /* FUNCTION PROCEDURE */
                  GOTO PROC_DECL;
               /* 10  <BODY> ::= (<STATEMENT LIST>) */
                  DO;
                     CALL ALLOCATE_ARRAY_STORAGE(CURRENT_LEVEL);
                     STORAGE_LNGTH(OWNER_STACK(CURRENT_LEVEL)) =
                           STACK_LIMIT(CURRENT_LEVEL);
                     CURRENT_LEVEL = CURRENT_LEVEL - 1;
                     IF NODE ¬= NULL THEN
                        DO;
                           CALL EMIT_TRIPLE(PRETURN, NULL, NULL, 0);
                           CALL EMIT_TRIPLE(PEND, NULL, NULL, 0);
                           TRIPLES(3) = N_TRIPLES;
                           CALL WRITE_TRIPLES;
                        END;
                  END;
               /* 11  <VAR DECL LIST> ::= <VAR DECL> (<VAR DECL LIST>) */
                  ;
               /* 12  <VAR DECL> ::= (<ID>)+ <TYPE> */
                  IF #MP < FATHERS_MULTIPLICITY THEN
                     DO;
                        VAR_TYPE(TABLE_PTR) = VARIABLE;
                        OWNER(TABLE_PTR) = OWNER_STACK(CURRENT_LEVEL);
                        PSEUDO_REG(TABLE_PTR) = CURRENT_LEVEL - 1;
                     END;
                  ELSE
                     DO;
                        CALL COMPUTE_STORAGE_LENGTH(TABLE_PTR);
                        DO #TP = 2 TO FATHERS_MULTIPLICITY;
                           ID_PTR = PARSE_TREE(NODE#STACK(NP) + #TP);
                           I, STRUCTYPE(ID_PTR) = STRUCTYPE(TABLE_PTR);
                           DATATYPE(ID_PTR) = TABLE_PTR;
                           CALL ALLOCATE_STORAGE(ID_PTR);
                        END;
                     END;
               /* 13  <STATEMENT> ::= <UNSIGNED INTEGER> <STATEMENT> */
                  /* WHEN #MP = 1, NODE POINTS TO LABEL. */
                  IF #MP = 1 THEN
                     DO;
                        IF (TRIPLES(N_TRIPLES - 3) & "7F") = ADD_DECIMAL THEN
                           DO;   /* BACK UP THE BLOCK-COUNTER EMITTER */
                              IC = IC - 1;
                              BASIC_BLOCKS = BASIC_BLOCKS - 1;
                              N_TRIPLES = N_TRIPLES - 3;
                           END;
                        /* SEE IF LABEL HAS ALREADY BEEN DEFINED. */
                        IF VALUE(TABLE_PTR) > 0 THEN
                           CALL ERROR('THE SAME LABEL IS DEFINED TWICE', 1);
                        /* NOW, DEFINE LABEL. */
                        CALL EMIT_TRIPLE(BCH_TARGET, TABLE_PTR, NULL, 0);
                        VALUE(TABLE_PTR) = IC;
                        DISPLACEMENT(TABLE_PTR) = N_TRIPLES - 3;
                        CALL EMIT_ADD_DECIMAL;
                        /* POP THE LABEL FROM THE OPERAND STACK */
                        #OP = #OP - 1;
                     END;
               /* 14  <STATEMENT> ::= <VARIABLE> <EXPRESSION> */
                                  /* ASSIGNMENT */
                  DO;
                     CALL REPLACE(#TP);
                     IF #MP = 1 THEN LHS = FALSE;
                     ELSE
                        DO;
                           IF #TP = BOOLPTR THEN
                              IF IS_CONDITION(OPERAND#STK(#OP)) THEN
                                 CALL COND_TO_REGISTER;
                           CALL COERCE_ASSIGNMENT(
                              PARSE_TREE(NODE#STACK(NP) + #MP), #TP);
                           I = STRUCTYPE(#TP);
                           /* IF STRUCTYPE(#TP) IN (.SCALAR, SUBRANGE, POINTER,
                              ARRAY, PACKED_ARRAY, RECORD, PACKED_RECORD,
                              ARITHMETIC.) THEN   */
                           IF (SHL(1, I) & "(1)10000 11001 11110") ¬= 0 THEN
                              CALL EMIT_TRIPLE(STORE, OPERAND#STK(#OP - 1),
                                               OPERAND#STK(#OP), 0);
                           ELSE IF (I = SET) | (I = PACKED_SET) THEN
                              DO;
                                 IF OPERAND#STK(#OP) = EMPTYSETPTR THEN
                                    DO;
                                       J = OPERAND#STK(#OP - 1);
                                       CALL EMIT_TRIPLE(XOR, J, J, 0);
                                    END;
                                 ELSE CALL EMIT_TRIPLE(MOVE, OPERAND#STK(#OP-1),
                                    OPERAND#STK(#OP), 0);
                              END;
                           ELSE CALL ERROR('ILLEGAL ASSIGNMENT', 1);
                           #OP = #OP - 2;
                        END;
                  END;
               /* 15  <STATEMENT> ::= <ID> (<EXPRESSION>)* */
                                  /* PROCEDURE STATEMENT */
                  DO;
                     CALL PROCFUNC(TRUE);
                     DGNS#_TOP, DGNS#_GOTO, DGNS#_STACK(DGNS#_DEPTH) = TRUE;
                  END;
               /* 16  <STATEMENT> ::= <STATEMENT LIST> */
                                  /* COMPOUND GROUP */
                  ;
               /* 17  <STATEMENT> ::= <EXPRESSION> <STATEMENT> (<STATEMENT>) */
                                  /* CONDITIONAL STATEMENT */
                  IF #MP = 1 THEN
                     DO;
                        IF ¬COMPTYPES(#TP, BOOLPTR) THEN CALL ERROR(BOOLTYPE,1);
                        IF ¬IS_CONDITION(OPERAND#STK(#OP)) THEN
                           DO;
                              CALL EMIT_CONDITIONAL_BRANCH(FX);
                              LISTHEAD = N_TRIPLES - 3;
                           END;
                        IF FX THEN
                           DO; /* EMIT AN UNCONDITIONAL BRANCH AROUND
                                  THE 'THEN' CLAUSE. */
                              CALL EMIT_TRIPLE(BCH, NULL, NULL, 0);
                              OPERAND#STK(#OP) = N_TRIPLES - 3;
                              CALL FIXUP(LISTHEAD, N_TRIPLES);
                              CALL EMIT_TRIPLE(BCH_TARGET, NULL, NULL, 0);
                           END;
                        ELSE OPERAND#STK(#OP) = LISTHEAD;
                        LISTHEAD = NULL;
                        CALL DGNS#_PUSH;
                        CALL EMIT_ADD_DECIMAL;
                     END;
                  ELSE
                     DO;
                        LISTHEAD = OPERAND#STK(#OP);
                        IF #MP < FATHERS_MULTIPLICITY THEN
                           DO; /* BRANCH AROUND 'ELSE' CLAUSE */
                              CALL EMIT_TRIPLE(BCH, NULL, NULL, 0);
                              OPERAND#STK(#OP) = N_TRIPLES - 3;
                           END;
                        ELSE #OP = #OP - 1;
                        CALL EMIT_TRIPLE(BCH_TARGET, NULL, NULL, 0);
                        CALL FIXUP(LISTHEAD, N_TRIPLES - 3);
                        LISTHEAD = NULL;
                        IF #MP < FATHERS_MULTIPLICITY THEN
                           CALL EMIT_ADD_DECIMAL;
                        ELSE CALL DGNS#_POP;
                     END;
               /* 18  <STATEMENT> ::= <EXPRESSION> (<CASE INSTANCE>)+ */
                                  /* CASE STATEMENT */
                  IF #MP = 1 THEN
                     DO;
                        FIX_LIST(NP) = NULL;
                        CALL DGNS#_PUSH;
                        MIN = MAXINT;
                        MAX = - MIN - 1;
                        IF #TP = BOOLPTR THEN
                           IF IS_CONDITION(OPERAND#STK(#OP)) THEN
                              CALL COND_TO_REGISTER;
                        CALL REPLACE(#TP);
                        DO I = 3 TO FATHERS_MULTIPLICITY + 1;
                           CASE_INSTANCE_PTR = PARSE_TREE(NODE#STACK(NP) + I);
                           DO J = 2 TO MULTIPLICITY(CASE_INSTANCE_PTR);
                              CASE_LABEL_PTR = PARSE_TREE(CASE_INSTANCE_PTR+J);
                              IF MULTIPLICITY(CASE_LABEL_PTR) ¬= 0 THEN
                                 /* UNARY MINUS */
                                 CASE_LABEL_VALUE = - VALUE(PARSE_TREE(
                                    PARSE_TREE(CASE_LABEL_PTR + 2) + 1));
                              ELSE CASE_LABEL_VALUE =
                                 VALUE(PARSE_TREE(CASE_LABEL_PTR + 1));
                              IF CASE_LABEL_VALUE < MIN THEN
                                 MIN = CASE_LABEL_VALUE;
                              IF CASE_LABEL_VALUE > MAX THEN
                                 MAX = CASE_LABEL_VALUE;
                           END;
                        END;
                        IF (OPERAND#STK(#OP) & MASK_TRIPLE) = 0 THEN
                           DO;   /* LOAD THE CASE SELECTOR */
                              CALL EMIT_TRIPLE(LOAD, OPERAND#STK(#OP), NULL, 3);
                              OPERAND#STK(#OP) = (N_TRIPLES - 3) | MASK_TRIPLE;
                           END;
                        IF STRUCTYPE(#TP) = SUBRANGE THEN
                           DO;
                              IF VALUE(S_LIST(#TP)) ¬= MIN THEN
                                 DO;
                                    CALL EMIT_TRIPLE(ADD, OPERAND#STK(#OP),
                                       FINDCONST(VALUE(S_LIST(#TP)) - MIN), 3);
                                    OPERAND#STK(#OP) =
                                       (N_TRIPLES - 3) | MASK_TRIPLE;
                                 END;
                              IF VALUE(S_LIST(#TP)) < MIN THEN
                                 DO;
                                    CALL EMIT_TRIPLE(LESS, OPERAND#STK(#OP) |
                                       MASK_TEMP, 0 | MASK_IMMEDIATE, 0);
                                    CALL EMIT_TRIPLE(BNZ, FIX_LIST(NP),
                                       (N_TRIPLES - 3) | MASK_TRIPLE, 0);
                                    FIX_LIST(NP) = N_TRIPLES - 3;
                                 END;
                              IF VALUE(#TP) > MAX THEN
                                 DO;
                                    CALL EMIT_TRIPLE(GREATER, OPERAND#STK(#OP) |
                                       MASK_TEMP, FINDCONST(MAX - MIN), 0);
                                    CALL EMIT_TRIPLE(BNZ, FIX_LIST(NP),
                                       (N_TRIPLES - 3) | MASK_TRIPLE, 0);
                                    FIX_LIST(NP) = N_TRIPLES - 3;
                                 END;
                           END;
                        ELSE IF (STRUCTYPE(#TP) = SCALAR)
                           | COMPTYPES(#TP, INTPTR) THEN
                           DO;
                              IF MIN ¬= 0 THEN
                                 DO;
                                    CALL EMIT_TRIPLE(ADD, OPERAND#STK(#OP),
                                       FINDCONST(-MIN), 3);
                                    OPERAND#STK(#OP) =
                                       (N_TRIPLES - 3) | MASK_TRIPLE;
                                    CALL EMIT_TRIPLE(LESS, OPERAND#STK(#OP) |
                                       MASK_TEMP, 0 | MASK_IMMEDIATE, 0);
                                    CALL EMIT_TRIPLE(BNZ, FIX_LIST(NP),
                                       (N_TRIPLES - 3) | MASK_TRIPLE, 0);
                                    FIX_LIST(NP) = N_TRIPLES - 3;
                                 END;
                              IF (STORAGE_LNGTH(#TP) - 1 > MAX)
                                 | COMPTYPES(#TP, INTPTR) THEN
                                 DO;
                                    CALL EMIT_TRIPLE(GREATER, OPERAND#STK(#OP)
                                       | MASK_TEMP, FINDCONST(MAX - MIN), 0);
                                    CALL EMIT_TRIPLE(BNZ, FIX_LIST(NP),
                                       (N_TRIPLES - 3) | MASK_TRIPLE, 0);
                                    FIX_LIST(NP) = N_TRIPLES - 3;
                                 END;
                           END;
                        ELSE CALL ERROR('ILLEGAL TYPE OF CASE SELECTOR', 1);
                        TABLE_PTR = NEXT_FREE_ROW;
                        DATATYPE(TABLE_PTR) = DATATYPE(#TP);
                        STRUCTYPE(TABLE_PTR) = SUBRANGE;
                        VAR_TYPE(TABLE_PTR) = TYPE;
                        VALUE(TABLE_PTR) = MAX;
                        STORAGE_LNGTH(TABLE_PTR) = MAX - MIN + 1;
                        CALL EMIT_TRIPLE(CASE_JUMP, OPERAND#STK(#OP),
                           TABLE_PTR, 0);
                        OPERAND#STK(#OP) = (N_TRIPLES - 3);
                        DO I = MIN TO MAX;
                           CALL EMIT_TRIPLE(BCH, NULL, NULL, 0);
                        END;
                     END;   /* #MP = 1 */
                  ELSE IF #MP < FATHERS_MULTIPLICITY THEN
                     DO;
                        CALL EMIT_TRIPLE(BCH, FIX_LIST(NP), NULL, 0);
                        FIX_LIST(NP) = N_TRIPLES - 3;
                     END;
                  ELSE /* #MP = FATHERS_MULTIPLICITY */
                     DO;
                        LISTHEAD = NULL;
                        I = OPERAND#STK(#OP);
                        TABLE_PTR = TRIPLES(I + 2);
                        TRIPLES(I + 2) = FINDCONST(STORAGE_LNGTH(TABLE_PTR));
                        J = I + 3*STORAGE_LNGTH(TABLE_PTR);
                        DO WHILE I < J;
                           I = I + 3;
                           IF TRIPLES(I + 1) = NULL THEN /* EMPTY CASE */
                              DO;
                                 TRIPLES(I + 1) = LISTHEAD;
                                 LISTHEAD = I;
                              END;
                        END;
                        IF LISTHEAD ¬= NULL THEN
                           DO;
                              CALL EMIT_TRIPLE(CASE_TARGET, NULL, NULL, 0);
                              CALL FIXUP(LISTHEAD, N_TRIPLES - 3);
                              LISTHEAD = NULL;
                           END;
                        CALL EMIT_TRIPLE(BCH_TARGET, NULL, NULL, 0);
                        CALL FIXUP(FIX_LIST(NP), N_TRIPLES - 3);
                        IF TABLE_PTR + 1 = N_DECL_SYMB THEN
                           /* RELEASE THE SYMBOL TABLE ENTRY */
                           N_DECL_SYMB = N_DECL_SYMB - 1;
                        #OP = #OP - 1;
                        CALL DGNS#_POP;
                     END;
               /* 19  <STATEMENT> ::= <EXPRESSION> <STATEMENT> */
                                  /* WHILE STATEMENT */
                  IF #MP = 1 THEN
                     DO;
                        CALL DGNS#_PUSH;
                        IF ¬COMPTYPES(#TP, BOOLPTR) THEN CALL ERROR(BOOLTYPE,1);
                        IF ¬IS_CONDITION(OPERAND#STK(#OP)) THEN
                           DO;
                              CALL EMIT_CONDITIONAL_BRANCH(FX);
                              LISTHEAD = N_TRIPLES - 3;
                           END;
                        IF FX THEN
                           DO; /* EMIT AN UNCONDITIONAL BRANCH
                                  AROUND THE WHILE STATEMENT */
                              CALL EMIT_TRIPLE(BCH, NULL, NULL, 0);
                              OPERAND#STK(#OP) = N_TRIPLES - 3;
                              CALL FIXUP(LISTHEAD, N_TRIPLES);
                              CALL EMIT_TRIPLE(BCH_TARGET, NULL, NULL, 0);
                           END;
                        ELSE OPERAND#STK(#OP) = LISTHEAD;
                        LISTHEAD = NULL;
                        CALL EMIT_ADD_DECIMAL;
                     END;
                  ELSE
                     DO;
                        CALL EMIT_TRIPLE(BCH, FIX_LIST(NP), NULL, 0);
                        CALL FIXUP(OPERAND#STK(#OP), N_TRIPLES);
                        CALL EMIT_TRIPLE(BCH_TARGET, NULL, NULL, 0);
                        #OP = #OP - 1;
                        CALL DGNS#_POP;
                     END;
               /* 20  <STATEMENT> ::= <STATEMENT LIST> <EXPRESSION> */
                                  /* UNTIL STATEMENT */
                  IF #MP = 1 THEN FX = FALSE;
                  ELSE
                     DO;
                        IF ¬COMPTYPES(#TP, BOOLPTR) THEN CALL ERROR(BOOLTYPE,1);
                        IF ¬IS_CONDITION(OPERAND#STK(#OP)) THEN
                           DO;
                              CALL EMIT_CONDITIONAL_BRANCH(FX);
                              LISTHEAD = N_TRIPLES - 3;
                           END;
                        IF FX THEN
                           DO;
                              CALL EMIT_TRIPLE(BCH, FIX_LIST(NP), NULL, 0);
                              CALL FIXUP(LISTHEAD, N_TRIPLES);
                              CALL EMIT_TRIPLE(BCH_TARGET, NULL, NULL, 0);
                           END;
                        ELSE CALL FIXUP(LISTHEAD, FIX_LIST(NP));
                        LISTHEAD = NULL;
                        #OP = #OP - 1;
                     END;
               /* 21  <STATEMENT> ::= <ID> <EXPRESSION> <EXPRESSION> <STATEMENT>
               */
                                  /* FOR STATEMENT -- UPTO */
               FORSTAT:
                  IF #MP = 1 THEN
                     DO;
                        CALL REPLACE(#TP);
                        IF VAR_TYPE(TABLE_PTR) = VAR_PARAM THEN
                           CALL ERROR('CONTROL VARIABLE MUST NOT BE FORMAL', 1);
                        ELSE IF VAR_TYPE(TABLE_PTR) ¬= VARIABLE THEN
                   CALL ERROR('ILLEGAL OR UNDECLARED LOOP CONTROL VARIABLE', 1);
                        I = STRUCTYPE(#TP);
                        IF ((SHL(1, I) & "(1)10000 00000 00110") = 0)
                           /* ¬(I IN (.SCALAR, SUBRANGE, ARITHMETIC.)) */
                           | COMPTYPES(#TP, REALPTR) THEN
                         CALL ERROR('ILLEGAL TYPE OF LOOP CONTROL VARIABLE', 1);
                     END;
                  ELSE IF #MP < 4 THEN
                     DO;
                        CALL REPLACE(#TP);
                        IF COMPTYPES(#TP, BOOLPTR) THEN
                           IF IS_CONDITION(OPERAND#STK(#OP)) THEN
                              CALL COND_TO_REGISTER;
                        CALL COERCE_ASSIGNMENT(PARSE_TREE(NODE#STACK(NP) + 2),
                           #TP);
                        TABLE_PTR = OPERAND#STK(#OP);
                        IF (TABLE_PTR & "C000") = MASK_SYMBOL THEN
                           DO;
                              IF VAR_TYPE(TABLE_PTR) = CONSTANT THEN
                                 DO;
                                    IF #MP = 2 THEN
                                       DO;
                                          BOUND1_IS_CONST = TRUE;
                                          BOUND1_VALUE = VALUE(TABLE_PTR);
                                       END;
                                    ELSE   /* #MP = 3 */
                                       DO;
                                          BOUND2_IS_CONST = TRUE;
                                          BOUND2_VALUE = VALUE(TABLE_PTR);
                                       END;
                                 END;
                              ELSE IF #MP = 2 THEN BOUND1_IS_CONST = FALSE;
                              ELSE /* #MP = 3 */ BOUND2_IS_CONST = FALSE;
                           END;
                        ELSE IF (TABLE_PTR & "C000") = MASK_IMMEDIATE THEN
                           DO;
                              IF #MP = 2 THEN
                                 DO;
                                    BOUND1_IS_CONST = TRUE;
                                    BOUND1_VALUE = TABLE_PTR & "3FFF";
                                 END;
                              ELSE   /* #MP = 3 */
                                 DO;
                                    BOUND2_IS_CONST = TRUE;
                                    BOUND2_VALUE = TABLE_PTR & "3FFF";
                                 END;
                           END;
                        ELSE IF #MP = 2 THEN BOUND1_IS_CONST = FALSE;
                        ELSE /* #MP = 3 */ BOUND2_IS_CONST = FALSE;
                        IF #MP = 3 THEN
                           DO;
                              CALL EMIT_TRIPLE(TEMP, OPERAND#STK(#OP), NULL, 3);
                              OPERAND#STK(#OP) = (N_TRIPLES - 3) | MASK_TEMP;
                              IF FATHERS_PROD_NO = 21 THEN /* UPTO */
                                 DO;
                                    IF BOUND1_IS_CONST THEN
                                       DO;
                                          IF BOUND2_IS_CONST THEN
                                             CALL EMIT_TRIPLE(TEMP,
                                                FINDCONST(BOUND2_VALUE + 1
                                                   - BOUND1_VALUE), NULL, 3);
                                          ELSE IF BOUND1_VALUE = 1 THEN
                                             CALL EMIT_TRIPLE(TEMP,
                                                OPERAND#STK(#OP), NULL, 3);
                                          ELSE
                                             DO;
                                                CALL EMIT_TRIPLE(SUBTRACT,
                                                   OPERAND#STK(#OP),
                                                   FINDCONST(BOUND1_VALUE-1),3);
                                                CALL EMIT_TRIPLE(TEMP,
                                                   (N_TRIPLES-3) | MASK_TRIPLE,
                                                   NULL, 3);
                                             END;
                                       END;
                                    ELSE   /* ¬BOUND1_IS_CONST */
                                       DO;
                                          IF BOUND2_IS_CONST THEN
                                             CALL EMIT_TRIPLE(SUBTRACT,
                                                FINDCONST(BOUND2_VALUE + 1),
                                                OPERAND#STK(#OP - 1), 3);
                                          ELSE
                                             DO;   /* WORST CASE */
                                                CALL EMIT_TRIPLE(SUBTRACT,
                                                   OPERAND#STK(#OP),
                                                   OPERAND#STK(#OP - 1), 3);
                                                CALL EMIT_TRIPLE(ADD,
                                                   (N_TRIPLES-3) | MASK_TRIPLE,
                                                   1 | MASK_IMMEDIATE, 3);
                                             END;
                                          CALL EMIT_TRIPLE(TEMP,
                                             (N_TRIPLES - 3) | MASK_TRIPLE,
                                             NULL, 3);
                                       END;
                                 END;
                              ELSE   /* DOWNTO */
                                 DO;
                                    IF BOUND1_IS_CONST THEN
                                       DO;
                                          IF BOUND2_IS_CONST THEN
                                             CALL EMIT_TRIPLE(TEMP,
                                                FINDCONST(BOUND1_VALUE + 1
                                                   - BOUND2_VALUE), NULL, 3);
                                          ELSE
                                             DO;
                                                CALL EMIT_TRIPLE(SUBTRACT,
                                                   FINDCONST(BOUND1_VALUE + 1),
                                                   OPERAND#STK(#OP), 3);
                                                CALL EMIT_TRIPLE(TEMP,
                                                   (N_TRIPLES-3) | MASK_TRIPLE,
                                                   NULL, 3);
                                             END;
                                       END;
                                    ELSE   /* ¬BOUND1_IS_CONST */
                                       DO;
                                          IF ¬BOUND2_IS_CONST THEN
                                             DO;   /* WORST CASE */
                                                CALL EMIT_TRIPLE(SUBTRACT,
                                                   OPERAND#STK(#OP - 1),
                                                   OPERAND#STK(#OP), 3);
                                                CALL EMIT_TRIPLE(ADD,
                                                   (N_TRIPLES-3) | MASK_TRIPLE,
                                                   1 | MASK_IMMEDIATE, 3);
                                                CALL EMIT_TRIPLE(TEMP,
                                                   (N_TRIPLES-3) | MASK_TRIPLE,
                                                   NULL, 3);
                                             END;
                                          ELSE IF BOUND2_VALUE = 1 THEN
                                             CALL EMIT_TRIPLE(TEMP,
                                                OPERAND#STK(#OP - 1), NULL, 3);
                                          ELSE
                                             DO;
                                                CALL EMIT_TRIPLE(SUBTRACT,
                                                   OPERAND#STK(#OP - 1),
                                                   FINDCONST(BOUND2_VALUE-1),3);
                                                CALL EMIT_TRIPLE(TEMP,
                                                   (N_TRIPLES-3) | MASK_TRIPLE,
                                                   NULL, 3);
                                             END;
                                       END;
                                 END;
                              OPERAND#STK(#OP - 1) = (N_TRIPLES-3) | MASK_TEMP;
                              CALL EMIT_TRIPLE(BCH_TARGET, NULL, NULL, 0);
                              FIX_LIST(NP) = N_TRIPLES;
                              CALL EMIT_TRIPLE(BCT, NULL, OPERAND#STK(#OP-1),0);
                              IF FATHERS_PROD_NO = 21 THEN I = SUBTRACT;
                              ELSE I = ADD;
                              CALL EMIT_TRIPLE(I, OPERAND#STK(#OP),
                                 OPERAND#STK(#OP - 1), 3);
                              CALL EMIT_TRIPLE(STORE, OPERAND#STK(#OP - 2),
                                 (N_TRIPLES - 3) | MASK_TRIPLE, 0);
                              CALL DGNS#_PUSH;
                              CALL EMIT_ADD_DECIMAL;
                           END;
                     END;
                  ELSE /* #MP = 4 */
                     DO;
                        CALL EMIT_TRIPLE(BCH, (FIX_LIST(NP) - 3) | MASK_TRIPLE,
                           NULL, 0);
                        CALL FIXUP(FIX_LIST(NP), N_TRIPLES);
                        CALL EMIT_TRIPLE(BCH_TARGET, NULL, NULL, 0);
                        CALL EMIT_TRIPLE(TPOP, OPERAND#STK(#OP - 1) & "BFFF",
                           NULL, 0);
                        CALL EMIT_TRIPLE(TPOP, OPERAND#STK(#OP) & "BFFF",
                           NULL, 0);
                        #OP = #OP - 3;
                        CALL DGNS#_POP;
                     END;
               /* 22  <STATEMENT> ::= <ID> <EXPRESSION> <EXPRESSION> <STATEMENT>
               */
                                  /* FOR STATEMENT - DOWNTO */
                  GOTO FORSTAT;
               /* 23  <STATEMENT> ::= (<VARIABLE>)+ <STATEMENT> */
                                  /* WITH STATEMENT */
                  IF #MP < FATHERS_MULTIPLICITY THEN
                     DO;
                        CALL REPLACE(#TP);
                        WITH_PTR = WITH_PTR + 1;
                        IF WITH_PTR > WITH_LENGTH THEN
                           DO;
                              CALL ERROR('WITH VARIABLES NESTED TOO DEEPLY', 1);
                              WITH_PTR = WITH_PTR - 1;
                              #OP = #OP - 1;
                           END;
                        ELSE
                           DO;
                              IF (OPERAND#STK(#OP) & "C000") = MASK_SYMBOL THEN
                                 DO;
                                    ID_PTR = OPERAND#STK(#OP);
                                    IF VAR_TYPE(ID_PTR) ¬= VARIABLE THEN
                                       CALL ERROR('ILLEGAL "WITH" VARIABLE: '
                                          || IDENTITY(ID_PTR), 1);
                                  END;
                              CALL EMIT_TRIPLE(LOAD_ADDR, OPERAND#STK(#OP),
                                 NULL, 3);
                              WITH_VARIABLE(WITH_PTR) =
                                 (N_TRIPLES - 3) | MASK_TEMP;
                              WITH_DATATYPE(WITH_PTR) = #TP;
                              #OP = #OP - 1;
                           END;
                        IF #MP = FATHERS_MULTIPLICITY - 1 THEN
                           DO;
                              CALL DGNS#_PUSH;
                              CALL EMIT_ADD_DECIMAL;
                           END;
                     END;
                  ELSE
                     DO I = 1 TO FATHERS_MULTIPLICITY - 1;
                        CALL EMIT_TRIPLE(TPOP, WITH_VARIABLE(WITH_PTR) & "BFFF",
                                         NULL, 0);
                        WITH_PTR = WITH_PTR - 1;
                        IF I = FATHERS_MULTIPLICITY - 1 THEN
                           CALL DGNS#_POP;
                     END;
               /* 24  <STATEMENT> ::= <UNSIGNED INTEGER> */
                                  /* GOTO STATEMENT */
                  DO;
                     CALL EMIT_TRIPLE(BCH, TABLE_PTR,
                        FINDCONST(VALUE(OWNER(TABLE_PTR))), 0);
                     #OP = #OP - 1;
                     DGNS#_TOP, DGNS#_GOTO, DGNS#_STACK(DGNS#_DEPTH) = TRUE;
                  END;
               /* 25  <FORMAL PARAM> ::= (<ID>)+ <ID> */
                                  /* FORMAL VAR PARAMETER */
            FORMAL:
               IF #MP < FATHERS_MULTIPLICITY THEN DO;
                  OWNER(TABLE_PTR) = OWNER_STACK(CURRENT_LEVEL);
                  PSEUDO_REG(TABLE_PTR) = CURRENT_LEVEL - 1;
                  IF #MP > 1 THEN
                     S_LIST(PARSE_TREE(NODE#STACK(NP) + #MP)) = TABLE_PTR;
                  IF FATHERS_PROD_NO = 25 THEN
                     DO;   /* VAR PARAMETER */
                        VAR_TYPE(TABLE_PTR) = VAR_PARAM;
                        STORAGE_LNGTH (TABLE_PTR) = 4;
                        DISPLACEMENT(TABLE_PTR) = STACK_LIMIT(CURRENT_LEVEL);
                        STACK_LIMIT(CURRENT_LEVEL) =
                              STACK_LIMIT(CURRENT_LEVEL) + 4;
                        END;
                  ELSE /* VALUE PARAM */ VAR_TYPE(TABLE_PTR) = VARIABLE;
                  END;
               ELSE DO;   /* TYPE IDENTIFIER  */
                  IF VAR_TYPE(TABLE_PTR) ¬= TYPE THEN
                     CALL ERROR(IDENTITY(TABLE_PTR) || ' IS NOT A TYPE', 1);
                  I, ID_PTR = PARSE_TREE(NODE#STACK(NP) + 2);
                  DO WHILE ID_PTR ¬= NULL;
                     DATATYPE(ID_PTR) = TABLE_PTR;
                     STRUCTYPE(ID_PTR) = STRUCTYPE(TABLE_PTR);
                     IF FATHERS_PROD_NO = 26 THEN DO;
                        CALL COMPUTE_STORAGE_LENGTH(TABLE_PTR);
                        CALL ALLOCATE_STORAGE(ID_PTR);
                        END;
                     ID_PTR = S_LIST(ID_PTR);
                     END;
                  TABLE_PTR = I;
                  END;
               /* 26  <FORMAL PARAM> ::= (<ID>)+ <ID> */
                                  /* FORMAL VALUE PARAMETER */
                  GOTO FORMAL;
               /* 27  <FORMAL PARAM> ::= (<ID>)+ (<PARAM TYPES>)+ (<ID>) */
                                  /* FORMAL PROCEDURE PARAMETER */
                  IF IS_LEAF & (#MP < FATHERS_MULTIPLICITY) THEN
                     DO;
                        DATATYPE(TABLE_PTR), S_LIST(TABLE_PTR) = NULL;
                        VAR_TYPE(TABLE_PTR) = PROC_PARAM;
                        STRUCTYPE(TABLE_PTR) = STATEMENT;
                        OWNER(TABLE_PTR) = OWNER_STACK(CURRENT_LEVEL);
                        STORAGE_LNGTH(TABLE_PTR) = 12;
                        PSEUDO_REG(TABLE_PTR) = CURRENT_LEVEL - 1;
                        DISPLACEMENT(TABLE_PTR) = STACK_LIMIT(CURRENT_LEVEL);
                        STACK_LIMIT(CURRENT_LEVEL) =
                           STACK_LIMIT(CURRENT_LEVEL) + 12;
                        IF #MP > 1 THEN
                           S_LIST(PARSE_TREE(NODE#STACK(NP) + #MP)) = TABLE_PTR;
                        CALL REPLACE(TABLE_PTR);
                        FIRST_PARAM_TYPES =
                           (MULTIPLICITY(PARSE_TREE(NODE#STACK(NP)+#MP+2)) > 0);
                        IF FIRST_PARAM_TYPES THEN
                           DO; /* INCREMENT CURRENT_LEVEL */
                              CURRENT_LEVEL = CURRENT_LEVEL + 1;
                              OWNER_STACK(CURRENT_LEVEL) =
                                 PARSE_TREE(NODE#STACK(NP) + 2);
                              ARRAYS_ALLOCATED(CURRENT_LEVEL) = NULL;
                              STACK_LIMIT(CURRENT_LEVEL) = 0;
                              HALFWORD_DISP(CURRENT_LEVEL) = 0;
                           END;
                     END;
                  ELSE
                     DO;
                        CALL REPLACE(TABLE_PTR);
                        ID_PTR = OWNER_STACK(CURRENT_LEVEL);
                        IF FIRST_PARAM_TYPES THEN
                           DO;
                              FIRST_PARAM_TYPES = FALSE;
                              LINK = ID_PTR;
                              DO WHILE LINK ¬= NULL;
                                 VALUE(LINK) = TABLE_PTR;
                                 LINK = S_LIST(LINK);
                              END;
                           END;
                        ELSE
                           DO;
                              LINK = PARSE_TREE(NODE#STACK(NP) + #MP);
                              IF LINK ¬= NULL THEN
                                 DO;
                                    DO WHILE S_LIST(LINK) ¬= NULL;
                                       LINK = S_LIST(LINK);
                                    END;
                                    S_LIST(LINK) = TABLE_PTR;
                                 END;
                           END;
                        IF #MP = FATHERS_MULTIPLICITY THEN
                           DO;
                              IF IS_LEAF THEN
                                 DO; /* FUNCTION-TYPE PARAMETERS */
                                    IF LINK ¬= NULL THEN S_LIST(LINK) = NULL;
                                    LINK = ID_PTR;
                                    DO WHILE LINK ¬= NULL;
                                       DATATYPE(LINK) = TABLE_PTR;
                                       STRUCTYPE(LINK) = STRUCTYPE(TABLE_PTR);
                                       LINK = S_LIST(LINK);
                                    END;
                                    IF VAR_TYPE(TABLE_PTR) ¬= TYPE THEN
                                       CALL ERROR(IDENTITY(TABLE_PTR)
                                                  || ' IS NOT A TYPE', 1);
                                 END;
                              CALL ALLOCATE_ARRAY_STORAGE(CURRENT_LEVEL);
                              CURRENT_LEVEL = CURRENT_LEVEL - 1;
                              TABLE_PTR = ID_PTR;
                           END;
                     END;
               /* 28  <CASE INSTANCE> ::= (<CONSTANT>)+ <STATEMENT> */
                  IF #MP < FATHERS_MULTIPLICITY THEN
                     DO;
                        IF #MP = 1 THEN
                           DO;
                              CALL EMIT_TRIPLE(CASE_TARGET, NULL, NULL, 0);
                              CASE_PTR = N_TRIPLES - 3;
                              CALL EMIT_ADD_DECIMAL;
                           END;
                        #OP = #OP - 1;
                        ID_PTR = TRIPLES(OPERAND#STK(#OP) + 2);
                        IF ¬COMPTYPES(#TP, DATATYPE(ID_PTR)) THEN
                           CALL ERROR(
                             'LABEL TYPE INCOMPATIBLE WITH SELECTING EXPRESSION'
                              , 1);
                        IF (TABLE_PTR & "C000") = MASK_IMMEDIATE THEN
                           CASE_LABEL_VALUE = TABLE_PTR & "3FFF";
                        ELSE CASE_LABEL_VALUE = VALUE(TABLE_PTR);
                        I = OPERAND#STK(#OP) + 3*(CASE_LABEL_VALUE +
                           STORAGE_LNGTH(ID_PTR) - VALUE(ID_PTR));
                        /* I POINTS TO THE "BCH" TRIPLE IN THE JUMP TABLE
                           WHICH CORRESPONDS TO CASE_LABEL_VALUE   */
                        IF TRIPLES(I + 1) = NULL THEN CALL FIXUP(I, CASE_PTR);
                        ELSE CALL ERROR('MULTIDEFINED CASE LABEL', 1);
                     END;
               /* 29  <EXPRESSION> ::= <EXPRESSION> */
                                  /* UNARY '+' OPERATOR */
                  ;
               /* 30  <EXPRESSION> ::= <EXPRESSION> */
                                  /* UNARY '-' OPERATOR */
                  DO;
                     CALL REPLACE(#TP);
                     IF STRUCTYPE(#TP) = SUBRANGE THEN
                        DO;
                           CALL COERCE_ASSIGNMENT(DATATYPE(#TP), #TP);
                           #TP = DATATYPE(#TP);
                        END;
                     IF COMPTYPES(#TP, INTPTR) THEN
                        DO;
                           TABLE_PTR = OPERAND#STK(#OP);
                           IF (TABLE_PTR & "C000") = MASK_IMMEDIATE THEN
                              OPERAND#STK(#OP) = FINDCONST(-(TABLE_PTR&"3FFF"));
                           ELSE IF ((TABLE_PTR & "C000") = MASK_SYMBOL)
                                   & (VAR_TYPE(TABLE_PTR) = CONSTANT) THEN
                              OPERAND#STK(#OP) = FINDCONST(-VALUE(TABLE_PTR));
                           ELSE
                              DO;
                                 CALL EMIT_TRIPLE(NEGATE, TABLE_PTR, NULL, 3);
                                 OPERAND#STK(#OP) =
                                    (N_TRIPLES - 3) | MASK_TRIPLE;
                              END;
                        END;
                     ELSE IF COMPTYPES(#TP, REALPTR) THEN
                        DO;
                           TABLE_PTR = OPERAND#STK(#OP);
                           IF ((TABLE_PTR & "C000") = MASK_SYMBOL)
                              & (VAR_TYPE(TABLE_PTR) = CONSTANT) THEN
                              DO;
                                 I = VALUE(TABLE_PTR);
                                 IF I > 0 THEN
                                    OPERAND#STK(#OP) = FINDREAL(I | "80000000");
                                 ELSE OPERAND#STK(#OP) =
                                    FINDREAL(I & "7FFFFFFF");
                              END;
                           ELSE
                              DO;
                                 CALL EMIT_TRIPLE(NEGATEFLT, OPERAND#STK(#OP),
                                    NULL, 3);
                                 OPERAND#STK(#OP) =
                                    (N_TRIPLES - 3) | MASK_TRIPLE;
                              END;
                        END;
                     ELSE CALL ERROR('ILLEGAL UNARY "-" OPERATOR', 1);
                  END;
               /* 31  <EXPRESSION> ::= <EXPRESSION> */
                                  /* UNARY 'NOT' OPERATOR */
                  DO;
                     IF ¬COMPTYPES(#TP, BOOLPTR) THEN
                        DO;
                           CALL ERROR(BOOLTYPE, 1);
                           #TP = BOOLPTR;
                        END;
                     IF IS_NEGATION(OPERAND#STK(#OP)) THEN
                        DO;
                           OPERAND#STK(#OP) = TRIPLES(N_TRIPLES - 2);
                           N_TRIPLES = N_TRIPLES - 3;
                           IC = IC - 1;
                        END;
                     ELSE IF IS_CONDITION(OPERAND#STK(#OP)) THEN
                        DO;
                           IF LISTHEAD ¬= NULL THEN
                              DO; /* REVERSE THE PARITY OF LISTHEAD */
                                 IF (LISTHEAD & "8000") ¬= 0 THEN
                                    LISTHEAD = LISTHEAD & "7FFF";
                                 ELSE LISTHEAD = LISTHEAD | "8000";
                              END;
                           ELSE
                              DO;
                                 CALL EMIT_CONDITIONAL_BRANCH(FX);
                                 LISTHEAD = (N_TRIPLES - 3) | SHL(FX, 15);
                                 OPERAND#STK(#OP) =
                                    (N_TRIPLES - 3) | MASK_TRIPLE;
                              END;
                        END;
                     ELSE
                        DO;
                           CALL EMIT_TRIPLE(NOT, OPERAND#STK(#OP), NULL, 3);
                           OPERAND#STK(#OP) = (N_TRIPLES - 3) | MASK_TRIPLE;
                        END;
                     FX = ¬FX;
                  END;
               /* 32  <EXPRESSION> ::= <EXPRESSION> <EXPRESSION> */
                                  /* BINARY '=' OPERATOR */
                  CALL EMIT_COMPARE(EQUAL_TO);
               /* 33  <EXPRESSION> ::= <EXPRESSION> <EXPRESSION> */
                                  /* BINARY '<' OPERATOR */
                  CALL EMIT_COMPARE(LESS_THAN);
               /* 34  <EXPRESSION> ::= <EXPRESSION> <EXPRESSION> */
                                  /* BINARY '>' OPERATOR */
                  CALL EMIT_COMPARE(GREATER_THAN);
               /* 35  <EXPRESSION> ::= <EXPRESSION> <EXPRESSION> */
                                  /* BINARY '<>' OPERATOR */
                  CALL EMIT_COMPARE(NOT_EQUAL_TO);
               /* 36  <EXPRESSION> ::= <EXPRESSION> <EXPRESSION> */
                                  /* BINARY '<=' OPERATOR */
                  CALL EMIT_COMPARE(LESS_EQ);
               /* 37  <EXPRESSION> ::= <EXPRESSION> <EXPRESSION> */
                                  /* BINARY '>=' OPERATOR */
                  CALL EMIT_COMPARE(GREATER_EQ);
               /* 38  <EXPRESSION> ::= <EXPRESSION> <EXPRESSION> */
                                  /* BINARY 'IN' OPERATOR */
                  IF #MP = 1 THEN
                     DO;
                        CALL REPLACE(#TP);
                        IF STRUCTYPE(#TP) = SUBRANGE THEN
                           CALL COERCE_ASSIGNMENT(DATATYPE(#TP), #TP);
                        ELSE IF (STRUCTYPE(#TP) ¬= SCALAR)
                                & ¬COMPTYPES(#TP, INTPTR) THEN
                           DO;
                              CALL ERROR(
                'FIRST OPERAND OF "IN" MUST BE SCALAR, SUBRANGE OR INTEGER', 1);
                              #TP = BOOLPTR;
                              #POS_STACK(NP) = 2;
                           END;
                     END;
                  ELSE /* #MP = 2 */ IF #TP = EMPTYSETPTR THEN
                     DO;
                        IF (OPERAND#STK(#OP - 1) & MASK_TRIPLE) ¬= 0 THEN
                           CALL EMIT_TRIPLE(TPOP, OPERAND#STK(#OP - 1), NULL,0);
                        OPERAND#STK(#OP - 1) = FALSE | MASK_IMMEDIATE;
                        #OP = #OP - 1;
                        #TP = BOOLPTR;
                     END;
                  ELSE
                     DO;
                        ID_PTR = OPERAND#STK(#OP - 1);
                        TABLE_PTR = PARSE_TREE(NODE#STACK(NP) + 2);
                        /* ID_PTR IS LEFT OPERAND, TABLE_PTR IS ITS DATATYPE */
                        IF ¬COMPTYPES(TABLE_PTR, DATATYPE(#TP)) THEN
                           CALL ERROR(
                       'FIRST OPERAND OF "IN" NOT COMPATIBLE WITH SET TYPE', 1);
                        MIN = SHL(VALUE(#TP), 3);
                        MAX = SHL(VALUE(#TP) + STORAGE_LNGTH(#TP), 3) - 1;
                        IF STRUCTYPE(TABLE_PTR) = SCALAR THEN
                           DO;
                              MUST_CHECK_LOWBOUND = (MIN > 0);
                              MUST_CHECK_HIGHBOUND =
                                 (MAX < STORAGE_LNGTH(TABLE_PTR) - 1);
                           END;
                        ELSE MUST_CHECK_LOWBOUND, MUST_CHECK_HIGHBOUND = TRUE;
                        IF (ID_PTR & MASK_TRIPLE) ¬= 0 THEN
                           J = ID_PTR | MASK_TEMP;
                        ELSE J = ID_PTR;
                        IF FX THEN
                           DO;
                              LINK = LISTHEAD;
                              LISTHEAD = NULL;
                           END;
                        IF MUST_CHECK_LOWBOUND THEN
                           CALL EMIT_BOUND_CHECK(J, MIN, GREATER_EQ);
                        IF MUST_CHECK_HIGHBOUND THEN
                           CALL EMIT_BOUND_CHECK(J, MAX, LESS_EQ);
                        IF VALUE(#TP) ¬= 0 THEN
                           DO;
                              CALL EMIT_TRIPLE(SUBTRACT, ID_PTR,
                                 FINDCONST(MIN), 3);
                              ID_PTR = (N_TRIPLES - 3) | MASK_TRIPLE;
                           END;
                        CALL EMIT_TRIPLE(IN, ID_PTR, OPERAND#STK(#OP), 0);
                        #TP = BOOLPTR;
                        #OP = #OP - 1;
                        OPERAND#STK(#OP) = N_TRIPLES | MASK_TRIPLE;
                        IF FX THEN
                           DO;
                              CALL EMIT_TRIPLE(BNZ, LINK,
                                 (N_TRIPLES - 3) | MASK_TRIPLE, 0);
                              IF LISTHEAD ¬= NULL THEN
                                 DO;
                                    CALL FIXUP(LISTHEAD, N_TRIPLES);
                                    CALL EMIT_TRIPLE(BCH_TARGET, NULL, NULL, 1);
                                 END;
                              LISTHEAD = OPERAND#STK(#OP);
                           END;
                        ELSE
                           DO;
                              CALL EMIT_TRIPLE(BZ, LISTHEAD,
                                 (N_TRIPLES - 3) | MASK_TRIPLE, 0);
                              LISTHEAD = N_TRIPLES - 3;
                           END;
                     END;
               /* 39  <EXPRESSION> ::= <EXPRESSION> <EXPRESSION> */
                                  /* BINARY '+' OPERATOR */
                  DO;
                     CALL REPLACE(#TP);
                     IF #MP = 2 THEN
                        DO;
                           CALL COERCE_OP;
                           #TP = PARSE_TREE(NODE#STACK(NP) + 2);
                           IF COMPTYPES(#TP, INTPTR) THEN
                              CALL EMIT_TRIPLE(ADD,OPERAND#STK(#OP - 1),
                                               OPERAND#STK(#OP), 3);
                           ELSE IF COMPTYPES(#TP, REALPTR) THEN
                              CALL EMIT_TRIPLE(ADDFLT, OPERAND#STK(#OP - 1),
                                               OPERAND#STK(#OP), 3);
                           ELSE IF (STRUCTYPE(#TP) = SET) |
                                   (STRUCTYPE(#TP) = PACKED_SET) THEN
                              DO;
                                 IF OPERAND#STK(#OP) = EMPTYSETPTR THEN
                                    /* DO NOTHING */ ;
                                 ELSE IF OPERAND#STK(#OP - 1) = EMPTYSETPTR THEN
                                    OPERAND#STK(#OP - 1) = OPERAND#STK(#OP);
                                 ELSE
                                    DO;
                                       CALL EMIT_TRIPLE(TEMP,
                                          OPERAND#STK(#OP - 1), 0,
                                          STORAGE_LNGTH(#TP) - 1);
                                       OPERAND#STK(#OP - 1) =
                                          (N_TRIPLES - 3) | MASK_TRIPLE;
                                       CALL EMIT_TRIPLE(OR,
                                          (N_TRIPLES - 3) | MASK_TEMP,
                                          OPERAND#STK(#OP), 0);
                                    END;
                              END;
                           ELSE CALL ERROR('ILLEGAL "+" OPERATOR', 1);
                           #OP = #OP - 1;
                           IF (STRUCTYPE(#TP) ¬= SET)
                              & (STRUCTYPE(#TP) ¬= PACKED_SET) THEN
                              OPERAND#STK(#OP) = (N_TRIPLES - 3) | MASK_TRIPLE;
                        END;
                  END;
               /* 40  <EXPRESSION> ::= <EXPRESSION> <EXPRESSION> */
                                  /* BINARY '-' OPERATOR */
                  DO;
                     CALL REPLACE(#TP);
                     IF #MP = 2 THEN
                        DO;
                           CALL COERCE_OP;
                           #TP = PARSE_TREE(NODE#STACK(NP) + 2);
                           IF COMPTYPES(#TP, INTPTR) THEN
                              CALL EMIT_TRIPLE(SUBTRACT, OPERAND#STK(#OP - 1),
                                               OPERAND#STK(#OP), 3);
                           ELSE IF COMPTYPES(#TP, REALPTR) THEN
                              CALL EMIT_TRIPLE(SUBFLT, OPERAND#STK(#OP - 1),
                                               OPERAND#STK(#OP), 3);
                           ELSE IF (STRUCTYPE(#TP) = SET) |
                                   (STRUCTYPE(#TP) = PACKED_SET) THEN
                              DO;
                                 IF (OPERAND#STK(#OP) ¬= EMPTYSETPTR)
                                    & (OPERAND#STK(#OP - 1) ¬= EMPTYSETPTR) THEN
                                    DO;
                                       J = OPERAND#STK(#OP - 1);
                                       IF (J & MASK_TRIPLE) ¬= 0 THEN
                                          J = J | MASK_TEMP;
                                       CALL EMIT_TRIPLE(TEMP, J, 0,
                                          STORAGE_LNGTH(#TP) - 1);
                                       CALL EMIT_TRIPLE(XOR,
                                          (N_TRIPLES - 3) | MASK_TEMP,
                                          OPERAND#STK(#OP), 0);
                                       CALL EMIT_TRIPLE(AND,
                                          (N_TRIPLES - 6) | MASK_TEMP,
                                          OPERAND#STK(#OP - 1), 0);
                                       OPERAND#STK(#OP - 1) =
                                          (N_TRIPLES - 9) | MASK_TRIPLE;
                                    END;
                              END;
                           #OP = #OP - 1;
                           IF (STRUCTYPE(#TP) ¬= SET)
                              & (STRUCTYPE(#TP) ¬= PACKED_SET) THEN
                              OPERAND#STK(#OP) = (N_TRIPLES - 3) | MASK_TRIPLE;
                        END;
                  END;
               /* 41  <EXPRESSION> ::= <EXPRESSION> <EXPRESSION> */
                                  /* BINARY 'OR' OPERATOR */
               ANDOR:
                  IF #MP = 1 THEN
                     DO;
                        IF ¬COMPTYPES(#TP, BOOLPTR) THEN CALL ERROR(BOOLTYPE,1);
                        IF IS_CONDITION(OPERAND#STK(#OP)) THEN
                           FIX_LIST(NP) = LISTHEAD;
                        ELSE
                           DO;
                              CALL EMIT_CONDITIONAL_BRANCH(FATHERS_PROD_NO=41);
                              FIX_LIST(NP) =
                                 SHL(FATHERS_PROD_NO=41, 15) | (N_TRIPLES - 3);
                           END;
                        FX = PARSE_TREE(NODE#STACK(NP-1)+#POS_STACK(NP-1)+1);
                        LISTHEAD = NULL;
                        #OP = #OP - 1;
                     END;
                  ELSE
                     DO;
                        IF ¬COMPTYPES(#TP, BOOLPTR) THEN
                           DO;
                              CALL ERROR(BOOLTYPE, 1);
                              #TP = BOOLPTR;
                           END;
                        FX = PARSE_TREE(NODE#STACK(NP-1)+#POS_STACK(NP-1)+1);
                        IF IS_CONDITION(OPERAND#STK(#OP)) THEN
                           DO; /* FIX UP RIGHT OPERAND LIST */
                              IF LISTHEAD ¬= NULL THEN
                                 IF (LISTHEAD & "8000") ¬= (SHL(FX,15) & "8000")
                                 THEN
                                    DO;
                                       CALL EMIT_TRIPLE(BCH_TARGET, NULL,
                                                        NULL, 1);
                                       CALL FIXUP(LISTHEAD, N_TRIPLES - 3);
                                       LISTHEAD = NULL;
                                    END;
                           END;
                        ELSE
                           DO;
                              CALL EMIT_CONDITIONAL_BRANCH(FX);
                              OPERAND#STK(#OP) = (N_TRIPLES - 3) | MASK_TRIPLE;
                              LISTHEAD = (N_TRIPLES - 3) | SHL(FX, 15);
                           END;
                        /* CHECK LEFT OPERAND LIST FOR FIXUP */
                        I = FIX_LIST(NP);
                        IF I ¬= NULL THEN
                           DO;
                              IF (I & "8000") ¬= (SHL(FX,15) & "8000") THEN
                                 DO;
                                    CALL EMIT_TRIPLE(BCH_TARGET, NULL, NULL, 1);
                                    CALL FIXUP(I, N_TRIPLES - 3);
                                 END;
                              ELSE IF LISTHEAD = NULL THEN LISTHEAD = I;
                              ELSE
                                 DO; /* LINK LEFT AND RIGHT FIXUP LISTS */
                                    I = I & "3FFF";
                                    DO WHILE TRIPLES(I + 1) ¬= NULL;
                                       I = TRIPLES(I + 1) & "3FFF";
                                    END;
                                    TRIPLES(I + 1) = LISTHEAD;
                                    LISTHEAD = FIX_LIST(NP);
                                 END;
                           END;
                     END;
               /* 42  <EXPRESSION> ::= <EXPRESSION> <EXPRESSION> */
                                  /* BINARY '*' OPERATOR */
                  DO;
                     CALL REPLACE(#TP);
                     IF #MP = 2 THEN
                        DO;
                           CALL COERCE_OP;
                              #TP = PARSE_TREE(NODE#STACK(NP) + 2);
                           IF COMPTYPES(#TP, INTPTR) THEN
                              CALL EMIT_TRIPLE(MULTIPLY, OPERAND#STK(#OP - 1),
                                               OPERAND#STK(#OP), 3);
                           ELSE IF COMPTYPES(#TP, REALPTR) THEN
                              CALL EMIT_TRIPLE(MPYFLT, OPERAND#STK(#OP - 1),
                                               OPERAND#STK(#OP), 3);
                           ELSE IF (STRUCTYPE(#TP) = SET) |
                                   (STRUCTYPE(#TP) = PACKED_SET) THEN
                              DO;
                                 IF OPERAND#STK(#OP - 1) = EMPTYSETPTR THEN
                                    /* DO NOTHING */ ;
                                 ELSE IF OPERAND#STK(#OP) = EMPTYSETPTR THEN
                                    DO;
                                       IF (OPERAND#STK(#OP - 1) & MASK_TRIPLE)
                                          ¬= 0 THEN
                                          CALL EMIT_TRIPLE(TPOP,
                                             OPERAND#STK(#OP - 1), NULL, 0);
                                       OPERAND#STK(#OP - 1) = EMPTYSETPTR;
                                    END;
                                 ELSE
                                    DO;
                                       CALL EMIT_TRIPLE(TEMP,
                                          OPERAND#STK(#OP - 1), 0,
                                          STORAGE_LNGTH(#TP) - 1);
                                       OPERAND#STK(#OP - 1) =
                                          (N_TRIPLES - 3) | MASK_TRIPLE;
                                       CALL EMIT_TRIPLE(AND,
                                          (N_TRIPLES - 3) | MASK_TEMP,
                                          OPERAND#STK(#OP), 0);
                                    END;
                              END;
                           ELSE CALL ERROR('ILLEGAL "*" OPERATOR', 1);
                           #OP = #OP - 1;
                           IF (STRUCTYPE(#TP) ¬= SET)
                              & (STRUCTYPE(#TP) ¬= PACKED_SET) THEN
                              OPERAND#STK(#OP) = (N_TRIPLES - 3) | MASK_TRIPLE;
                        END;
                  END;
               /* 43  <EXPRESSION> ::= <EXPRESSION> <EXPRESSION> */
                                  /* BINARY '/' OPERATOR */
                  DO;
                     CALL REPLACE(#TP);
                     CALL COERCE_ASSIGNMENT(REALPTR, #TP);
                     IF #MP = 2 THEN
                        DO;
                           CALL EMIT_TRIPLE(DIVFLT, OPERAND#STK(#OP - 1),
                                            OPERAND#STK(#OP), 3);
                           #OP = #OP - 1;
                           OPERAND#STK(#OP) = (N_TRIPLES - 3) | MASK_TRIPLE;
                           #TP = REALPTR;
                        END;
                  END;
               /* 44  <EXPRESSION> ::= <EXPRESSION> <EXPRESSION> */
                                  /* BINARY 'DIV' OPERATOR */
                  DO;
                     CALL REPLACE(#TP);
                     CALL COERCE_ASSIGNMENT(INTPTR, #TP);
                     IF #MP = 2 THEN
                        DO;
                           CALL EMIT_TRIPLE(DIVIDE, OPERAND#STK(#OP - 1),
                                               OPERAND#STK(#OP), 3);
                           #OP = #OP - 1;
                           OPERAND#STK(#OP) = (N_TRIPLES - 3) | MASK_TRIPLE;
                           #TP = INTPTR;
                        END;
                  END;
               /* 45  <EXPRESSION> ::= <EXPRESSION> <EXPRESSION> */
                                  /* BINARY 'MOD' OPERATOR */
                  DO;
                     CALL REPLACE(#TP);
                     CALL COERCE_ASSIGNMENT(INTPTR, #TP);
                     IF #MP = 2 THEN
                        DO;
                           CALL EMIT_TRIPLE(REM, OPERAND#STK(#OP - 1),
                                               OPERAND#STK(#OP), 3);
                           #OP = #OP - 1;
                           OPERAND#STK(#OP) = (N_TRIPLES - 3) | MASK_TRIPLE;
                           #TP = INTPTR;
                        END;
                  END;
               /* 46  <EXPRESSION> ::= <EXPRESSION> <EXPRESSION> */
                                  /* BINARY 'AND' OPERATOR */
                  GOTO ANDOR;
               /* 47  <EXPRESSION> ::= <IDENTIFIER> (<EXPRESSION>)* */
                                  /* FUNCTION PROCEDURE */
                  DO;
                     IF ¬((FATHERS_MULTIPLICITY = 1) & PARAMLIST) THEN
                        CALL PROCFUNC(FALSE);
                     IF #MP = FATHERS_MULTIPLICITY THEN
                        FX = PARSE_TREE(NODE#STACK(NP-1)+#POS_STACK(NP-1) + 1);
                  END;
               /* 48  <EXPRESSION> ::= (<ELEMENT>)+ */
                                  /* SET EXPRESSION */
               SET_ELEMENT:
                  DO;
                     CALL REPLACE(#TP);
                     IF #TP = BOOLPTR THEN
                        IF IS_CONDITION(OPERAND#STK(#OP)) THEN
                           CALL COND_TO_REGISTER;
                     TABLE_PTR = OPERAND#STK(#OP);
                     ID_PTR = FIX_LIST(NP);
                     ERROR_FLAG = FALSE;
                     I = PARSE_TREE(NODE + 1);
                     J = FATHERS_PROD_NO;
                     IF #MP = 1 THEN
                        IF ((J = 76) & (#POS_STACK(NP-1) = 1)) | (I = 75) THEN
                        DO;   /* FORM AN INITIAL TYPING OF THE SET */
                           DATATYPE(ID_PTR) = DATATYPE(#TP);
                           IF COMPTYPES(DATATYPE(#TP), REALPTR) THEN
                              DO;
                                 CALL ERROR('SET ELEMENT OF TYPE REAL', 1);
                                 ERROR_FLAG = TRUE;
                              END;
                           IF (TABLE_PTR & "C000") = MASK_IMMEDIATE THEN
                              DO;
                                 STORAGE_LNGTH(ID_PTR) = 1;
                                 VALUE(ID_PTR) = SHR(TABLE_PTR & "3FFF", 3);
                              END;
                           ELSE IF ((TABLE_PTR & "C000") = MASK_SYMBOL)
                                 & (VAR_TYPE(TABLE_PTR) = CONSTANT) THEN
                              DO;
                                 STORAGE_LNGTH(ID_PTR) = 1;
                                 I = VALUE(TABLE_PTR) / 8;
                                 VALUE(ID_PTR) = I;
                              END;
                           ELSE IF STRUCTYPE(#TP) = SCALAR THEN
                              DO;
                                 STORAGE_LNGTH(ID_PTR) =
                                    SHR(STORAGE_LNGTH(DATATYPE(#TP)), 3) + 1;
                                 VALUE(ID_PTR) = 0;
                              END;
                           ELSE IF STRUCTYPE(#TP) = SUBRANGE THEN
                              DO;
                                 STORAGE_LNGTH(ID_PTR) =
                                    SHR(STORAGE_LNGTH(#TP), 3) + 1;
                                 I = VALUE(S_LIST(#TP)) / 8;
                                 VALUE(ID_PTR) = I;
                              END;
                           ELSE
                              DO;
                                 CALL ERROR(
                           'UNABLE TO DETERMINE DATATYPE OF SET EXPRESSION', 1);
                                 ERROR_FLAG = TRUE;
                              END;
                        END;
                     IF (SHL(1, STRUCTYPE(#TP)) & "(1)10000 00000 00110") = 0
                        /* ¬(STRUCTYPE(#TP) IN (.SCALAR, SUBRANGE, ARITHMETIC.))
                        */ THEN
                        DO;
                           CALL ERROR('ILLEGAL SET ELEMENT', 1);
                           ERROR_FLAG = TRUE;
                        END;
                     IF ¬ERROR_FLAG THEN
                        IF ¬COMPTYPES(DATATYPE(ID_PTR), DATATYPE(#TP)) THEN
                           DO;
                              CALL ERROR('INCOMPATIBLE SET ELEMENTS', 1);
                              ERROR_FLAG = TRUE;
                           END;
                     /* UPDATE SET TYPE ESTIMATE */
                     MIN = SHL(VALUE(ID_PTR), 3);
                     MAX = MIN + SHL(STORAGE_LNGTH(ID_PTR), 3) - 1;
                     IF (TABLE_PTR & "C000") = MASK_IMMEDIATE THEN
                        DO;
                           J = TABLE_PTR & "3FFF";
                           IF J < MIN THEN MIN = J & "FFF8";
                           IF J > MAX THEN MAX = (J & "FFF8") + 7;
                        END;
                     ELSE IF ((TABLE_PTR & "C000") = MASK_SYMBOL) &
                              (VAR_TYPE(TABLE_PTR) = CONSTANT) THEN
                        DO;
                           J = VALUE(TABLE_PTR);
                           IF J < MIN THEN MIN = J & "FFFFFFF8";
                           IF J > MAX THEN MAX = (J & "FFFFFFF8") + 7;
                        END;
                     ELSE IF STRUCTYPE(#TP) = SCALAR THEN
                        DO;
                           MIN = 0;
                           MAX = (STORAGE_LNGTH(DATATYPE(#TP))&"FFFFFFF8") + 7;
                        END;
                     ELSE IF STRUCTYPE(#TP) = SUBRANGE THEN
                        DO;
                           J = VALUE(S_LIST(#TP));
                           IF J < MIN THEN MIN = J & "FFFFFFF8";
                           IF VALUE(#TP) > MAX THEN
                              MAX = (VALUE(#TP) & "FFFFFFF8") + 7;
                        END;
                     ELSE IF ¬ERROR_FLAG THEN
                        DO;
                           CALL ERROR(
                           'UNABLE TO DETERMINE DATATYPE OF SET EXPRESSION', 1);
                           ERROR_FLAG = TRUE;
                        END;
                     I = MIN / 8;
                     VALUE(ID_PTR) = I;
                     STORAGE_LNGTH(ID_PTR) = SHR(MAX - MIN, 3) + 1;
                     IF STORAGE_LNGTH(ID_PTR) > 256 THEN
                        DO;
                           CALL ERROR(SUBRANGE_SIZE, 1);
                           ERROR_FLAG = TRUE;
                        END;
                     IF PARSE_TREE(NODE + 1) = 76 THEN
                        DO;
                           CALL REPLACE(NODE);
                           IF #OP < #OPMAX THEN #OP = #OP + 1;
                           ELSE
                              DO;
                                 CALL ERROR(OP#STACK#ERR, 1);
                                 RETURN;
                              END;
                           OPERAND#STK(#OP) = NULL;
                        END;
                     IF ERROR_FLAG THEN
                        DO;
                           IF FATHERS_PROD_NO = 76 THEN
                              DO;
                                 CALL FATHER;
                                 #MP = #POS_STACK(NP);
                              END;
                           DO I = 1 TO #MP;
                              IF OPERAND#STK(#OP) = NULL THEN #OP = #OP - 3;
                              ELSE #OP = #OP - 1;
                           END;
                           #OP = #OP + 1;
                           #TP, OPERAND#STK(#OP) = EMPTYSETPTR;
                           #POS_STACK(NP) = FATHERS_MULTIPLICITY;
                        END;
                     ELSE IF #MP = FATHERS_MULTIPLICITY THEN
                        DO;
                           CALL EMIT_TRIPLE(TEMP, NULL, 0,
                                            STORAGE_LNGTH(ID_PTR) - 1);
                           FIX_LIST(NP) = (N_TRIPLES - 3) | MASK_TRIPLE;
                           J = FIX_LIST(NP) | MASK_TEMP;
                           CALL EMIT_TRIPLE(XOR, J, J, 0);
                           DO I = 1 TO #MP;
                              IF OPERAND#STK(#OP) = NULL THEN
                                 DO; /* A RANGE-TYPE SET ELEMENT */
                                    #OP = #OP - 1;
                                    J = PARSE_TREE(NODE#STACK(NP)+#MP-I+2);
                                    /* J POINTS TO 76-NODE */
                                    CALL COERCE_SET_ELEMENT(PARSE_TREE(J+3),
                                       MIN);
                                    #OP = #OP - 1;
                                    CALL COERCE_SET_ELEMENT(PARSE_TREE(J+2),
                                       MIN);
                                    CALL EMIT_TRIPLE(RANGE, OPERAND#STK(#OP),
                                       OPERAND#STK(#OP + 1),
                                       STORAGE_LNGTH(ID_PTR) - 1);
                                    OPERAND#STK(#OP) =
                                       (N_TRIPLES - 3) | MASK_TRIPLE;
                                 END;
                              ELSE
                                 CALL COERCE_SET_ELEMENT(
                                    PARSE_TREE(NODE#STACK(NP)+#MP-I+2), MIN);
                              J = FIX_LIST(NP) | MASK_TEMP;
                              CALL EMIT_TRIPLE(INTO, OPERAND#STK(#OP), J, 0);
                              IF I < #MP THEN #OP = #OP - 1;
                              ELSE OPERAND#STK(#OP) = FIX_LIST(NP);
                           END;
                           #TP = ID_PTR;
                        END;
                  END;
               /* 49  <EXPRESSION> ::= <VARIABLE> */
                  CALL REPLACE(#TP);
               /* 50  <EXPRESSION> ::= <UNSIGNED CONSTANT> */
                  DO;
                     PARAMLIST = FALSE;
                     IF VAR_TYPE(TABLE_PTR) = LITERAL THEN
                        DO;   /* A STRING CONSTANT */
                           #TP = TABLE_PTR;
                           CALL REPLACE(#TP);
                        END;
                     ELSE IF (#TP = INTPTR) | (#TP = CHARPTR) THEN
                        OPERAND#STK(#OP) = FINDCONST(VALUE(TABLE_PTR));
                  END;
               /* 51  <VARIABLE> ::= <ID> (<QUALIFIER>)* */
                  IF #MP = 1 THEN
                     DO;
                        I = VAR_TYPE(TABLE_PTR);
                        IF I = VAR_PARAM THEN
                           DO;
                              IF ¬PARAMLIST THEN
                                 DO;
                                    IF (STRUCTYPE(TABLE_PTR) = SCALAR) |
                                       (STRUCTYPE(TABLE_PTR) = SUBRANGE) THEN
                                       I = 1;
                                    ELSE I = STORAGE_LNGTH(DATATYPE(TABLE_PTR))
                                             - 1;
                                    CALL EMIT_TRIPLE(INDEX, 0 | MASK_IMMEDIATE,
                                                     OPERAND#STK(#OP), I);
                                    OPERAND#STK(#OP) =
                                       (N_TRIPLES - 3) | MASK_TRIPLE;
                                    I = I + 1;
                                    IF I > 256 THEN
                                       IF FATHERS_MULTIPLICITY = 1 THEN
                                          CALL EMIT_TRIPLE(S_LENGTH, SHR(I, 16),
                                             I, 0);
                                 END;
                           END;
                        ELSE IF (I = FIELD_ID) | (I = VARIANT) THEN
                           DO;
                              ID_PTR = OWNER(TABLE_PTR);
                              DO WHILE VAR_TYPE(S_LIST(ID_PTR)) = VARIANT;
                                 ID_PTR = OWNER(ID_PTR);
                              END;
                              I = WITH_PTR;
                              DO WHILE (I ¬= NULL)&(WITH_DATATYPE(I) ¬= ID_PTR);
                                 I = I - 1;
                              END;
                              IF I ¬= NULL THEN
                                 DO;
                                    CALL EMIT_TRIPLE(INDEX, 0 | MASK_IMMEDIATE,
                                       WITH_VARIABLE(I), 0);
                                    I = STORAGE_LNGTH(TABLE_PTR);
                                    OPERAND#STK(#OP) = N_TRIPLES | MASK_TRIPLE;
                                    CALL EMIT_TRIPLE(INDEX,
                                       (N_TRIPLES - 3) | MASK_TRIPLE,
                                       FINDCONST(DISPLACEMENT(TABLE_PTR)), I-1);
                                    IF I > 256 THEN
                                       IF FATHERS_MULTIPLICITY = 1 THEN
                                          CALL EMIT_TRIPLE(S_LENGTH, SHR(I, 16),
                                             I, 0);
                                 END;
                              ELSE CALL ERROR('FIELD IDENTIFIER '
                                 || IDENTITY(TABLE_PTR)
                                 || ' MUST BE PRECEDED BY A RECORD NAME', 1);
                           END;
                        ELSE IF (I = PROC) | (I = MULTDECL) |
                                (I = PROC_PARAM) THEN
                           DO;
                              IF LHS THEN
                                 DO;
                                    IF (DATATYPE(TABLE_PTR) = NULL) |
                                       (TABLE_PTR ¬= OWNER_STACK(CURRENT_LEVEL))
                                    THEN CALL ERROR (
                                     'ILLEGAL ASSIGNMENT TO PROCEDURE/FUNCTION '
                                       || IDENTITY(TABLE_PTR), 1);
                                 END;
                              ELSE IF ¬PARAMLIST THEN
                                 CALL PROCFUNC(FALSE);
                           END;
                        ELSE IF I = CONSTANT THEN
                           DO;
                              IF LHS THEN CALL ERROR('CONSTANT IDENTIFIER '
                                 || IDENTITY(TABLE_PTR)
                                 || ' MAY NOT BE ASSIGNED TO', 1);
                              ELSE IF ¬COMPTYPES(#TP, REALPTR) THEN
                                 OPERAND#STK(#OP) = FINDCONST(VALUE(TABLE_PTR));
                           END;
                        ELSE IF I ¬= VARIABLE THEN
                           CALL ERROR('ILLEGAL VARIABLE: '
                              || IDENTITY(TABLE_PTR), 1);
                        LHS, PARAMLIST = FALSE;
                     END;  /* #MP = 1 */
                  ELSE
                     CALL REPLACE(#TP);
               /* 52  (NOT USED) */
                  ;
               /* 53  <QUALIFIER> ::= (<EXPRESSION>)+ */
                                  /* SUBSCRIPT LIST */
                  DO;
                     IF #MP = FATHERS_MULTIPLICITY THEN
                        FX = PARSE_TREE(NODE#STACK(NP-1)+#POS_STACK(NP-1) + 1);
                     IF #MP = 1 THEN ID_PTR =
                        PARSE_TREE(NODE#STACK(NP - 1) + #POS_STACK(NP - 1));
                     ELSE ID_PTR = PARSE_TREE(NODE#STACK(NP) + #MP);
                     IF STRUCTYPE(ID_PTR) ¬= ARRAY THEN
                        CALL ERROR('ILLEGAL SUBSCRIPT', 1);
                     ELSE
                        DO;
                           IF #TP = BOOLPTR THEN
                              IF IS_CONDITION(OPERAND#STK(#OP)) THEN
                                 CALL COND_TO_REGISTER;
                           CALL COERCE_ASSIGNMENT(S_LIST(ID_PTR), #TP);
                           I = STORAGE_LNGTH(ID_PTR)
                               / STORAGE_LNGTH(S_LIST(ID_PTR));
                           /* I IS ARRAY ELEMENT SIZE */
                           IF (OPERAND#STK(#OP) & "C000") = MASK_IMMEDIATE THEN
                              OPERAND#STK(#OP) =
                                 FINDCONST(I*(OPERAND#STK(#OP) & "3FFF"));
                           ELSE IF ((OPERAND#STK(#OP) & "C000") = MASK_SYMBOL) &
                                (VAR_TYPE(OPERAND#STK(#OP)) = CONSTANT) THEN
                              OPERAND#STK(#OP) =
                                 FINDCONST(VALUE(OPERAND#STK(#OP))*I);
                           ELSE IF I ¬= 1 THEN
                              DO;
                                 CALL EMIT_TRIPLE(MULTIPLY, OPERAND#STK(#OP),
                                    FINDCONST(I), 3);
                                 OPERAND#STK(#OP) =
                                    (N_TRIPLES - 3) | MASK_TRIPLE;
                              END;
                           CALL EMIT_TRIPLE(INDEX, OPERAND#STK(#OP - 1),
                              OPERAND#STK(#OP), I - 1);
                           #OP = #OP - 1;
                           OPERAND#STK(#OP) = (N_TRIPLES - 3) | MASK_TRIPLE;
                           IF I > 256 THEN
                              IF (#MP = FATHERS_MULTIPLICITY) &
                                 (#POS_STACK(NP - 1) =
                                    MULTIPLICITY(NODE#STACK(NP - 1))) THEN
                                 CALL EMIT_TRIPLE(S_LENGTH, SHR(I, 16), I, 0);
                           #TP = DATATYPE(ID_PTR);
                           CALL REPLACE(#TP);
                        END;
                  END;
               /* 54  <QUALIFIER> ::= <EMPTY> */
                                  /* ARROW (@) */
                  DO;
                     #TP = PARSE_TREE(NODE#STACK(NP - 1) + #POS_STACK(NP - 1));
                     IF (STRUCTYPE(#TP) = FILE) | (STRUCTYPE(#TP) = PACKED_FILE)
                        THEN #TP = DATATYPE(#TP);
                     ELSE IF STRUCTYPE(#TP) = POINTER THEN
                        DO;
                           ID_PTR = DATATYPE(#TP);
                           IF (STRUCTYPE(ID_PTR) = SCALAR) |
                              (STRUCTYPE(ID_PTR) = SUBRANGE) THEN
                                 I = 1;
                           ELSE I = STORAGE_LNGTH(ID_PTR) - 1;
                           CALL EMIT_TRIPLE(INDEX, 0 | MASK_IMMEDIATE,
                              OPERAND#STK(#OP), I);
                           OPERAND#STK(#OP) = (N_TRIPLES - 3) | MASK_TRIPLE;
                           I = I + 1;
                           IF I > 256 THEN
                              IF #POS_STACK(NP - 1) =
                                    MULTIPLICITY(NODE#STACK(NP - 1)) THEN
                                CALL EMIT_TRIPLE(S_LENGTH, SHR(I, 16), I, 0);
                           #TP = DATATYPE(#TP);
                        END;
                     ELSE CALL ERROR(
                        'TYPE OF VARIABLE MUST BE FILE OR POINTER', 1);
                  END;
               /* 55  <QUALIFIER> ::= <ID> */
                                  /* FIELD IDENTIFIER */
                  IF (VAR_TYPE(TABLE_PTR) = FIELD_ID) |
                     (VAR_TYPE(TABLE_PTR) = VARIANT) THEN
                     DO;
                        #TP =
                           PARSE_TREE(NODE#STACK(NP - 1) + #POS_STACK(NP - 1));
                        #OP = #OP - 1;
                        IF (STRUCTYPE(#TP) = RECORD) |
                           (STRUCTYPE(#TP) = PACKED_RECORD) THEN
                           DO;
                              ID_PTR = OWNER(TABLE_PTR);
                              DO WHILE VAR_TYPE(S_LIST(ID_PTR)) = VARIANT;
                                 ID_PTR = OWNER(ID_PTR);
                              END;
                              IF ID_PTR ¬= #TP THEN
                                 CALL ERROR(IDENTITY(TABLE_PTR)
                                    || ' IS NOT A FIELD IN THIS RECORD', 1);
                              ELSE
                                 DO;
                                    CALL EMIT_TRIPLE(INDEX, OPERAND#STK(#OP),
                                       FINDCONST(DISPLACEMENT(TABLE_PTR)),
                                       STORAGE_LNGTH(TABLE_PTR) - 1);
                                    OPERAND#STK(#OP) =
                                       (N_TRIPLES - 3) | MASK_TRIPLE;
                                    I = STORAGE_LNGTH(TABLE_PTR);
                                    IF I > 256 THEN
                                       IF #POS_STACK(NP - 1) =
                                             MULTIPLICITY(NODE#STACK(NP - 1))
                                       THEN
                                          CALL EMIT_TRIPLE(S_LENGTH, SHR(I, 16),
                                             I, 0);
                                    #TP = DATATYPE(TABLE_PTR);
                                    CALL REPLACE(#TP);
                                 END;
                           END;
                        ELSE CALL ERROR('TYPE OF VARIABLE IS NOT RECORD', 1);
                     END;
                  ELSE
                     DO;
                        CALL ERROR(IDENTITY(TABLE_PTR)
                                   || ' IS NOT A FIELD IDENTIFIER', 1);
                        #OP = #OP - 1;
                     END;
               /* 56  (NOT USED) */
                  ;
               /* 57  <CONSTANT> ::= <UNSIGNED CONSTANT> */
                                  /* + CONSTANT */
                  ;
               /* 58  <CONSTANT> ::= <UNSIGNED CONSTANT> */
                                  /* - CONSTANT */
                  IF (VAR_TYPE(TABLE_PTR) = CONSTANT) &
                     (STRUCTYPE(TABLE_PTR) = ARITHMETIC) THEN
                     DO;
                        I = VALUE(TABLE_PTR);
                        IF COMPTYPES(DATATYPE(TABLE_PTR), REALPTR) THEN
                           DO;
                              IF I < 0 THEN I = I & "7FFFFFFF";
                              ELSE I = I | "80000000";
                              TABLE_PTR = FINDREAL(I);
                           END;
                        ELSE TABLE_PTR = FINDCONST(-I);
                        IF IS_DECLARATION THEN
                           CALL REPLACE(TABLE_PTR);
                        ELSE
                           DO;
                              OPERAND#STK(#OP) = TABLE_PTR;
                              CALL REPLACE(#TP);
                           END;
                     END;
                  ELSE CALL ERROR('ILLEGAL CONSTANT: -'
                                  || IDENTITY(TABLE_PTR), 1);
               /* 59  <TYPE> ::= <IDENTIFIER> */
                                  /* SIMPLE TYPE IDENTIFIER */
                  ALLOCATE_NEW_ROW = TRUE;
               /* 60  <TYPE> ::= (<ID>)+ */
                                  /* SCALAR TYPE */
                  DO;
                     IF #MP = 1 THEN
                        DO;
                           IF ALLOCATE_NEW_ROW THEN
                              DO;
                                 ID_PTR = NEXT_FREE_ROW;
                                 VAR_TYPE(ID_PTR) = TYPE;
                                 OWNER(ID_PTR) = OWNER_STACK(CURRENT_LEVEL);
                              END;
                           ELSE
                              DO;
                                 ID_PTR = TP_ID_PTR;
                                 ALLOCATE_NEW_ROW = TRUE;
                              END;
                           STRUCTYPE(ID_PTR) = SCALAR;
                           DATATYPE(ID_PTR) = ID_PTR;
                           S_LIST(ID_PTR) = TABLE_PTR;
                           STORAGE_LNGTH(ID_PTR) = FATHERS_MULTIPLICITY;
                        END;
                     ELSE S_LIST(PARSE_TREE(NODE#STACK(NP) + #MP)) = TABLE_PTR;
                     VAR_TYPE(TABLE_PTR) = CONSTANT;
                     STRUCTYPE(TABLE_PTR) = SCALAR;
                     OWNER(TABLE_PTR) = OWNER(ID_PTR);
                     VALUE(TABLE_PTR) = #MP - 1;
                     TABLE_PTR, DATATYPE(TABLE_PTR) = ID_PTR;
                  END;
               /* 61  <TYPE> ::= <CONSTANT> <CONSTANT> */
                                  /* SUBRANGE TYPE */
               IF #MP = 1 THEN DO;
                  IF ALLOCATE_NEW_ROW THEN
                     ID_PTR = NEXT_FREE_ROW;
                  ELSE DO;
                     ID_PTR = TP_ID_PTR;
                     ALLOCATE_NEW_ROW = TRUE;
                     END;
                  CALL REPLACE (ID_PTR);
                  I, DATATYPE(ID_PTR) = DATATYPE(TABLE_PTR);
                  IF (I ¬= INTPTR) THEN
                     IF STRUCTYPE(I) ¬= SCALAR THEN CALL ERROR
                        ('A SUBRANGE MUST BE OF A SCALAR TYPE OR OF INTEGERS',1)
                        ;
                  VAR_TYPE(ID_PTR) = TYPE;
                  STRUCTYPE(ID_PTR) = SUBRANGE;
                  OWNER(ID_PTR) = OWNER_STACK(CURRENT_LEVEL);
                  S_LIST(ID_PTR) = TABLE_PTR;
                  END;
               ELSE DO;
                  ID_PTR = PARSE_TREE(NODE#STACK(NP) + 2);
                  I = VALUE(S_LIST(ID_PTR));  /* GET VALUE(<CONSTANT1>) */
                  IF DATATYPE(ID_PTR) ¬= DATATYPE(TABLE_PTR) THEN
                     CALL ERROR('TYPES OF SUBRANGE BOUNDS DISAGREE', 1);
                  ELSE IF I > VALUE(TABLE_PTR) THEN
                     CALL ERROR('LOWER BOUND OF SUBRANGE EXCEEDS UPPER BOUND',
                        1);
                  VALUE(ID_PTR) = VALUE(TABLE_PTR);
                  IF I < 0 THEN DO;
                     IF I + 32767 > VALUE(TABLE_PTR) THEN
                        SL = VALUE(TABLE_PTR) - I + 1;
                     ELSE SL = NULL;
                     END;
                  ELSE DO;
                     SL = VALUE(TABLE_PTR) - I + 1;
                     IF SL > 32767 THEN SL = NULL;
                     END;
                  STORAGE_LNGTH(ID_PTR) = SL;
                  TABLE_PTR = ID_PTR;
                  END;
               /* 62  <TYPE> ::= <ID> */
                                  /* POINTER TYPE */
                  DO;
                     IF ALLOCATE_NEW_ROW THEN ID_PTR = NEXT_FREE_ROW;
                     ELSE
                        DO;
                           ID_PTR = TP_ID_PTR;
                           ALLOCATE_NEW_ROW = TRUE;
                        END;
                     DATATYPE(ID_PTR) = TABLE_PTR;
                     VAR_TYPE(ID_PTR) = TYPE;
                     STORAGE_LNGTH(ID_PTR) = 4;
                     STRUCTYPE(ID_PTR) = POINTER;
                     OWNER(ID_PTR) = OWNER_STACK(CURRENT_LEVEL);
                     TABLE_PTR = ID_PTR;
                  END;
               /* 63  <TYPE> ::= (<TYPE>)+ <TYPE> */
                                  /* ARRAY TYPE */
            ARRAYTYP:
                  IF #MP < FATHERS_MULTIPLICITY THEN DO;
                     IF ALLOCATE_ARRAY_ENTRY THEN
                        ID_PTR = NEXT_FREE_ROW;
                     ELSE DO;
                        ID_PTR = TP_ID_PTR;
                        ALLOCATE_ARRAY_ENTRY = TRUE;
                        END;
                     CALL REPLACE (ID_PTR);
                     VAR_TYPE(ID_PTR) = TYPE;
                     STRUCTYPE(ID_PTR) = ARRAY;
                     OWNER(ID_PTR) = OWNER_STACK(CURRENT_LEVEL);
                     S_LIST(ID_PTR) = TABLE_PTR;
                     END;
                  ELSE DO;
                     CALL COMPUTE_STORAGE_LENGTH(TABLE_PTR);
                     #TP = FATHERS_MULTIPLICITY;
                     DO WHILE #TP >= 2;
                        ID_PTR = PARSE_TREE(NODE#STACK(NP) + #TP);
                        DATATYPE(ID_PTR) = TABLE_PTR;
                        SL, STORAGE_LNGTH(ID_PTR) = STORAGE_LNGTH(S_LIST(ID_PTR)
                                                                        )*SL;
                        TABLE_PTR = ID_PTR;
                        #TP = #TP - 1;
                        END;
                     END;
               /* 64  <TYPE> ::= <TYPE> */
                                  /* FILE TYPE */
            FILETYP:
               DO;
                  IF ALLOCATE_NEW_ROW THEN
                     ID_PTR = NEXT_FREE_ROW;
                  ELSE DO;
                     ID_PTR = TP_ID_PTR;
                     ALLOCATE_NEW_ROW = TRUE;
                     END;
                  DATATYPE(ID_PTR) = TABLE_PTR;
                  VAR_TYPE(ID_PTR) = TYPE;
                  STRUCTYPE(ID_PTR) = FILE;
                  OWNER(ID_PTR) = OWNER_STACK(CURRENT_LEVEL);
                  CALL COMPUTE_STORAGE_LENGTH(TABLE_PTR);
                  STORAGE_LNGTH(ID_PTR) = SL;
                  TABLE_PTR = ID_PTR;
                  END;
               /* 65  <TYPE> ::= <TYPE> */
                                  /* SET TYPE */
            SETTYP:
               DO;
                  IF ALLOCATE_ARRAY_ENTRY THEN
                     ID_PTR = NEXT_FREE_ROW;
                  ELSE DO;
                     ID_PTR = TP_ID_PTR;
                     ALLOCATE_ARRAY_ENTRY = TRUE;
                     END;
                  DATATYPE(ID_PTR) = DATATYPE(TABLE_PTR);
                  S_LIST(ID_PTR) = TABLE_PTR;
                  VAR_TYPE(ID_PTR) = TYPE;
                  STRUCTYPE(ID_PTR) = SET;
                  OWNER(ID_PTR) = OWNER_STACK(CURRENT_LEVEL);
                  IF STRUCTYPE(TABLE_PTR) = SCALAR THEN
                     DO;
                        STORAGE_LNGTH(ID_PTR) =
                           SHR(STORAGE_LNGTH(TABLE_PTR) + 7, 3);
                        VALUE(ID_PTR) = 0;
                     END;
                  ELSE IF STRUCTYPE(TABLE_PTR) = SUBRANGE THEN
                     DO;
                        IF STORAGE_LNGTH(TABLE_PTR) = NULL THEN
                           CALL ERROR(SUBRANGE_SIZE, 1);
                        ELSE
                           DO;
                              I = VALUE(S_LIST(TABLE_PTR)) & "FFFFFFF8";
                              I = I / 8;
                              VALUE(ID_PTR) = I;
                              SL = VALUE(TABLE_PTR) & "FFFFFFF8";
                              SL = (SL/8) - VALUE(ID_PTR) + 1;
                              STORAGE_LNGTH(ID_PTR) = SL;
                           END;
                     END;
                  ELSE CALL ERROR(
                     'A SET TYPE MUST BE BASED ON A SCALAR OR SUBRANGE TYPE',1);
                  IF STORAGE_LNGTH(ID_PTR) > 256 THEN
                     CALL ERROR(SUBRANGE_SIZE, 1);
                  TABLE_PTR = ID_PTR;
                  END;
               /* 66  <TYPE> ::= (<FIXED FIELD LIST>)* (<VARIANT FIELD>) */
                                  /* RECORD TYPE */
               RECORDTYP:
                  DO;
                     IF #MP = 1 THEN
                        DO;
                           ID_PTR = OWNER_STACK(CURRENT_LEVEL);
                           S_LIST(ID_PTR) = TABLE_PTR;
                           CALL REPLACE(TABLE_PTR);
                           STORAGE_LNGTH(ID_PTR) = STORAGE_LNGTH(TABLE_PTR);
                        END;
                     ELSE
                        DO;
                           I, ID_PTR = PARSE_TREE(NODE#STACK(NP) + #MP);
                           DO WHILE S_LIST(I) ¬= NULL;
                              I = S_LIST(I);
                           END;
                           S_LIST(I) = TABLE_PTR;
                           CALL REPLACE(TABLE_PTR);
                           ID_PTR = OWNER_STACK(CURRENT_LEVEL);
                        END;
                     IF #MP = FATHERS_MULTIPLICITY THEN
                        DO;
                           TABLE_PTR = OWNER_STACK(CURRENT_LEVEL);
                           CALL ALLOCATE_ARRAY_STORAGE(CURRENT_LEVEL);
                           /* COMPUTE STORAGE_LNGTH FROM ALLOCATED DISPLACEMENT
                              INTO STACK.   */
                           IF VAR_TYPE(OWNER(TABLE_PTR)) = PROC THEN
                              STORAGE_LNGTH(TABLE_PTR) =
                                 STACK_LIMIT(CURRENT_LEVEL);
                           ELSE STORAGE_LNGTH(TABLE_PTR) =
                              STACK_LIMIT(CURRENT_LEVEL)
                                 - STACK_LIMIT(CURRENT_LEVEL - 1);
                           CURRENT_LEVEL = CURRENT_LEVEL - 1;
                        END;
                  END;
               /* 67  <FIXED FIELD LIST> ::= (<ID>)+ <TYPE> */
                  IF #MP < FATHERS_MULTIPLICITY THEN
                     DO;
                        I, OWNER(TABLE_PTR) = OWNER_STACK(CURRENT_LEVEL);
                        IF GREAT_GRANDFATHERS_PROD_NO = 69 THEN
                           VAR_TYPE(TABLE_PTR) = VARIANT;
                        ELSE VAR_TYPE(TABLE_PTR) = FIELD_ID;
                        IF #MP > 1 THEN
                           DO; /* LINK FIELD VARIABLES */
                              ID_PTR = PARSE_TREE(NODE#STACK(NP) + #MP);
                              S_LIST(ID_PTR) = TABLE_PTR;
                           END;
                     END;
                  ELSE
                     DO;
                        CALL COMPUTE_STORAGE_LENGTH(TABLE_PTR);
                        I, ID_PTR = PARSE_TREE(NODE#STACK(NP) + 2);
                        DO WHILE ID_PTR ¬= NULL;
                           DATATYPE(ID_PTR) = TABLE_PTR;
                           STRUCTYPE(ID_PTR) = STRUCTYPE(TABLE_PTR);
                           CALL ALLOCATE_STORAGE(ID_PTR);
                           PSEUDO_REG(ID_PTR) = NULL;
                           ID_PTR = S_LIST(ID_PTR);
                        END;
                        TABLE_PTR = I;
                     END;
               /* 68  <VARIANT FIELD> ::= <ID> <ID> (<VARIANT INSTANCE>)+ */
                  DO;
                     IF #MP = 1 THEN
                        DO;
                           I, OWNER(TABLE_PTR) = OWNER_STACK(CURRENT_LEVEL);
                           IF GREAT_GRANDFATHERS_PROD_NO = 69 THEN
                              VAR_TYPE(TABLE_PTR) = VARIANT;
                           ELSE VAR_TYPE(TABLE_PTR) = FIELD_ID;
                           STRUCTYPE(TABLE_PTR) = TAG;
                           SL = 2;
                           CALL ALLOCATE_STORAGE(TABLE_PTR);
                           CALL ALLOCATE_ARRAY_STORAGE(CURRENT_LEVEL);
                           ARRAYS_ALLOCATED(CURRENT_LEVEL) = NULL;
                        END;
                     ELSE IF #MP = 2 THEN
                        DO;
                           IF (VAR_TYPE(TABLE_PTR) ¬= TYPE) |
                              (STRUCTYPE(TABLE_PTR) < SCALAR) |
                              (STRUCTYPE(TABLE_PTR) > SUBRANGE)  THEN
                                 CALL ERROR('INVALID TAG TYPE IN VARIANT RECORD'
                                    , 1);
                           DATATYPE(PARSE_TREE(NODE#STACK(NP) + 2)) = TABLE_PTR;
                        END;
                     ELSE IF #MP = 3 THEN
                        DO;
                           ID_PTR = PARSE_TREE(NODE#STACK(NP) + 2);
                           S_LIST(ID_PTR) = TABLE_PTR;
                           CALL REPLACE(TABLE_PTR);
                           STORAGE_LNGTH(ID_PTR) = STACK_LIMIT(CURRENT_LEVEL+1)
                                                  - STACK_LIMIT(CURRENT_LEVEL);
                        END;
                     ELSE
                        DO;
                           ID_PTR = PARSE_TREE(NODE#STACK(NP) + #MP);
                           DO WHILE S_LIST(ID_PTR) ¬= NULL;
                              ID_PTR = S_LIST(ID_PTR);
                           END;
                           S_LIST(ID_PTR) = TABLE_PTR;
                           CALL REPLACE(TABLE_PTR);
                           ID_PTR = PARSE_TREE(NODE#STACK(NP) + 2);
                           SL = STACK_LIMIT(CURRENT_LEVEL + 1)
                               - STACK_LIMIT(CURRENT_LEVEL);
                           IF STORAGE_LNGTH(ID_PTR) < SL THEN
                              STORAGE_LNGTH(ID_PTR) = SL;
                        END;
                     IF #MP = FATHERS_MULTIPLICITY THEN
                        DO;
                           TABLE_PTR = ID_PTR; /* POINTS TO TAG */
                           STACK_LIMIT(CURRENT_LEVEL) =
                              STACK_LIMIT(CURRENT_LEVEL)
                                 + STORAGE_LNGTH(ID_PTR);
                           STORAGE_LNGTH(ID_PTR) = 2;
                        END;
                  END;
               /* 69  <VARIANT INSTANCE> ::= (<CONSTANT>)+ <TYPE>
                         IN WHICH <TYPE> IS ALWAYS A RECORD TYPE -- PROD. 66  */
                  DO;
                     IF FATHERS_MULTIPLICITY - #MP > 1 THEN
                        DO;
                           /* CREATE A SYMBOL TABLE ENTRY FOR A CASELABEL */
                           ID_PTR = NEXT_FREE_ROW;
                           DATATYPE(ID_PTR) = DATATYPE(TABLE_PTR);
                           VAR_TYPE(ID_PTR) = CASELABEL;
                           STRUCTYPE(ID_PTR) = SCALAR;
                           OWNER(ID_PTR) = OWNER_STACK(CURRENT_LEVEL);
                           VALUE(ID_PTR) = VALUE(TABLE_PTR);
                           TABLE_PTR = ID_PTR;
                        END;
                     IF #MP < FATHERS_MULTIPLICITY THEN
                        DO;
                           CALL REPLACE(TABLE_PTR);
                           IF #MP > 1 THEN
                              S_LIST(PARSE_TREE(NODE#STACK(NP) + #MP)) =
                                    TABLE_PTR;
                           I = DATATYPE(PARSE_TREE(NODE#STACK(NP - 1) + 2));
                              /* POINTER TO THE TAG TYPE */
                           IF DATATYPE(TABLE_PTR) ¬= I THEN
                              DO;
                                 IF STRUCTYPE(I) = SUBRANGE THEN
                                    DO;
                                       IF DATATYPE(I) ¬= DATATYPE(TABLE_PTR)
                                       THEN CALL ERROR(TAG_TYPE, 1);
                                       ELSE
                                          IF (VALUE(TABLE_PTR) > VALUE(I)) |
                                          (VALUE(TABLE_PTR) < VALUE(S_LIST(I)))
                                          THEN CALL ERROR(
            'VALUE OF CASE LABEL IS OUTSIDE SUBRANGE SPECIFIED BY TAG TYPE', 1);
                                    END;
                                 ELSE CALL ERROR(TAG_TYPE, 1);
                              END;
                        END;
                     ELSE
                        DO;
                           ID_PTR = PARSE_TREE(NODE#STACK(NP) + #MP);
                           VALUE(TABLE_PTR) = VALUE(ID_PTR);
                           I = FATHERS_MULTIPLICITY - 1;
                           IF I > 1 THEN
                              DO;
                                 S_LIST(PARSE_TREE(NODE#STACK(NP) + I)) =
                                    TABLE_PTR;
                                 TABLE_PTR = PARSE_TREE(NODE#STACK(NP) + 2);
                              END;
                        END;
                  END;
               /* 70  <STATEMENT> ::= <EMPTY> */
                  ;
               /* 71  <TYPE> ::= (<TYPE>)+ <TYPE> */
                                  /* PACKED ARRAY TYPE */
                  GOTO ARRAYTYP;
               /* 72  <TYPE> ::= <TYPE> */
                                  /* PACKED FILE TYPE */
                  GOTO FILETYP;
               /* 73  <TYPE> ::= <TYPE> */
                                  /* PACKED SET TYPE */
                  GOTO SETTYP;
               /* 74  <TYPE> ::= (<FIXED FIELD LIST>)* (<VARIANT FIELD>) */
                                  /* PACKED RECORD TYPE */
                  GOTO RECORDTYP;
               /* 75  <ELEMENT> ::= <EXPRESSION> */
                                  /* SIMPLE SET ELEMENT */
                  FX = PARSE_TREE(NODE#STACK(NP - 1) + #POS_STACK(NP - 1) + 1);
               /* 76  <ELEMENT> ::= <EXPRESSION> <EXPRESSION> */
                                  /* RANGE */
                  IF #MP = 1 THEN
                     DO;
                        FIX_LIST(NP) = FIX_LIST(NP - 1);
                        GOTO SET_ELEMENT;
                     END;
                  ELSE
                     DO;
                        CALL REPLACE(#TP);
                        FX = PARSE_TREE(NODE#STACK(NP - 1)
                                         + #POS_STACK(NP - 1) + 1);
                     END;
               /* 77  <PARAM TYPES> ::= (<TYPE ID>)+ */
                                  /* LIST OF TYPES OF VALUE PARAMETERS */
               TYPE_LIST:
                  DO;
                     I = NEXT_FREE_ROW;
                     DATATYPE(I) = TABLE_PTR;
                     IF VAR_TYPE(TABLE_PTR) ¬= TYPE THEN
                        CALL ERROR(IDENTITY(TABLE_PTR) || ' IS NOT A TYPE', 1);
                     STRUCTYPE(I) = STRUCTYPE(TABLE_PTR);
                     OWNER(I) = OWNER_STACK(CURRENT_LEVEL);
                     PSEUDO_REG(I), S_LIST(I) = NULL;
                     IF FATHERS_PROD_NO = 77 THEN
                        DO; /* FORMAL VALUE PARAMETERS */
                           VAR_TYPE(I) = VARIABLE;
                           CALL COMPUTE_STORAGE_LENGTH(I);
                           CALL ALLOCATE_STORAGE(I);
                        END;
                     ELSE   /* FORMAL VAR PARAMETER */
                        DO;
                           VAR_TYPE(I) = VAR_PARAM;
                           STORAGE_LNGTH(I) = 4;
                           DISPLACEMENT(I) = STACK_LIMIT(CURRENT_LEVEL);
                           STACK_LIMIT(CURRENT_LEVEL) =
                              STACK_LIMIT(CURRENT_LEVEL) + 4;
                        END;
                     IF #MP > 1 THEN
                        DO; /* LINK FORMAL PARAMETER TYPES TOGETHER */
                           J = PARSE_TREE(NODE#STACK(NP) + #MP);
                           S_LIST(J) = I;
                        END;
                     CALL REPLACE(I);
                     IF #MP = FATHERS_MULTIPLICITY THEN
                        TABLE_PTR = PARSE_TREE(NODE#STACK(NP) + 2);
                  END;
               /* 78  <PARAM TYPES> ::= (<TYPE ID>)+ */
                                  /* LIST OF TYPES OF VAR PARAMETERS */
                  GOTO TYPE_LIST;
               /* 79  <PARAM TYPES> ::= (<PARAM TYPES>)+ (<TYPE ID>) */
                                  /* PROCEDURE OR FUNCTION TYPES */
                  DO;
                     CALL REPLACE(TABLE_PTR);
                     IF #MP > 1 THEN
                        DO;   /* LINK FORMAL PARAM LISTS TOGETHER */
                           LINK = PARSE_TREE(NODE#STACK(NP) + #MP);
                           IF LINK ¬= NULL THEN
                              DO;
                                 DO WHILE S_LIST(LINK) ¬= NULL;
                                    LINK = S_LIST(LINK);
                                 END;
                                 S_LIST(LINK) = TABLE_PTR;
                              END;
                        END;
                     IF #MP = FATHERS_MULTIPLICITY THEN
                        DO;
                           ID_PTR = OWNER_STACK(CURRENT_LEVEL);
                           IF IS_LEAF THEN
                              DO; /* A FUNCTION-TYPE PARAMETER */
                                 IF LINK ¬= NULL THEN S_LIST(LINK) = NULL;
                                 DATATYPE(ID_PTR) = TABLE_PTR;
                                 STRUCTYPE(ID_PTR) = STRUCTYPE(TABLE_PTR);
                                 IF VAR_TYPE(TABLE_PTR) ¬= TYPE THEN
                                    CALL ERROR(IDENTITY(TABLE_PTR)
                                              || ' IS NOT A TYPE', 1);
                              END;
                           CALL ALLOCATE_ARRAY_STORAGE(CURRENT_LEVEL);
                           VALUE(ID_PTR) = PARSE_TREE(NODE#STACK(NP) + 2);
                           CURRENT_LEVEL = CURRENT_LEVEL - 1;
                           TABLE_PTR = ID_PTR;
                        END;
                  END;
               /* 80  <PARAM TYPES> ::= <EMPTY> */
                  TABLE_PTR = NULL;
               /* 81  <ERROR> ::= <EMPTY> */
                  IF ¬IS_DECLARATION THEN
                     DO WHILE (FATHERS_PROD_NO ¬= 3) & (NP >= 0);
                        CALL FATHER;
                     END;
               END;   /* CASE */
               IF #POS_STACK(NP) = MULTIPLICITY(NODE#STACK(NP)) THEN
                  CALL FATHER;
               ELSE
                  DO;
                     CALL RIGHT_BRO;
                     FIRST_VISIT = TRUE;
                  END;
            END;
      END;
   END VISIT_NODES;

   /*             PROCEDURES FOR RESTORING SYMBOL TABLE               */

NEXT_SYMBOL:
   PROCEDURE CHARACTER;
     /*         $P ----- DISABLES XREF PROGRAM         */
      DECLARE (CP, S1, S2, TEXT_LIMIT) FIXED, (BCD, CHAR) CHARACTER;
      IF LENGTH(SY_TEXT) < 3 THEN
         DO;
            CHAR = INPUT(3);
            SY_TEXT = SY_TEXT || CHAR;
         END;
      BCD = '';
      S1 = BYTE(X1);
      S2 = BYTE(SY_TEXT, 1);
      CP = 1;
      TEXT_LIMIT = LENGTH(SY_TEXT) - 1;
      DO WHILE ¬(S1 = BYTE('''') & S2 = BYTE(X1));
         IF ¬(S1 = BYTE('''') & S2 = S1) THEN
            DO;
               CHAR = SUBSTR(SY_TEXT, CP, 1);
               BCD = BCD || CHAR;
            END;
         ELSE S2 = BYTE(X1);
         S1 = S2;
         CP = CP + 1;
         IF CP > TEXT_LIMIT THEN
            DO;
               SY_TEXT = INPUT(3);
               TEXT_LIMIT = 79;
               CP = 0;
            END;
         S2 = BYTE(SY_TEXT, CP);
      END;
      BCD = SUBSTR(BCD, 0, LENGTH(BCD) - 1);
      IF CP = TEXT_LIMIT THEN
         DO;
            CHAR = INPUT(3);
            SY_TEXT = SY_TEXT || CHAR;
         END;
      SY_TEXT = SUBSTR(SY_TEXT, CP + 1);
      RETURN BCD;
   END NEXT_SYMBOL;

RESTORE_COLUMN:
   PROCEDURE (ARRAY_ADDR, BYTES_PER_ITEM, LIMIT);
      DECLARE ARRAY_ADDR FIXED,
              (BYTES_PER_ITEM, LIMIT) BIT(16);
      DECLARE (INCREMENT, I, J, K) FIXED;
      DECLARE MVC(3) BIT(16) INITIAL("D200", "2000", "1000");
      INCREMENT = 80 / BYTES_PER_ITEM;
      J = ARRAY_ADDR + (N_PREDECLARED_SYMB + 1)*BYTES_PER_ITEM;
      I = N_PREDECLARED_SYMB + 1;
      DO WHILE I + INCREMENT < LIMIT;
         CALL INLINE("58",1,0,SY_TEXT);          /* L    1,SY_TEXT         */
         CALL INLINE("58",2,0,J);                /* L    2,J               */
         CALL INLINE("D2","4","F",2,0,1,0);      /* MVC  0(80,2),0(1)      */
         I = I + INCREMENT;
         J = J + 80;
         SY_TEXT = INPUT(3);
      END;
      K = (LIMIT - I) * BYTES_PER_ITEM - 1;
      CALL INLINE("58",1,0,SY_TEXT);             /* L    1,SY_TEXT         */
      CALL INLINE("58",2,0,J);                   /* L    2,J               */
      CALL INLINE("58",3,0,K);                   /* L    3,K               */
      CALL INLINE("44",3,0,MVC);                 /* EX   3,MVC             */
      SY_TEXT = INPUT(3);
   END RESTORE_COLUMN;

RESTORE_SY_TABLE:
   PROCEDURE;
      DECLARE I FIXED;
      DECLARE S CHARACTER;
      N_DECL_SYMB, N_ANONYMOUS_SYMB = 0;
      SY_TEXT = INPUT(3);
      IF SUBSTR(SY_TEXT, 0, 5) ¬= '%SYMB' THEN
         DO;
            OUTPUT = '%SYMB CARD EXPECTED.';
            CALL EXIT;
         END;
      DO I = 5 TO 9;
         IF BYTE(SY_TEXT, I) ¬= BYTE(' ') THEN
            N_DECL_SYMB = 10*N_DECL_SYMB + BYTE(SY_TEXT,I) - BYTE('0');
      END;
      DO I = 10 TO 14;
         IF BYTE(SY_TEXT,I) ¬= BYTE(' ') THEN
            N_ANONYMOUS_SYMB = 10*N_ANONYMOUS_SYMB + BYTE(SY_TEXT,I)
                               - BYTE('0');
      END;
      FIRST_LITERAL = 0;
      DO I = 15 TO 19;
         IF BYTE(SY_TEXT, I) ¬= BYTE(' ') THEN
            FIRST_LITERAL = 10*FIRST_LITERAL + BYTE(SY_TEXT, I) - BYTE('0');
      END;
      PRINT_STATISTICS = (BYTE(SY_TEXT, 20) = BYTE('D'));
      PRINT_SYMBOLS = (BYTE(SY_TEXT, 21) = BYTE('S'));
      IF FIRST_LITERAL < 0 THEN FIRST_LITERAL = NULL;
      GAP = TABLE_LENGTH - N_DECL_SYMB + 1;
      SY_TEXT = INPUT(3);
      DO I = N_PREDECLARED_SYMB + 1 TO N_ANONYMOUS_SYMB - 1;
         IDENTITY(I) = NEXT_SYMBOL;
      END;
      SY_TEXT = INPUT(3);
      CALL RESTORE_COLUMN(ADDR(N_LOOKUPS),2,N_ANONYMOUS_SYMB);
      CALL RESTORE_COLUMN(ADDR(SYMB_LINK),2,N_ANONYMOUS_SYMB);
      CALL RESTORE_COLUMN(ADDR(VALUE),4,N_DECL_SYMB);
      CALL RESTORE_COLUMN(ADDR(VAR_TYPE),2,N_DECL_SYMB);
      CALL RESTORE_COLUMN(ADDR(DATATYPE),2,N_DECL_SYMB);
      CALL RESTORE_COLUMN(ADDR(WHERE_DECL),2,N_ANONYMOUS_SYMB);
      IDENTITY(N_PREDECLARED_SYMB + 1) =
         SUBSTR(IDENTITY(N_PREDECLARED_SYMB + 1), 1);
      CALL REWIND(FALSE, 3);   /* REWIND SYMBOL TABLE FILE */
   END RESTORE_SY_TABLE;

INITIALIZE_SY_TABLE:
   PROCEDURE;
      DECLARE I FIXED;
      DO I = 0 TO TABLE_LENGTH;
         VALUE(I) = 0;
         OWNER(I) = NULL;
         STORAGE_LNGTH(I), S_LIST(I) = NULL;
         PSEUDO_REG(I) , DISPLACEMENT(I) = NULL;
      END;
      DO I = N_PREDECLARED_SYMB + 1 TO TABLE_LENGTH;
         DATATYPE(I) = NULL;
      END;
      VALUE(FALSEPTR) = FALSE;
      VALUE(TRUEPTR) = TRUE;
      VALUE(NILPTR) = "FBFBFBFB";
      VALUE(MAXINTPTR) = MAXINT;
      S_LIST(INTPTR) = MAXINTPTR;
      S_LIST(BOOLPTR) = FALSEPTR;
      S_LIST(FALSEPTR) = TRUEPTR;
      STORAGE_LNGTH(NILPTR) = 4;
      STORAGE_LNGTH(INTPTR), STORAGE_LNGTH(REALPTR) = 4;
      STORAGE_LNGTH(BOOLPTR) = 2;
      STORAGE_LNGTH(CHARPTR) = 256;
      STORAGE_LNGTH(MAXINTPTR) = 4;
      STORAGE_LNGTH(INPUTPTR), STORAGE_LNGTH(OUTPUTPTR) = 2;
      STORAGE_LNGTH(INTFIELDSIZEPTR), STORAGE_LNGTH(BOOLFIELDSIZEPTR) = 4;
      STORAGE_LNGTH(REALFIELDSIZEPTR), STORAGE_LNGTH(DECIMAL_PLACESPTR) = 4;
      PSEUDO_REG(MAXINTPTR) = 0;
      DISPLACEMENT(MAXINTPTR) = DISPLAY_BYTES;
      CALL EMIT_DATA_BYTES(MAXINTPTR);
      PSEUDO_REG(NILPTR) = 0;
      DISPLACEMENT(NILPTR) = DISPLAY_BYTES + 4;
      CALL EMIT_DATA_BYTES(NILPTR);
      PSEUDO_REG(INPUTPTR), PSEUDO_REG(OUTPUTPTR) = 0;
      DISPLACEMENT(INPUTPTR) = DISPLAY_BYTES + 8;
      DISPLACEMENT(OUTPUTPTR) = DISPLAY_BYTES + 10;
      DATA_BYTES(DISPLACEMENT(INPUTPTR) + 1) = BYTE('?');
      DATA_BYTES(DISPLACEMENT(OUTPUTPTR) + 1) = BYTE('?');
      PSEUDO_REG(INTFIELDSIZEPTR), PSEUDO_REG(BOOLFIELDSIZEPTR) = 0;
      PSEUDO_REG(REALFIELDSIZEPTR), PSEUDO_REG(DECIMAL_PLACESPTR) = 0;
      DISPLACEMENT(INTFIELDSIZEPTR) = DISPLAY_BYTES + 12;
      DISPLACEMENT(BOOLFIELDSIZEPTR) = DISPLAY_BYTES + 16;
      DISPLACEMENT(REALFIELDSIZEPTR) = DISPLAY_BYTES + 20;
      DISPLACEMENT(DECIMAL_PLACESPTR) = DISPLAY_BYTES + 24;
      DATA_BYTES(DISPLACEMENT(INTFIELDSIZEPTR) + 3) = 12;
      DATA_BYTES(DISPLACEMENT(BOOLFIELDSIZEPTR) + 3) = 6;
      DATA_BYTES(DISPLACEMENT(REALFIELDSIZEPTR) + 3) = 14;
      DATA_BYTES(DISPLACEMENT(DECIMAL_PLACESPTR) + 3) = 0;
      DO I = DISPLACEMENT(DECIMAL_PLACESPTR) + 4 TO 79;
         DATA_BYTES(I) = 0;
      END;
   END INITIALIZE_SY_TABLE;

INITIALIZE_ARITHMETIC_FUNCTIONS:
   PROCEDURE;
      /* INITIALIZE SYMBOL TABLE ENTRIES FOR SIN, COS, EXP, LN, SQRT
         AND ARCTAN. */
      DECLARE (FUNCTION, PARAM_PTR) BIT(16),
              MONITOR_CODE(5) BIT(8) INITIAL (0, 1, 3, 4, 5, 2);
      /* ALLOCATE SYMBOL TABLE ENTRY FOR FORMAL PARAMETER OF STANDARD
         ARITHMETIC FUNCTIONS */
      PARAM_PTR = NEXT_FREE_ROW;
      DATATYPE(PARAM_PTR) = REALPTR;
      STRUCTYPE(PARAM_PTR) = ARITHMETIC;
      VAR_TYPE(PARAM_PTR) = VARIABLE;
      S_LIST(PARAM_PTR) = NULL;
      DO FUNCTION = SINPTR TO ARCTANPTR;
         S_LIST(FUNCTION) = PARAM_PTR;
         VALUE(FUNCTION) = MONITOR_CODE(FUNCTION-SINPTR);
      END;
   END INITIALIZE_ARITHMETIC_FUNCTIONS;

   /*                 PROCEDURE FOR READING IN A PARSE TREE           */

READ_TREE:
   PROCEDURE FIXED;   /* RETURNS POINTER TO ROOT */
      DECLARE (ROOT, I, J) FIXED;
      ROOT, I = 0;
      SY_TEXT = INPUT(2);
      IF LENGTH(SY_TEXT) = 0 THEN RETURN NULL;
      IF SUBSTR(SY_TEXT, 0, 5) ¬= '%TREE' THEN
         DO;
            OUTPUT = '%TREE CARD EXPECTED.';
            RETURN NULL;
         END;
      DO J = 5 TO 9;
         IF BYTE(SY_TEXT, J) ¬= BYTE(' ') THEN
            ROOT = 10*ROOT + BYTE(SY_TEXT, J) - BYTE('0');
      END;
      PRINT_TREES = (BYTE(SY_TEXT, 10) = BYTE('P'));
      PRINT_TRIPLES = (BYTE(SY_TEXT, 11) = BYTE('T'));
      PRINT_CODE = (BYTE(SY_TEXT, 12) = BYTE('E'));
      SY_TEXT = INPUT(2);
      DO WHILE SUBSTR(SY_TEXT, 0, 4) ¬= '%END';
         J = ADDR(PARSE_TREE(I));
         CALL INLINE("58",1,0,SY_TEXT);          /* L    1,SY_TEXT         */
         CALL INLINE("58",2,0,J);                /* L    2,J               */
         CALL INLINE("D2","4","F",2,0,1,0);      /* MVC  0(80,2),0(1)      */
         I = I + 40;
         SY_TEXT = INPUT(2);
      END;
      LAST_LINE = NULL;
      CURRENT_LINE = PARSE_TREE(ROOT + MULTIPLICITY(ROOT) + 2);
      TREE_SIZE = ROOT + MULTIPLICITY(ROOT) + 3;
      IF GAP > 0 THEN
         DO;
            I = 1;
            DO WHILE I <= ROOT;
               IF MULTIPLICITY(I) = 0 THEN
                  IF PARSE_TREE(I + 1) > N_ANONYMOUS_SYMB THEN
                     PARSE_TREE(I + 1) = PARSE_TREE(I + 1) - GAP;
               I = I + MULTIPLICITY(I) + 3;
            END;
         END;
      IF PRINT_TREES THEN CALL PARSE_TREE_DUMP(ROOT);
      RETURN ROOT;
   END READ_TREE;

EVALUATE_CONSTANTS:
   PROCEDURE;
      DECLARE I BIT(16);
      HALFWORD_DISP(1) = 0;
      I = N_DECL_SYMB - 1;
      CONST_POOL_SIZE =
         DISPLACEMENT(DECIMAL_PLACESPTR) + 4 - DISPLAY_BYTES;
      DO WHILE I >= N_ANONYMOUS_SYMB;
         IF DATATYPE(I) = INTPTR THEN
            DO;
               STORAGE_LNGTH(I) = 4;
               STRUCTYPE(I) = ARITHMETIC;
               S_LIST(I) = S_LIST(INTPTR);
               S_LIST(INTPTR) = I;
               PSEUDO_REG(I) = 0;
               DISPLACEMENT(I) = CONST_POOL_SIZE + DISPLAY_BYTES;
               CONST_POOL_SIZE = CONST_POOL_SIZE + 4;
            END;
         ELSE IF DATATYPE(I) = CHARPTR THEN
            DO;
               STORAGE_LNGTH(I) = 2;
               STRUCTYPE(I) = SCALAR;
               S_LIST(I) = S_LIST(CHARPTR);
               S_LIST(CHARPTR) = I;
               PSEUDO_REG(I) = 0;
               IF HALFWORD_DISP(1) > 0 THEN
                  DO;
                     DISPLACEMENT(I) = HALFWORD_DISP(1);
                     HALFWORD_DISP(1) = 0;
                  END;
               ELSE
                  DO;
                     DISPLACEMENT(I) = CONST_POOL_SIZE + DISPLAY_BYTES;
                     HALFWORD_DISP(1) =
                        CONST_POOL_SIZE + DISPLAY_BYTES + 2;
                     CONST_POOL_SIZE = CONST_POOL_SIZE + 4;
                  END;
            END;
         ELSE   /* DATATYPE(I) = REALPTR */
            DO;
               STORAGE_LNGTH(I) = 4;
               STRUCTYPE(I) = ARITHMETIC;
               S_LIST(I) = S_LIST(REALPTR);
               S_LIST(REALPTR) = I;
               PSEUDO_REG(I) = 0;
               DISPLACEMENT(I) = CONST_POOL_SIZE + DISPLAY_BYTES;
               CONST_POOL_SIZE = CONST_POOL_SIZE + 4;
            END;
         CALL EMIT_DATA_BYTES(I);
         I = I - 1;
      END;
      I = FIRST_LITERAL;
      DO WHILE I ¬= NULL;
         STORAGE_LNGTH(I) = LENGTH(IDENTITY(I));
         STRUCTYPE(I) = ARRAY;
         PSEUDO_REG(I) = 0;
         DISPLACEMENT(I) = CONST_POOL_SIZE + DISPLAY_BYTES;
         CONST_POOL_SIZE = CONST_POOL_SIZE + STORAGE_LNGTH(I);
         CALL EMIT_DATA_BYTES(I);
         I = SYMB_LINK(I);
      END;
      CONST_POOL_SIZE = (CONST_POOL_SIZE + 3) & "FFFFFC";
   END EVALUATE_CONSTANTS;

MAIN_PROCEDURE:
   PROCEDURE;
      CALL INITIALIZE_SY_TABLE;
      CALL RESTORE_SY_TABLE;
      CALL EVALUATE_CONSTANTS;
      CALL INITIALIZE_ARITHMETIC_FUNCTIONS;
      ROOT_OF_SUBTREE = READ_TREE;
      DO WHILE ROOT_OF_SUBTREE ¬= NULL;
         CALL VISIT_NODES;
         ROOT_OF_SUBTREE = READ_TREE;
      END;
      IF PRINT_SYMBOLS THEN CALL SY_DUMP;
      CALL WRITE_SYMBOLS;
      OUTPUT(5) = COREIM_DESCRIPT(ADDR(DATA_BYTES), 80);
      CALL REWIND(TRUE, 5);   /* REWIND DATA FILE */
   END MAIN_PROCEDURE;

   WITH_PTR = NULL;
   FORWARD_AVAIL = NULL;
   FORWARD_LIMIT = 0;
   CALL MAIN_PROCEDURE;

   IF SEVERE_ERRORS + MONITOR_LINK(3) > 0 THEN
      DO;
         MONITOR_LINK(0) = NULL;   /* ABORT COMPILATION */
         CALL PRINT_COMPILE_TIME;
      END;
   ELSE IF MONITOR_LINK(2) > 0 THEN   /* DEBUG LEVEL > 0 */
      CALL PREPARE_POST_MORTEM_TABLES;
EOF EOF EOF
